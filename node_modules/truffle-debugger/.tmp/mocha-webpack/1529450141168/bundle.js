(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Debugger", [], factory);
	else if(typeof exports === 'object')
		exports["Debugger"] = factory();
	else
		root["Debugger"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 56);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("debug");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/regenerator");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/toConsumableArray");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/defineProperty");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/slicedToArray");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/entries");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prefixName = prefixName;
exports.keccak256 = keccak256;

var _utils = __webpack_require__(15);

function prefixName(prefix, fn) {
  Object.defineProperty(fn, 'name', {
    value: prefix + "." + fn.name,
    configurable: true
  });

  return fn;
}

/**
 * @return 0x-prefix string of keccak256 hash
 */
function keccak256() {
  return (0, _utils.toHexString)(_utils.keccak256.apply(undefined, arguments));
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(3);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _toConsumableArray2 = __webpack_require__(2);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _extends2 = __webpack_require__(13);

var _extends3 = _interopRequireDefault(_extends2);

var _slicedToArray2 = __webpack_require__(4);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(12);

var _selectors = __webpack_require__(26);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger:evm:selectors");

var WORD_SIZE = 0x20;

/**
 * create EVM-level selectors for a given trace step selector
 * may specify additional selectors to include
 */
function createStepSelectors(step) {
  var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var base = {
    /**
     * .trace
     *
     * trace step info related to operation
     */
    trace: (0, _reselectTree.createLeaf)([step], function (_ref) {
      var gasCost = _ref.gasCost,
          op = _ref.op,
          pc = _ref.pc;
      return { gasCost: gasCost, op: op, pc: pc };
    }),

    /**
     * .programCounter
     */
    programCounter: (0, _reselectTree.createLeaf)(["./trace"], function (step) {
      return step.pc;
    }),

    /**
     * .isJump
     */
    isJump: (0, _reselectTree.createLeaf)(["./trace"], function (step) {
      return step.op != "JUMPDEST" && step.op.indexOf("JUMP") == 0;
    }),

    /**
     * .isCall
     *
     * whether the opcode will switch to another calling context
     */
    isCall: (0, _reselectTree.createLeaf)(["./trace"], function (step) {
      return step.op == "CALL" || step.op == "DELEGATECALL";
    }),

    /**
     * .isCreate
     */
    isCreate: (0, _reselectTree.createLeaf)(["./trace"], function (step) {
      return step.op == "CREATE";
    }),

    /**
     * .isHalting
     *
     * whether the instruction halts or returns from a calling context
     */
    isHalting: (0, _reselectTree.createLeaf)(["./trace"], function (step) {
      return step.op == "STOP" || step.op == "RETURN";
    })
  };

  if (state) {
    var isRelative = function isRelative(path) {
      return typeof path == "string" && (path.startsWith("./") || path.startsWith("../"));
    };

    if (isRelative(state)) {
      state = "../" + state;
    }

    (0, _assign2.default)(base, {
      /**
       * .callAddress
       *
       * address transferred to by call operation
       */
      callAddress: (0, _reselectTree.createLeaf)(["./isCall", "./trace", state], function (matches, step, _ref2) {
        var stack = _ref2.stack;

        if (!matches) return null;

        var address = stack[stack.length - 2];
        address = "0x" + address.substring(24);
        return address;
      }),

      /**
       * .createBinary
       *
       * binary code to execute via create operation
       */
      createBinary: (0, _reselectTree.createLeaf)(["./isCreate", "./trace", state], function (matches, step, _ref3) {
        var stack = _ref3.stack,
            memory = _ref3.memory;

        if (!matches) return null;

        // Get the code that's going to be created from memory.
        // Note we multiply by 2 because these offsets are in bytes.
        var offset = parseInt(stack[stack.length - 2], 16) * 2;
        var length = parseInt(stack[stack.length - 3], 16) * 2;

        return "0x" + memory.join("").substring(offset, offset + length);
      })
    });
  }

  return base;
}

var evm = (0, _reselectTree.createSelectorTree)({
  /**
   * evm.state
   */
  state: function state(_state) {
    return _state.evm;
  },

  /**
   * evm.info
   */
  info: {
    /**
     * evm.info.contexts
     */
    contexts: (0, _reselectTree.createLeaf)(['/state'], function (state) {
      return state.info.contexts.byContext;
    }),

    /**
     * evm.info.instances
     */
    instances: (0, _reselectTree.createLeaf)(['/state'], function (state) {
      return state.info.instances.byAddress;
    }),

    /**
     * evm.info.binaries
     */
    binaries: {
      _: (0, _reselectTree.createLeaf)(['/state'], function (state) {
        return state.info.contexts.byBinary;
      }),

      /**
       * evm.info.binaries.search
       *
       * returns function (binary) => context
       */
      search: (0, _reselectTree.createLeaf)(['./_'], function (binaries) {
        // HACK ignore link references for search
        // link references come in two forms: with underscores or all zeroes
        // the underscore format is used by Truffle to reference links by name
        // zeroes are used by solc directly, as libraries inject their own
        // address at CREATE-time
        var toRegExp = function toRegExp(binary) {
          return new RegExp("^" + binary.replace(/__.{38}|0{40}/g, ".{40}"));
        };

        var matchers = (0, _entries2.default)(binaries).map(function (_ref4) {
          var _ref5 = (0, _slicedToArray3.default)(_ref4, 2),
              binary = _ref5[0],
              context = _ref5[1].context;

          return {
            context: context,
            regex: toRegExp(binary)
          };
        });

        return function (binary) {
          return matchers.filter(function (_ref6) {
            var context = _ref6.context,
                regex = _ref6.regex;
            return binary.match(regex);
          }).map(function (_ref7) {
            var context = _ref7.context;
            return { context: context };
          })[0] || null;
        };
      })
    }
  },

  /**
   * evm.current
   */
  current: {

    /**
     * evm.current.callstack
     */
    callstack: function callstack(state) {
      return state.evm.proc.callstack;
    },

    /**
     * evm.current.call
     */
    call: (0, _reselectTree.createLeaf)(["./callstack"], function (stack) {
      return stack.length ? stack[stack.length - 1] : {};
    }),

    /**
     * evm.current.context
     */
    context: (0, _reselectTree.createLeaf)(["./call", "/info/instances", "/info/binaries/search", "/info/contexts"], function (_ref8, instances, search, contexts) {
      var address = _ref8.address,
          binary = _ref8.binary;

      var record = void 0;
      if (address) {
        record = instances[address];
        binary = record.binary;
      } else {
        record = search(binary);
      }

      var context = contexts[(record || {}).context];

      return (0, _extends3.default)({}, context, {
        binary: binary
      });
    }),

    /**
     * evm.current.state
     *
     * evm state info: as of last operation, before op defined in step
     */
    state: _assign2.default.apply(Object, [{}].concat((0, _toConsumableArray3.default)(["depth", "error", "gas", "memory", "stack", "storage"].map(function (param) {
      return (0, _defineProperty3.default)({}, param, (0, _reselectTree.createLeaf)([_selectors2.default.step], function (step) {
        return step[param];
      }));
    })))),

    /**
     * evm.current.step
     */
    step: createStepSelectors(_selectors2.default.step, "./state")
  },

  /**
   * evm.next
   */
  next: {

    /**
     * evm.next.state
     *
     * evm state as a result of next step operation
     */
    state: _assign2.default.apply(Object, [{}].concat((0, _toConsumableArray3.default)(["depth", "error", "gas", "memory", "stack", "storage"].map(function (param) {
      return (0, _defineProperty3.default)({}, param, (0, _reselectTree.createLeaf)([_selectors2.default.next], function (step) {
        return step[param];
      }));
    })))),

    step: createStepSelectors(_selectors2.default.next, "./state")
  }
});

exports.default = evm;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/assign");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = __webpack_require__(17);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _extends2 = __webpack_require__(13);

var _extends3 = _interopRequireDefault(_extends2);

var _defineProperty2 = __webpack_require__(3);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _slicedToArray2 = __webpack_require__(4);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _toConsumableArray2 = __webpack_require__(2);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(12);

var _truffleSolidityUtils = __webpack_require__(94);

var _truffleSolidityUtils2 = _interopRequireDefault(_truffleSolidityUtils);

var _truffleCodeUtils = __webpack_require__(95);

var _truffleCodeUtils2 = _interopRequireDefault(_truffleCodeUtils);

var _selectors = __webpack_require__(7);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger:solidity:selectors");

function getSourceRange() {
  var instruction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return {
    start: instruction.start || 0,
    length: instruction.length || 0,
    lines: instruction.range || {
      start: {
        line: 0, column: 0
      },
      end: {
        line: 0, column: 0
      }
    }
  };
}

var solidity = (0, _reselectTree.createSelectorTree)({
  /**
   * solidity.state
   */
  state: function state(_state) {
    return _state.solidity;
  },

  /**
   * solidity.info
   */
  info: {
    /**
     * solidity.info.sources
     */
    sources: (0, _reselectTree.createLeaf)(['/state'], function (state) {
      return state.info.sources.byId;
    }),

    /**
     * solidity.info.sourceMaps
     */
    sourceMaps: (0, _reselectTree.createLeaf)(['/state'], function (state) {
      return state.info.sourceMaps.byContext;
    })
  },

  /**
   * solidity.current
   */
  current: {

    /**
     * solidity.current.sourceMap
     */
    sourceMap: (0, _reselectTree.createLeaf)([_selectors2.default.current.context, "/info/sourceMaps"], function (_ref, sourceMaps) {
      var context = _ref.context;
      return sourceMaps[context] || {};
    }),

    /**
     * solidity.current.functionDepth
     */
    functionDepth: function functionDepth(state) {
      return state.solidity.proc.functionDepth;
    },

    /**
     * solidity.current.instructions
     */
    instructions: (0, _reselectTree.createLeaf)(["/info/sources", _selectors2.default.current.context, "./sourceMap"], function (sources, _ref2, _ref3) {
      var binary = _ref2.binary;
      var sourceMap = _ref3.sourceMap;

      var instructions = _truffleCodeUtils2.default.parseCode(binary);

      if (!sourceMap) {
        // Let's create a source map to use since none exists. This source map
        // maps just as many ranges as there are instructions, and ensures every
        // instruction is marked as "jumping out". This will ensure all
        // available debugger commands step one instruction at a time.
        //
        // This is kindof a hack; perhaps this should be broken out into separate
        // context types. TODO
        sourceMap = "";
        for (var i = 0; i < instructions.length; i++) {
          sourceMap += i + ":" + i + ":1:-1;";
        }
      }

      var lineAndColumnMappings = _assign2.default.apply(Object, [{}].concat((0, _toConsumableArray3.default)((0, _entries2.default)(sources).map(function (_ref4) {
        var _ref5 = (0, _slicedToArray3.default)(_ref4, 2),
            id = _ref5[0],
            source = _ref5[1].source;

        return (0, _defineProperty3.default)({}, id, _truffleSolidityUtils2.default.getCharacterOffsetToLineAndColumnMapping(source || ""));
      }))));
      var humanReadableSourceMap = _truffleSolidityUtils2.default.getHumanReadableSourceMap(sourceMap);

      var primaryFile = humanReadableSourceMap[0].file;
      debug("primaryFile %o", primaryFile);

      return instructions.map(function (instruction, index) {
        // lookup source map by index and add `index` property to
        // instruction
        //

        var sourceMap = humanReadableSourceMap[index] || {};

        return {
          instruction: (0, _extends3.default)({}, instruction, { index: index }),
          sourceMap: sourceMap
        };
      }).map(function (_ref7) {
        var instruction = _ref7.instruction,
            sourceMap = _ref7.sourceMap;

        // add source map information to instruction, or defaults
        //

        var jump = sourceMap.jump,
            _sourceMap$start = sourceMap.start,
            start = _sourceMap$start === undefined ? 0 : _sourceMap$start,
            _sourceMap$length = sourceMap.length,
            length = _sourceMap$length === undefined ? 0 : _sourceMap$length,
            _sourceMap$file = sourceMap.file,
            file = _sourceMap$file === undefined ? primaryFile : _sourceMap$file;

        var lineAndColumnMapping = lineAndColumnMappings[file] || {};
        var range = {
          start: lineAndColumnMapping[start] || { line: null, column: null },
          end: lineAndColumnMapping[start + length] || { line: null, column: null }
        };

        if (range.start.line === null) {
          debug("sourceMap %o", sourceMap);
        }

        return (0, _extends3.default)({}, instruction, {

          jump: jump,
          start: start,
          length: length,
          file: file,
          range: range
        });
      });
    }),

    /**
     * solidity.current.instructionAtProgramCounter
     */
    instructionAtProgramCounter: (0, _reselectTree.createLeaf)(["./instructions"], function (instructions) {
      var map = [];
      instructions.forEach(function (instruction) {
        map[instruction.pc] = instruction;
      });

      // fill in gaps in map by defaulting to the last known instruction
      var lastSeen = null;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(map.entries()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ref8 = _step.value;

          var _ref9 = (0, _slicedToArray3.default)(_ref8, 2);

          var pc = _ref9[0];
          var instruction = _ref9[1];

          if (instruction) {
            lastSeen = instruction;
          } else {
            map[pc] = lastSeen;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return map;
    }),

    /**
     * solidity.current.instruction
     */
    instruction: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors2.default.current.step.programCounter], function (map, pc) {
      return map[pc] || {};
    }),

    /**
     * solidity.current.source
     */
    source: (0, _reselectTree.createLeaf)(["/info/sources", "./instruction"], function (sources, _ref10) {
      var id = _ref10.file;
      return sources[id] || {};
    }),

    /**
     * solidity.current.sourceRange
     */
    sourceRange: (0, _reselectTree.createLeaf)(["./instruction"], getSourceRange),

    /**
     * solidity.current.isSourceRangeFinal
     */
    isSourceRangeFinal: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors2.default.current.step.programCounter, _selectors2.default.next.step.programCounter], function (map, current, next) {
      if (!map[next]) {
        return true;
      }

      current = map[current];
      next = map[next];

      return current.start != next.start || current.length != next.length || current.file != next.file;
    }),

    /**
     * solidity.current.isMultiline
     */
    isMultiline: (0, _reselectTree.createLeaf)(["./sourceRange"], function (_ref11) {
      var lines = _ref11.lines;
      return lines.start.line != lines.end.line;
    }),

    /**
     * solidity.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], function (isJump) {
      return isJump;
    }),

    /**
     * solidity.current.jumpDirection
     */
    jumpDirection: (0, _reselectTree.createLeaf)(["./instruction"], function () {
      var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return i.jump || "-";
    })
  }
});

exports.default = solidity;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/asyncToGenerator");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("web3");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("reselect-tree");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/extends");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("redux-saga/effects");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MAX_WORD = exports.WORD_SIZE = undefined;

var _getIterator2 = __webpack_require__(17);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _defineProperty2 = __webpack_require__(3);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _slicedToArray2 = __webpack_require__(4);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _toConsumableArray2 = __webpack_require__(2);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _typeof2 = __webpack_require__(46);

var _typeof3 = _interopRequireDefault(_typeof2);

exports.cleanBigNumbers = cleanBigNumbers;
exports.typeIdentifier = typeIdentifier;
exports.typeClass = typeClass;
exports.allocateDeclarations = allocateDeclarations;
exports.specifiedSize = specifiedSize;
exports.storageSize = storageSize;
exports.isReference = isReference;
exports.referenceType = referenceType;
exports.baseDefinition = baseDefinition;
exports.toBigNumber = toBigNumber;
exports.toSignedBigNumber = toSignedBigNumber;
exports.toHexString = toHexString;
exports.toBytes = toBytes;
exports.keccak256 = keccak256;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _bignumber = __webpack_require__(27);

var _web = __webpack_require__(11);

var _web2 = _interopRequireDefault(_web);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger:data:decode:utils");

var WORD_SIZE = exports.WORD_SIZE = 0x20;
var MAX_WORD = exports.MAX_WORD = new _bignumber.BigNumber(2).pow(256).minus(1);

/**
 * recursively converts big numbers into something nicer to look at
 */
function cleanBigNumbers(value) {
  if (_bignumber.BigNumber.isBigNumber(value)) {
    return value.toNumber();
  } else if (value && value.map != undefined) {
    return value.map(function (inner) {
      return cleanBigNumbers(inner);
    });
  } else if (value && (typeof value === "undefined" ? "undefined" : (0, _typeof3.default)(value)) == "object") {
    return _assign2.default.apply(Object, [{}].concat((0, _toConsumableArray3.default)((0, _entries2.default)(value).map(function (_ref) {
      var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
          key = _ref2[0],
          inner = _ref2[1];

      return (0, _defineProperty3.default)({}, key, cleanBigNumbers(inner));
    }))));
  } else {
    return value;
  }
}

function typeIdentifier(definition) {
  return definition.typeDescriptions.typeIdentifier;
}

/**
 * returns basic type class for a variable definition node
 * e.g.:
 *  `t_uint256` becomes `uint`
 *  `t_struct$_Thing_$20_memory_ptr` becomes `struct`
 */
function typeClass(definition) {
  return typeIdentifier(definition).match(/t_([^$_0-9]+)/)[1];
}

/**
 * Allocate storage for given variable declarations
 *
 * Postcondition: starts a new slot and occupies whole slots
 */
function allocateDeclarations(declarations, refs) {
  var slot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : WORD_SIZE - 1;
  var path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];

  if (index < WORD_SIZE - 1) {
    // starts a new slot
    slot++;
    index = WORD_SIZE - 1;
  }

  var parentFrom = { slot: slot, index: 0 };
  var parentTo = { slot: slot, index: WORD_SIZE - 1 };
  var mapping = {};

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(declarations), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var declaration = _step.value;

      var _allocateDeclaration = allocateDeclaration(declaration, refs, slot, index),
          from = _allocateDeclaration.from,
          to = _allocateDeclaration.to,
          next = _allocateDeclaration.next,
          children = _allocateDeclaration.children;

      mapping[declaration.id] = { from: from, to: to, name: declaration.name };
      if (children !== undefined) {
        mapping[declaration.id].children = children;
      }

      slot = next.slot;
      index = next.index;

      parentTo = { slot: to.slot, index: WORD_SIZE - 1 };
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (index < WORD_SIZE - 1) {
    slot++;
    index = WORD_SIZE - 1;
  }

  return {
    from: parentFrom,
    to: parentTo,
    next: { slot: slot, index: index },
    children: mapping
  };
}

function allocateValue(slot, index, bytes) {
  var from = index - bytes + 1 >= 0 ? { slot: slot, index: index - bytes + 1 } : { slot: slot + 1, index: WORD_SIZE - bytes };

  var to = { slot: from.slot, index: from.index + bytes - 1 };

  var next = from.index == 0 ? { slot: from.slot + 1, index: WORD_SIZE - 1 } : { slot: from.slot, index: from.index - 1 };

  return { from: from, to: to, next: next };
}

function allocateDeclaration(declaration, refs, slot, index) {
  var definition = refs[declaration.id].definition;
  var byteSize = storageSize(definition); // yum

  if (typeClass(definition) != "struct") {
    return allocateValue(slot, index, byteSize);
  }

  var struct = refs[definition.typeName.referencedDeclaration];
  debug("struct: %O", struct);

  var result = allocateDeclarations(struct.variables || [], refs, slot, index);
  debug("struct result %o", result);
  return result;
}

/**
 * e.g. uint48 -> 6
 * @return size in bytes for explicit type size, or `null` if not stated
 */
function specifiedSize(definition) {
  var specified = typeIdentifier(definition).match(/t_[a-z]+([0-9]+)/);

  if (!specified) {
    return null;
  }

  var num = specified[1];

  switch (typeClass(definition)) {
    case "int":
    case "uint":
      return num / 8;

    case "bytes":
      return num;

    default:
      debug("Unknown type for size specification: %s", typeIdentifier(definition));
  }
}

function storageSize(definition) {
  switch (typeClass(definition)) {
    case "bool":
      return 1;

    case "address":
      return 20;

    case "int":
    case "uint":
      // is this a HACK? ("256" / 8)
      return typeIdentifier(definition).match(/t_[a-z]+([0-9]+)/)[1] / 8;

    case "string":
    case "bytes":
    case "array":
      return WORD_SIZE;
  }
}

function isReference(definition) {
  return typeIdentifier(definition).match(/_(memory|storage)(_ptr)?$/) != null;
}

function referenceType(definition) {
  return typeIdentifier(definition).match(/_([^_]+)(_ptr)?$/)[1];
}

function baseDefinition(definition) {
  var baseIdentifier = typeIdentifier(definition)
  // first dollar sign     last dollar sign
  //   `---------.       ,---'
  .match(/^[^$]+\$_(.+)_\$[^$]+$/)[1];
  //              `----' greedy match

  // HACK - internal types for memory or storage also seem to be pointers
  if (baseIdentifier.match(/_(memory|storage)$/) != null) {
    baseIdentifier = baseIdentifier + "_ptr";
  }

  // another HACK - we get away with it becausewe're only using that one property
  return {
    typeDescriptions: {
      typeIdentifier: baseIdentifier
    }
  };
}

function toBigNumber(bytes) {
  if (bytes == undefined) {
    return undefined;
  } else if (typeof bytes == "string") {
    return new _bignumber.BigNumber(bytes, 16);
  } else if (typeof bytes == "number" || _bignumber.BigNumber.isBigNumber(bytes)) {
    return new _bignumber.BigNumber(bytes);
  } else if (bytes.reduce) {
    return bytes.reduce(function (num, byte) {
      return num.times(0x100).plus(byte);
    }, new _bignumber.BigNumber(0));
  }
}

function toSignedBigNumber(bytes) {
  if (bytes[0] < 128) {
    // first bit is 0
    return toBigNumber(bytes);
  } else {
    return toBigNumber(bytes.map(function (b) {
      return 0xff - b;
    })).plus(1).negated();
  }
}

/**
 * @param bytes - Uint8Array
 * @param length - desired byte length (pad with zeroes)
 * @param trim - omit leading zeroes
 */
function toHexString(bytes) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var trim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (typeof length == "boolean") {
    trim = length;
    length = 0;
  }

  if (_bignumber.BigNumber.isBigNumber(bytes)) {
    bytes = toBytes(bytes);
  }

  var pad = function pad(s) {
    return "" + "00".slice(0, 2 - s.length) + s;
  };

  //                                          0  1  2  3  4
  //                                 0  1  2  3  4  5  6  7
  // bytes.length:        5  -  0x(          e5 c2 aa 09 11 )
  // length (preferred):  8  -  0x( 00 00 00 e5 c2 aa 09 11 )
  //                                `--.---'
  //                                     offset 3
  if (bytes.length < length) {
    var prior = bytes;
    bytes = new Uint8Array(length);

    bytes.set(prior, length - prior.length);
  }

  debug("bytes: %o", bytes);

  var string = bytes.reduce(function (str, byte) {
    return "" + str + pad(byte.toString(16));
  }, "");

  if (trim) {
    string = string.replace(/^(00)+/, "");
  }

  if (string.length == 0) {
    string = "00";
  }

  return "0x" + string;
}

function toBytes(number) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  if (number < 0) {
    return [];
  }

  var hex = number.toString(16);
  if (hex.length % 2 == 1) {
    hex = "0" + hex;
  }

  var bytes = new Uint8Array(hex.match(/.{2}/g).map(function (byte) {
    return parseInt(byte, 16);
  }));

  if (bytes.length < length) {
    var prior = bytes;
    bytes = new Uint8Array(length);
    bytes.set(prior, length - prior.length);
  }

  return bytes;
}

function keccak256() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var web3 = new _web2.default();

  args = args.map(function (arg) {
    if (typeof arg == "number" || _bignumber.BigNumber.isBigNumber(arg)) {
      return toHexString(toBytes(arg, WORD_SIZE)).slice(2);
    } else if (typeof arg == "string") {
      return web3.toHex(arg).slice(2);
    } else {
      return "";
    }
  });

  var sha = web3.sha3(args.join(''), { encoding: 'hex' });
  debug("sha %o", sha);
  return toBigNumber(sha);
}

/***/ }),
/* 16 */
/***/ (function(module, exports) {

/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @namespace Utils
 * @name flag
 * @api private
 */

module.exports = function (obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};


/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/get-iterator");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(58);


/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

   includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40

};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gatherArtifacts = exports.migrate = exports.compile = exports.defaultMigrations = exports.addMigrations = exports.addContracts = exports.createSandbox = exports.prepareContracts = undefined;

var _getIterator2 = __webpack_require__(17);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = __webpack_require__(31);

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _asyncToGenerator2 = __webpack_require__(10);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var prepareContracts = exports.prepareContracts = function () {
  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(provider) {
    var sources = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var migrations = arguments[2];

    var config, accounts, _ref2, contracts, files, contractNames, artifacts, abstractions;

    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return createSandbox();

          case 2:
            config = _context.sent;
            _context.next = 5;
            return getAccounts(provider);

          case 5:
            accounts = _context.sent;


            config.networks["debugger"] = {
              provider: provider,
              network_id: "*",
              from: accounts[0]
            };
            config.network = "debugger";

            _context.next = 10;
            return addContracts(config, sources);

          case 10:
            _context.next = 12;
            return compile(config);

          case 12:
            _ref2 = _context.sent;
            contracts = _ref2.contracts;
            files = _ref2.files;
            contractNames = (0, _keys2.default)(contracts);

            if (migrations) {
              _context.next = 20;
              break;
            }

            _context.next = 19;
            return defaultMigrations(contractNames);

          case 19:
            migrations = _context.sent;

          case 20:
            _context.next = 22;
            return addMigrations(config, migrations);

          case 22:
            _context.next = 24;
            return migrate(config);

          case 24:
            _context.next = 26;
            return gatherArtifacts(config);

          case 26:
            artifacts = _context.sent;

            debug("artifacts: %o", artifacts.map(function (a) {
              return a.contractName;
            }));

            abstractions = {};

            contractNames.forEach(function (name) {
              abstractions[name] = config.resolver.require(name);
            });

            return _context.abrupt("return", {
              files: files,
              abstractions: abstractions,
              artifacts: artifacts,
              config: config
            });

          case 31:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function prepareContracts(_x2) {
    return _ref.apply(this, arguments);
  };
}();

var createSandbox = exports.createSandbox = function () {
  var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
    var config;
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return new _promise2.default(function (accept, reject) {
              _truffleBox2.default.sandbox(function (err, result) {
                if (err) return reject(err);
                result.resolver = new _truffleResolver2.default(result);
                result.artifactor = new _truffleArtifactor2.default(result.contracts_build_directory);
                result.networks = {};

                accept(result);
              });
            });

          case 2:
            config = _context2.sent;
            _context2.next = 5;
            return _fsExtra2.default.remove(_path2.default.join(config.contracts_directory, "MetaCoin.sol"));

          case 5:
            _context2.next = 7;
            return _fsExtra2.default.remove(_path2.default.join(config.contracts_directory, "ConvertLib.sol"));

          case 7:
            _context2.next = 9;
            return _fsExtra2.default.remove(_path2.default.join(config.migrations_directory, "2_deploy_contracts.js"));

          case 9:
            return _context2.abrupt("return", config);

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function createSandbox() {
    return _ref3.apply(this, arguments);
  };
}();

var addContracts = exports.addContracts = function () {
  var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(config) {
    var sources = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var promises, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, filename, source;

    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            promises = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context3.prev = 4;

            for (_iterator = (0, _getIterator3.default)((0, _keys2.default)(sources)); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              filename = _step.value;
              source = sources[filename];

              promises.push(_fsExtra2.default.outputFile(_path2.default.join(config.contracts_directory, filename), source));
            }

            _context3.next = 12;
            break;

          case 8:
            _context3.prev = 8;
            _context3.t0 = _context3["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context3.t0;

          case 12:
            _context3.prev = 12;
            _context3.prev = 13;

            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }

          case 15:
            _context3.prev = 15;

            if (!_didIteratorError) {
              _context3.next = 18;
              break;
            }

            throw _iteratorError;

          case 18:
            return _context3.finish(15);

          case 19:
            return _context3.finish(12);

          case 20:
            _context3.next = 22;
            return _promise2.default.all(promises);

          case 22:
            return _context3.abrupt("return", _context3.sent);

          case 23:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[4, 8, 12, 20], [13,, 15, 19]]);
  }));

  return function addContracts(_x4) {
    return _ref4.apply(this, arguments);
  };
}();

var addMigrations = exports.addMigrations = function () {
  var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(config) {
    var migrations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var promises, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, filename, source;

    return _regenerator2.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            promises = [];
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _iteratorError2 = undefined;
            _context4.prev = 4;

            for (_iterator2 = (0, _getIterator3.default)((0, _keys2.default)(migrations)); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              filename = _step2.value;
              source = migrations[filename];

              promises.push(_fsExtra2.default.outputFile(_path2.default.join(config.migrations_directory, filename), source));
            }

            _context4.next = 12;
            break;

          case 8:
            _context4.prev = 8;
            _context4.t0 = _context4["catch"](4);
            _didIteratorError2 = true;
            _iteratorError2 = _context4.t0;

          case 12:
            _context4.prev = 12;
            _context4.prev = 13;

            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }

          case 15:
            _context4.prev = 15;

            if (!_didIteratorError2) {
              _context4.next = 18;
              break;
            }

            throw _iteratorError2;

          case 18:
            return _context4.finish(15);

          case 19:
            return _context4.finish(12);

          case 20:
            _context4.next = 22;
            return _promise2.default.all(promises);

          case 22:
            return _context4.abrupt("return", _context4.sent);

          case 23:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[4, 8, 12, 20], [13,, 15, 19]]);
  }));

  return function addMigrations(_x6) {
    return _ref5.apply(this, arguments);
  };
}();

var defaultMigrations = exports.defaultMigrations = function () {
  var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(contractNames) {
    var migrations;
    return _regenerator2.default.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            contractNames = contractNames.filter(function (name) {
              return name != "Migrations";
            });

            migrations = {};


            contractNames.forEach(function (contractName, i) {
              var index = i + 2; // start at 2 cause Migrations migration
              var filename = index + "_migrate_" + contractName + ".js";
              var source = "\n      var " + contractName + " = artifacts.require(\"" + contractName + "\");\n\n      module.exports = function(deployer) {\n        deployer.deploy(" + contractName + ");\n      };\n    ";

              migrations[filename] = source;
            });

            return _context5.abrupt("return", migrations);

          case 4:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));

  return function defaultMigrations(_x7) {
    return _ref6.apply(this, arguments);
  };
}();

var compile = exports.compile = function () {
  var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(config) {
    return _regenerator2.default.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.abrupt("return", new _promise2.default(function (accept, reject) {
              _truffleWorkflowCompile2.default.compile(config.with({
                all: true,
                quiet: true
              }), function (err, contracts, files) {
                if (err) return reject(err);
                return accept({ contracts: contracts, files: files });
              });
            }));

          case 1:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));

  return function compile(_x8) {
    return _ref7.apply(this, arguments);
  };
}();

var migrate = exports.migrate = function () {
  var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7(config) {
    return _regenerator2.default.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            return _context7.abrupt("return", new _promise2.default(function (accept, reject) {
              _truffleMigrate2.default.run(config.with({
                quiet: true
              }), function (err, contracts) {
                if (err) return reject(err);
                accept(contracts);
              });
            }));

          case 1:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this);
  }));

  return function migrate(_x9) {
    return _ref8.apply(this, arguments);
  };
}();

var gatherArtifacts = exports.gatherArtifacts = function () {
  var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(config) {
    return _regenerator2.default.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            return _context8.abrupt("return", _truffleDebugUtils2.default.gatherArtifacts(config));

          case 1:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this);
  }));

  return function gatherArtifacts(_x10) {
    return _ref9.apply(this, arguments);
  };
}();

exports.getAccounts = getAccounts;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _path = __webpack_require__(83);

var _path2 = _interopRequireDefault(_path);

var _fsExtra = __webpack_require__(84);

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _async = __webpack_require__(85);

var _async2 = _interopRequireDefault(_async);

var _truffleWorkflowCompile = __webpack_require__(86);

var _truffleWorkflowCompile2 = _interopRequireDefault(_truffleWorkflowCompile);

var _truffleDebugUtils = __webpack_require__(87);

var _truffleDebugUtils2 = _interopRequireDefault(_truffleDebugUtils);

var _truffleArtifactor = __webpack_require__(88);

var _truffleArtifactor2 = _interopRequireDefault(_truffleArtifactor);

var _web = __webpack_require__(11);

var _web2 = _interopRequireDefault(_web);

var _truffleMigrate = __webpack_require__(89);

var _truffleMigrate2 = _interopRequireDefault(_truffleMigrate);

var _truffleBox = __webpack_require__(90);

var _truffleBox2 = _interopRequireDefault(_truffleBox);

var _truffleResolver = __webpack_require__(91);

var _truffleResolver2 = _interopRequireDefault(_truffleResolver);

var _truffleExpect = __webpack_require__(45);

var _truffleExpect2 = _interopRequireDefault(_truffleExpect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)("test:helpers");

function getAccounts(provider) {
  var web3 = new _web2.default(provider);
  return new _promise2.default(function (accept, reject) {
    web3.eth.getAccounts(function (err, accounts) {
      if (err) return reject(err);
      accept(accounts);
    });
  });
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(12);

var _jsonPointer = __webpack_require__(34);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _map = __webpack_require__(47);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger:ast:selectors");

/**
 * ast
 */
var ast = (0, _reselectTree.createSelectorTree)({
  /**
   * ast.views
   */
  views: {
    /**
     * ast.views.sources
     */
    sources: (0, _reselectTree.createLeaf)([_selectors2.default.info.sources], function (sources) {
      return sources;
    })
  },

  /**
   * ast.current
   */
  current: {

    /**
     * ast.current.tree
     *
     * ast for current source
     */
    tree: (0, _reselectTree.createLeaf)([_selectors2.default.current.source], function (_ref) {
      var ast = _ref.ast;
      return ast;
    }),

    /**
     * ast.current.index
     *
     * source ID
     */
    index: (0, _reselectTree.createLeaf)([_selectors2.default.current.source], function (_ref2) {
      var id = _ref2.id;
      return id;
    }),

    /**
     * ast.current.pointer
     *
     * jsonpointer for current ast node
     */
    pointer: (0, _reselectTree.createLeaf)(["./tree", _selectors2.default.current.sourceRange], function (ast, range) {
      return (0, _map.findRange)(ast, range.start, range.length);
    }),

    /**
     * ast.current.node
     *
     * current ast node to execute
     */
    node: (0, _reselectTree.createLeaf)(["./tree", "./pointer"], function (ast, pointer) {
      return pointer ? _jsonPointer2.default.get(ast, pointer) : _jsonPointer2.default.get(ast, "");
    })

  }
});

exports.default = ast;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("redux");

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = require("ganache-cli");

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/keys");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(10);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(32);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(33);

var _createClass3 = _interopRequireDefault(_createClass2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _truffleExpect = __webpack_require__(45);

var _truffleExpect2 = _interopRequireDefault(_truffleExpect);

var _session = __webpack_require__(92);

var _session2 = _interopRequireDefault(_session);

var _reselectTree = __webpack_require__(12);

var _selectors = __webpack_require__(36);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(21);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(26);

var _selectors6 = _interopRequireDefault(_selectors5);

var _selectors7 = __webpack_require__(7);

var _selectors8 = _interopRequireDefault(_selectors7);

var _selectors9 = __webpack_require__(9);

var _selectors10 = _interopRequireDefault(_selectors9);

var _selectors11 = __webpack_require__(54);

var _selectors12 = _interopRequireDefault(_selectors11);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger");

/**
 * @example
 * let session = Debugger
 *   .forTx(<txHash>, {
 *     contracts: [<contract obj>, ...],
 *     provider: <provider instance>
 *   })
 *   .connect();
 */

var Debugger = function () {
  /**
   * @param {Session} session - debugger session
   * @private
   */
  function Debugger(session) {
    (0, _classCallCheck3.default)(this, Debugger);

    /**
     * @private
     */
    this._session = session;
  }

  /**
   * Instantiates a Debugger for a given transaction hash.
   *
   * @param {String} txHash - transaction hash with leading "0x"
   * @param {{contracts: Array<Contract>, files: Array<String>, provider: Web3Provider}} options -
   * @return {Debugger} instance
   */

  (0, _createClass3.default)(Debugger, [{
    key: "connect",

    /**
     * Connects to the instantiated Debugger.
     *
     * @return {Session} session instance
     */
    value: function connect() {
      return this._session;
    }

    /**
     * Exported selectors
     *
     * See individual selector docs for full listing
     *
     * @example
     * Debugger.selectors.ast.current.tree
     *
     * @example
     * Debugger.selectors.solidity.current.instruction
     *
     * @example
     * Debugger.selectors.trace.steps
     */

  }], [{
    key: "forTx",
    value: function () {
      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(txHash) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var session;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _truffleExpect2.default.options(options, ["contracts", "provider"]);

                session = new _session2.default(options.contracts, options.files, txHash, options.provider);
                _context.prev = 2;
                _context.next = 5;
                return session.ready();

              case 5:
                _context.next = 10;
                break;

              case 7:
                _context.prev = 7;
                _context.t0 = _context["catch"](2);
                throw _context.t0;

              case 10:
                return _context.abrupt("return", new this(session));

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[2, 7]]);
      }));

      function forTx(_x2) {
        return _ref.apply(this, arguments);
      }

      return forTx;
    }()
  }, {
    key: "selectors",
    get: function get() {
      return (0, _reselectTree.createNestedSelector)({
        ast: _selectors4.default,
        data: _selectors2.default,
        trace: _selectors6.default,
        evm: _selectors8.default,
        solidity: _selectors10.default,
        session: _selectors12.default
      });
    }
  }]);
  return Debugger;
}();

/**
 * @typedef {Object} Contract
 * @property {string} contractName contract name
 * @property {string} source solidity source code
 * @property {string} sourcePath path to source file
 * @property {string} binary 0x-prefixed hex string with create bytecode
 * @property {string} sourceMap solidity source map for create bytecode
 * @property {Object} ast Abstract Syntax Tree from Solidity
 * @property {string} deployedBinary 0x-prefixed compiled binary (on chain)
 * @property {string} deployedSourceMap solidity source map for on-chain bytecode
 */

exports.default = Debugger;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reselectTree = __webpack_require__(12);

var trace = (0, _reselectTree.createSelectorTree)({
  /**
   * trace.index
   *
   * current step index
   */
  index: function index(state) {
    return state.trace.proc.index;
  },

  /**
   * trace.steps
   *
   * all trace steps
   */
  steps: function steps(state) {
    return state.trace.info.steps;
  },

  /**
   * trace.stepsRemaining
   *
   * number of steps remaining in trace
   */
  stepsRemaining: (0, _reselectTree.createLeaf)(["./steps", "./index"], function (steps, index) {
    return steps.length - index;
  }),

  /**
   * trace.step
   *
   * current trace step
   */
  step: (0, _reselectTree.createLeaf)(["./steps", "./index"], function (steps, index) {
    return steps[index];
  }),

  /**
   * trace.next
   *
   * next trace step or {}
   */
  next: (0, _reselectTree.createLeaf)(["./steps", "./index"], function (steps, index) {
    return index < steps.length - 1 ? steps[index + 1] : {};
  })
});

exports.default = trace;

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = require("bignumber.js");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saveSteps = saveSteps;
exports.receiveAddresses = receiveAddresses;
exports.next = next;
exports.tick = tick;
exports.tock = tock;
exports.endTrace = endTrace;
var SAVE_STEPS = exports.SAVE_STEPS = "SAVE_STEPS";
function saveSteps(steps) {
  return {
    type: SAVE_STEPS,
    steps: steps
  };
}

var RECEIVE_ADDRESSES = exports.RECEIVE_ADDRESSES = "RECEIVE_ADDRESSES";
function receiveAddresses(addresses) {
  return {
    type: RECEIVE_ADDRESSES,
    addresses: addresses
  };
}

var NEXT = exports.NEXT = "NEXT";
function next() {
  return { type: NEXT };
}

var TICK = exports.TICK = "TICK";
function tick() {
  return { type: TICK };
}

var TOCK = exports.TOCK = "TOCK";
function tock() {
  return { type: TOCK };
}

var END_OF_TRACE = exports.END_OF_TRACE = "EOT";
function endTrace() {
  return { type: END_OF_TRACE };
}

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(61);


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = __webpack_require__(40);
var getProperties = __webpack_require__(64);
var getEnumerableProperties = __webpack_require__(65);

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 * @namespace Utils
 * @name inspect
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
}

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === 'object') {
    return object instanceof HTMLElement;
  } else {
    return object &&
      typeof object === 'object' &&
      object.nodeType === 1 &&
      typeof object.nodeName === 'string';
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value && typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If this is a DOM element, try to get the outer HTML.
  if (isDOMElement(value)) {
    if ('outerHTML' in value) {
      return value.outerHTML;
      // This value does not have an outerHTML attribute,
      //   it could still be an XML element
    } else {
      // Attempt to serialize it
      try {
        if (document.xmlVersion) {
          var xmlSerializer = new XMLSerializer();
          return xmlSerializer.serializeToString(value);
        } else {
          // Firefox 11- do not support outerHTML
          //   It does, however, support innerHTML
          //   Use the following to render the element
          var ns = "http://www.w3.org/1999/xhtml";
          var container = document.createElementNS(ns, '_');

          container.appendChild(value.cloneNode(false));
          html = container.innerHTML
            .replace('><', '>' + value.innerHTML + '<');
          container.innerHTML = '';
          return html;
        }
      } catch (err) {
        // This could be a non-native DOM implementation,
        //   continue with the normal flow:
        //   printing the element as if it is an object.
      }
    }
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) && (
      (keys.length === 1 && keys[0] === 'stack') ||
      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
     ))) {
    if (typeof value === 'function') {
      var name = getName(value);
      var nameSuffix = name ? ': ' + name : '';
      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (typeof value === 'function') {
    var name = getName(value);
    var nameSuffix = name ? ': ' + name : '';
    base = ' [Function' + nameSuffix + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case 'undefined':
      return ctx.stylize('undefined', 'undefined');

    case 'string':
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');

    case 'number':
      if (value === 0 && (1/value) === -Infinity) {
        return ctx.stylize('-0', 'number');
      }
      return ctx.stylize('' + value, 'number');

    case 'boolean':
      return ctx.stylize('' + value, 'boolean');
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  if (value.__lookupGetter__) {
    if (value.__lookupGetter__(key)) {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
  }
  if (visibleKeys.indexOf(key) < 0) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (typeof name === 'undefined') {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
}

function isRegExp(re) {
  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
}

function isDate(d) {
  return typeof d === 'object' && objectToString(d) === '[object Date]';
}

function isError(e) {
  return typeof e === 'object' && objectToString(e) === '[object Error]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/promise");

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/classCallCheck");

/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/createClass");

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = require("json-pointer");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.start = start;
exports.ready = ready;
exports.error = error;
exports.finish = finish;
exports.recordContracts = recordContracts;
var START = exports.START = "SESSION_START";
function start(txHash, provider) {
  return {
    type: START,
    txHash: txHash, provider: provider
  };
}

var READY = exports.READY = "SESSION_READY";
function ready() {
  return {
    type: READY
  };
}

var ERROR = exports.ERROR = "SESSION_ERROR";
function error(error) {
  return {
    type: ERROR,
    error: error
  };
}

var FINISH = exports.FINISH = "SESSION_FINISH";
function finish() {
  return {
    type: FINISH
  };
}

var RECORD_CONTRACTS = exports.RECORD_CONTRACTS = "RECORD_CONTRACTS";
function recordContracts(contexts, sources) {
  return {
    type: RECORD_CONTRACTS,
    contexts: contexts, sources: sources
  };
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(13);

var _extends3 = _interopRequireDefault(_extends2);

var _defineProperty2 = __webpack_require__(3);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _slicedToArray2 = __webpack_require__(4);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _toConsumableArray2 = __webpack_require__(2);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(12);

var _jsonPointer = __webpack_require__(34);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _selectors = __webpack_require__(21);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(7);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(9);

var _selectors6 = _interopRequireDefault(_selectors5);

var _decode = __webpack_require__(104);

var _decode2 = _interopRequireDefault(_decode);

var _utils = __webpack_require__(15);

var decodeUtils = _interopRequireWildcard(_utils);

var _bignumber = __webpack_require__(27);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger:data:selectors");

function createStateSelectors(_ref) {
  var stack = _ref.stack,
      memory = _ref.memory,
      storage = _ref.storage;

  return {
    /**
     * .stack
     */
    stack: (0, _reselectTree.createLeaf)([stack], function (words) {
      return (words || []).map(function (word) {
        return decodeUtils.toBytes(decodeUtils.toBigNumber(word, decodeUtils.WORD_SIZE));
      });
    }),

    /**
     * .memory
     */
    memory: (0, _reselectTree.createLeaf)([memory], function (words) {
      return new Uint8Array((words.join("").match(/.{1,2}/g) || []).map(function (byte) {
        return parseInt(byte, 16);
      }));
    }),

    /**
     * .storage
     */
    storage: (0, _reselectTree.createLeaf)([storage], function (mapping) {
      return _assign2.default.apply(Object, [{}].concat((0, _toConsumableArray3.default)((0, _entries2.default)(mapping).map(function (_ref2) {
        var _ref3 = (0, _slicedToArray3.default)(_ref2, 2),
            address = _ref3[0],
            word = _ref3[1];

        return (0, _defineProperty3.default)({}, "0x" + address, new Uint8Array((word.match(/.{1,2}/g) || []).map(function (byte) {
          return parseInt(byte, 16);
        })));
      }))));
    })
  };
}

var data = (0, _reselectTree.createSelectorTree)({
  state: function state(_state) {
    return _state.data;
  },

  /**
   * data.views
   */
  views: {
    ast: (0, _reselectTree.createLeaf)([_selectors2.default.current], function (tree) {
      return tree;
    }),

    atLastInstructionForSourceRange: (0, _reselectTree.createLeaf)([_selectors6.default.current.isSourceRangeFinal], function (final) {
      return final;
    }),

    /**
     * data.views.scopes
     */
    scopes: {

      /**
       * data.views.scopes.inlined
       */
      inlined: (0, _reselectTree.createLeaf)(["/info/scopes", _selectors6.default.info.sources], function (scopes, sources) {
        return _assign2.default.apply(Object, [{}].concat((0, _toConsumableArray3.default)((0, _entries2.default)(scopes).map(function (_ref5) {
          var _ref6 = (0, _slicedToArray3.default)(_ref5, 2),
              id = _ref6[0],
              entry = _ref6[1];

          return (0, _defineProperty3.default)({}, id, (0, _extends3.default)({}, entry, {

            definition: _jsonPointer2.default.get(sources[entry.sourceId].ast, entry.pointer)
          }));
        }))));
      })
    },

    /**
     * data.views.decoder
     *
     * selector returns (ast node definition, data reference) => value
     */
    decoder: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "/current/state"], function (scopes, state) {
      return function (definition, ref) {
        return (0, _decode2.default)(definition, ref, state, scopes);
      };
    })
  },

  /**
   * data.info
   */
  info: {

    /**
     * data.info.scopes
     */
    scopes: (0, _reselectTree.createLeaf)(["/state"], function (state) {
      return state.info.scopes.byId;
    })
  },

  /**
   * data.proc
   */
  proc: {

    /**
     * data.proc.assignments
     */
    assignments: (0, _reselectTree.createLeaf)(["/state"], function (state) {
      return state.proc.assignments.byId;
    })
  },

  /**
   * data.current
   */
  current: {
    /**
     *
     * data.current.scope
     */
    scope: {

      /**
       * data.current.scope.id
       */
      id: (0, _reselectTree.createLeaf)([_selectors2.default.current.node], function (node) {
        return node.id;
      })
    },

    /**
     * data.current.state
     */
    state: createStateSelectors(_selectors4.default.current.state),

    /**
     * data.current.identifiers (namespace)
     */
    identifiers: {

      /**
       * data.current.identifiers (selector)
       *
       * returns identifers and corresponding definition node ID
       */
      _: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "/current/scope"], function (scopes, scope) {
        var cur = scope.id;
        var variables = {};

        do {
          variables = _assign2.default.apply(Object, [variables].concat((0, _toConsumableArray3.default)((scopes[cur].variables || []).filter(function (v) {
            return variables[v.name] == undefined;
          }).map(function (v) {
            return (0, _defineProperty3.default)({}, v.name, v.id);
          }))));

          cur = scopes[cur].parentId;
        } while (cur != null);

        return variables;
      }),

      /**
       * data.current.identifiers.definitions
       *
       * current variable definitions
       */
      definitions: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "./_"], function (scopes, identifiers) {
        return _assign2.default.apply(Object, [{}].concat((0, _toConsumableArray3.default)((0, _entries2.default)(identifiers).map(function (_ref9) {
          var _ref10 = (0, _slicedToArray3.default)(_ref9, 2),
              identifier = _ref10[0],
              id = _ref10[1];

          var definition = scopes[id].definition;

          return (0, _defineProperty3.default)({}, identifier, definition);
        }))));
      }),

      /**
       * data.current.identifiers.refs
       *
       * current variables' value refs
       */
      refs: (0, _reselectTree.createLeaf)(["/proc/assignments", "./_"], function (assignments, identifiers) {
        return _assign2.default.apply(Object, [{}].concat((0, _toConsumableArray3.default)((0, _entries2.default)(identifiers).map(function (_ref12) {
          var _ref13 = (0, _slicedToArray3.default)(_ref12, 2),
              identifier = _ref13[0],
              id = _ref13[1];

          var _ref14 = assignments[id] || {},
              ref = _ref14.ref;

          if (!ref) {
            return undefined;
          };

          return (0, _defineProperty3.default)({}, identifier, ref);
        }))));
      }),

      decoded: (0, _reselectTree.createLeaf)(["/views/decoder", "./definitions", "./refs"], function (decode, definitions, refs) {
        return _assign2.default.apply(Object, [{}].concat((0, _toConsumableArray3.default)((0, _entries2.default)(refs).map(function (_ref16) {
          var _ref17 = (0, _slicedToArray3.default)(_ref16, 2),
              identifier = _ref17[0],
              ref = _ref17[1];

          return (0, _defineProperty3.default)({}, identifier, decode(definitions[identifier], ref));
        }))));
      }),

      native: (0, _reselectTree.createLeaf)(['./decoded'], decodeUtils.cleanBigNumbers)
    }
  },

  /**
   * data.next
   */
  next: {

    /**
     * data.next.state
     */
    state: createStateSelectors(_selectors4.default.next.state)
  }
});

exports.default = data;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/set");

/***/ }),
/* 38 */
/***/ (function(module, exports) {

/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || AssertionError;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  } else {
    try {
      throw new Error();
    } catch(e) {
      this.stack = e.stack;
    }
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};


/***/ }),
/* 39 */
/***/ (function(module, exports) {

/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getActual
 */

module.exports = function (obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};


/***/ }),
/* 40 */
/***/ (function(module, exports) {

/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 * @namespace Utils
 * @name getName
 */

module.exports = function (func) {
  if (func.name) return func.name;

  var match = /^\s?function ([^(]*)\(/.exec(func);
  return match && match[1] ? match[1] : "";
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var inspect = __webpack_require__(30);
var config = __webpack_require__(19);

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @namespace Utils
 * @api public
 */

module.exports = function (obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj)
        , kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};


/***/ }),
/* 42 */
/***/ (function(module, exports) {

/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @namespace Utils
 * @name transferFlags
 * @api private
 */

module.exports = function (assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
      object.__flags[flag] = flags[flag];
    }
  }
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Chai - getPathInfo utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var hasProperty = __webpack_require__(44);

/**
 * ### .getPathInfo(path, object)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */

module.exports = function getPathInfo(path, obj) {
  var parsed = parsePath(path),
      last = parsed[parsed.length - 1];

  var info = {
    parent: parsed.length > 1 ? _getPathValue(parsed, obj, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: _getPathValue(parsed, obj)
  };
  info.exists = hasProperty(info.name, info.parent);

  return info;
};


/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath (path) {
  var str = path.replace(/([^\\])\[/g, '$1.[')
    , parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    var re = /^\[(\d+)\]$/
      , mArr = re.exec(value);
    if (mArr) return { i: parseFloat(mArr[1]) };
    else return { p: value.replace(/\\([.\[\]])/g, '$1') };
  });
}


/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @param {Number} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

function _getPathValue (parsed, obj, index) {
  var tmp = obj
    , res;

  index = (index === undefined ? parsed.length : index);

  for (var i = 0, l = index; i < l; i++) {
    var part = parsed[i];
    if (tmp) {
      if ('undefined' !== typeof part.p)
        tmp = tmp[part.p];
      else if ('undefined' !== typeof part.i)
        tmp = tmp[part.i];
      if (i == (l - 1)) res = tmp;
    } else {
      res = undefined;
    }
  }
  return res;
}


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Chai - hasProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var type = __webpack_require__(29);

/**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has
 * named property or numeric array index.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with natives
 * and null/undefined values.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty('str', obj);  // true
 *     hasProperty('constructor', obj);  // true
 *     hasProperty('bar', obj);  // false
 *
 *     hasProperty('length', obj.str); // true
 *     hasProperty(1, obj.str);  // true
 *     hasProperty(5, obj.str);  // false
 *
 *     hasProperty('length', obj.arr);  // true
 *     hasProperty(2, obj.arr);  // true
 *     hasProperty(3, obj.arr);  // false
 *
 * @param {Objuect} object
 * @param {String|Number} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */

var literals = {
    'number': Number
  , 'string': String
};

module.exports = function hasProperty(name, obj) {
  var ot = type(obj);

  // Bad Object, obviously no props at all
  if(ot === 'null' || ot === 'undefined')
    return false;

  // The `in` operator does not work with certain literals
  // box these before the check
  if(literals[ot] && typeof obj !== 'object')
    obj = new literals[ot](obj);

  return name in obj;
};


/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = require("truffle-expect");

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/typeof");

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _toConsumableArray2 = __webpack_require__(2);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _slicedToArray2 = __webpack_require__(4);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

exports.getRange = getRange;
exports.rangeNodes = rangeNodes;
exports.findRange = findRange;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _nodeIntervalTree = __webpack_require__(96);

var _nodeIntervalTree2 = _interopRequireDefault(_nodeIntervalTree);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger:ast:map");

/**
 * @private
 */
function getRange(node) {
  // src: "<start>:<length>:<_>"
  // returns [start, end]
  var _node$src$split$slice = node.src.split(":").slice(0, 2).map(function (i) {
    return parseInt(i);
  }),
      _node$src$split$slice2 = (0, _slicedToArray3.default)(_node$src$split$slice, 2),
      start = _node$src$split$slice2[0],
      length = _node$src$split$slice2[1];

  return [start, start + length];
}

/**
 * @private
 */
function rangeNodes(node) {
  var pointer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

  if (node instanceof Array) {
    var _ref;

    return (_ref = []).concat.apply(_ref, (0, _toConsumableArray3.default)(node.map(function (sub, i) {
      return rangeNodes(sub, pointer + "/" + i);
    })));
  } else if (node instanceof Object) {
    var results = [];

    if (node.src) {
      results.push({ pointer: pointer, range: getRange(node) });
    }

    return results.concat.apply(results, (0, _toConsumableArray3.default)((0, _keys2.default)(node).map(function (key) {
      return rangeNodes(node[key], pointer + "/" + key);
    })));
  } else {
    return [];
  }
}

/**
 * @private
 */
function findRange(node, sourceStart, sourceLength) {
  var ranges = rangeNodes(node);
  var tree = new _nodeIntervalTree2.default();

  ranges.forEach(function (_ref2) {
    var range = _ref2.range,
        pointer = _ref2.pointer;

    var _range = (0, _slicedToArray3.default)(range, 2),
        start = _range[0],
        end = _range[1];

    tree.insert(start, end, { range: range, pointer: pointer });
  });

  var sourceEnd = sourceStart + sourceLength;

  var overlapping = tree.search(sourceStart, sourceEnd);

  // find nodes that fully contain requested range,
  // return longest pointer
  return overlapping.filter(function (_ref3) {
    var range = _ref3.range;
    return sourceStart >= range[0] && sourceEnd <= range[1];
  }).map(function (_ref4) {
    var pointer = _ref4.pointer;
    return pointer;
  }).reduce(function (a, b) {
    return a.length > b.length ? a : b;
  }, "");
}

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.beginStep = beginStep;
exports.advance = advance;
exports.stepNext = stepNext;
exports.stepOver = stepOver;
exports.stepInto = stepInto;
exports.stepOut = stepOut;
exports.interrupt = interrupt;
exports.continueUntil = continueUntil;
var BEGIN_STEP = exports.BEGIN_STEP = "BEGIN_STEP";
function beginStep(type) {
  return {
    type: BEGIN_STEP,
    stepType: type
  };
}

var ADVANCE = exports.ADVANCE = "ADVANCE";
function advance() {
  return { type: ADVANCE };
}

var STEP_NEXT = exports.STEP_NEXT = "STEP_NEXT";
function stepNext() {
  return { type: STEP_NEXT };
}

var STEP_OVER = exports.STEP_OVER = "STEP_OVER";
function stepOver() {
  return { type: STEP_OVER };
}

var STEP_INTO = exports.STEP_INTO = "STEP_INTO";
function stepInto() {
  return { type: STEP_INTO };
}

var STEP_OUT = exports.STEP_OUT = "STEP_OUT";
function stepOut() {
  return { type: STEP_OUT };
}

var INTERRUPT = exports.INTERRUPT = "INTERRUPT";
function interrupt() {
  return { type: INTERRUPT };
}

var CONTINUE_UNTIL = exports.CONTINUE_UNTIL = "CONTINUE_UNTIL";
function continueUntil() {
  for (var _len = arguments.length, breakpoints = Array(_len), _key = 0; _key < _len; _key++) {
    breakpoints[_key] = arguments[_key];
  }

  return {
    type: CONTINUE_UNTIL,
    breakpoints: breakpoints
  };
}

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __webpack_require__(4);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _toConsumableArray2 = __webpack_require__(2);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _defineProperty2 = __webpack_require__(3);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

exports.scope = scope;
exports.declare = declare;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(14);

var _jsonPointer = __webpack_require__(34);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _helpers = __webpack_require__(6);

var _actions = __webpack_require__(28);

var _actions2 = __webpack_require__(50);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(36);

var _selectors2 = _interopRequireDefault(_selectors);

var _utils = __webpack_require__(15);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _marked = /*#__PURE__*/_regenerator2.default.mark(scope),
    _marked2 = /*#__PURE__*/_regenerator2.default.mark(declare),
    _marked3 = /*#__PURE__*/_regenerator2.default.mark(tickSaga),
    _marked4 = /*#__PURE__*/_regenerator2.default.mark(saga);

var debug = (0, _debug2.default)("debugger:data:sagas");

function scope(nodeId, pointer, parentId, sourceId) {
  return _regenerator2.default.wrap(function scope$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return (0, _effects.put)(actions.scope(nodeId, pointer, parentId, sourceId));

        case 2:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

function declare(node) {
  return _regenerator2.default.wrap(function declare$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return (0, _effects.put)(actions.declare(node));

        case 2:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, this);
}

function tickSaga() {
  var _ref, tree, treeId, node, pointer, scopes, definitions, stack, top, parameters, returnParameters, assignments, storageVars, _storageVars, slot, index, allocation;

  return _regenerator2.default.wrap(function tickSaga$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return (0, _effects.select)(_selectors2.default.views.ast);

        case 2:
          _ref = _context3.sent;
          tree = _ref.tree;
          treeId = _ref.id;
          node = _ref.node;
          pointer = _ref.pointer;
          _context3.next = 9;
          return (0, _effects.select)(_selectors2.default.info.scopes);

        case 9:
          scopes = _context3.sent;
          _context3.next = 12;
          return (0, _effects.select)(_selectors2.default.views.scopes.inlined);

        case 12:
          definitions = _context3.sent;
          _context3.next = 15;
          return (0, _effects.select)(_selectors2.default.next.state.stack);

        case 15:
          stack = _context3.sent;

          if (stack) {
            _context3.next = 18;
            break;
          }

          return _context3.abrupt("return");

        case 18:
          top = stack.length - 1;

          if (node) {
            _context3.next = 21;
            break;
          }

          return _context3.abrupt("return");

        case 21:
          _context3.t0 = node.nodeType;
          _context3.next = _context3.t0 === "FunctionDefinition" ? 24 : _context3.t0 === "ContractDefinition" ? 34 : _context3.t0 === "VariableDeclaration" ? 44 : 46;
          break;

        case 24:
          _context3.next = 26;
          return (0, _effects.select)(_selectors2.default.views.atLastInstructionForSourceRange);

        case 26:
          if (_context3.sent) {
            _context3.next = 28;
            break;
          }

          return _context3.abrupt("break", 47);

        case 28:

          parameters = node.parameters.parameters.map(function (p, i) {
            return pointer + "/parameters/parameters/" + i;
          });

          returnParameters = node.returnParameters.parameters.map(function (p, i) {
            return pointer + "/returnParameters/parameters/" + i;
          });

          assignments = returnParameters.concat(parameters).reverse().map(function (pointer) {
            return _jsonPointer2.default.get(tree, pointer).id;
          }).map(function (id, i) {
            return (0, _defineProperty3.default)({}, id, { "stack": top - i });
          }).reduce(function (acc, assignment) {
            return (0, _assign2.default)(acc, assignment);
          }, {});

          _context3.next = 33;
          return (0, _effects.put)(actions.assign(treeId, assignments));

        case 33:
          return _context3.abrupt("break", 47);

        case 34:
          _storageVars = scopes[node.id].variables || [];
          slot = 0;
          index = _utils.WORD_SIZE - 1; // cause lower-order

          debug("storage vars %o", _storageVars);

          allocation = utils.allocateDeclarations(_storageVars, definitions);

          assignments = _assign2.default.apply(Object, [{}].concat((0, _toConsumableArray3.default)((0, _entries2.default)(allocation.children).map(function (_ref3) {
            var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),
                id = _ref4[0],
                storage = _ref4[1];

            return (0, _defineProperty3.default)({}, id, { storage: storage });
          }))));
          debug("assignments %O", assignments);

          _context3.next = 43;
          return (0, _effects.put)(actions.assign(treeId, assignments));

        case 43:
          return _context3.abrupt("break", 47);

        case 44:
          _context3.next = 46;
          return (0, _effects.put)(actions.assign(treeId, (0, _defineProperty3.default)({}, _jsonPointer2.default.get(tree, pointer).id, { "stack": top })));

        case 46:
          return _context3.abrupt("break", 47);

        case 47:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3, this);
}

function saga() {
  return _regenerator2.default.wrap(function saga$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return (0, _effects.takeEvery)(_actions.TICK, /*#__PURE__*/_regenerator2.default.mark(function _callee() {
            return _regenerator2.default.wrap(function _callee$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.prev = 0;
                    return _context4.delegateYield(tickSaga(), "t0", 2);

                  case 2:
                    _context4.next = 7;
                    break;

                  case 4:
                    _context4.prev = 4;
                    _context4.t1 = _context4["catch"](0);

                    debug(_context4.t1);

                  case 7:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee, this, [[0, 4]]);
          }));

        case 2:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked4, this);
}

exports.default = (0, _helpers.prefixName)("data", saga);

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scope = scope;
exports.declare = declare;
exports.assign = assign;
var SCOPE = exports.SCOPE = "SCOPE";
function scope(id, pointer, parentId, sourceId) {
  return {
    type: SCOPE,
    id: id, pointer: pointer, parentId: parentId, sourceId: sourceId
  };
}

var DECLARE = exports.DECLARE = "DECLARE_VARIABLE";
function declare(node) {
  return {
    type: DECLARE,
    node: node
  };
}

var ASSIGN = exports.ASSIGN = "ASSIGN";
function assign(context, assignments) {
  return {
    type: ASSIGN,
    context: context, assignments: assignments
  };
}

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _set = __webpack_require__(37);

var _set2 = _interopRequireDefault(_set);

var _toConsumableArray2 = __webpack_require__(2);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

exports.advance = advance;
exports.wait = wait;
exports.processTrace = processTrace;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(14);

var _helpers = __webpack_require__(6);

var _actions = __webpack_require__(28);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(26);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _marked = /*#__PURE__*/_regenerator2.default.mark(waitForTrace),
    _marked2 = /*#__PURE__*/_regenerator2.default.mark(advance),
    _marked3 = /*#__PURE__*/_regenerator2.default.mark(next),
    _marked4 = /*#__PURE__*/_regenerator2.default.mark(wait),
    _marked5 = /*#__PURE__*/_regenerator2.default.mark(processTrace),
    _marked6 = /*#__PURE__*/_regenerator2.default.mark(saga);

var debug = (0, _debug2.default)("debugger:trace:sagas");

function waitForTrace() {
  var _ref, steps, addresses;

  return _regenerator2.default.wrap(function waitForTrace$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return (0, _effects.take)(actions.SAVE_STEPS);

        case 2:
          _ref = _context.sent;
          steps = _ref.steps;
          addresses = [].concat((0, _toConsumableArray3.default)(new _set2.default(steps.filter(function (_ref2) {
            var op = _ref2.op;
            return op == "CALL" || op == "DELEGATECALL";
          }).map(function (_ref3) {
            var stack = _ref3.stack;
            return "0x" + stack[stack.length - 2].substring(24);
          }))));
          _context.next = 7;
          return (0, _effects.put)(actions.receiveAddresses(addresses));

        case 7:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

function advance() {
  return _regenerator2.default.wrap(function advance$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return (0, _effects.put)(actions.next());

        case 2:
          _context2.next = 4;
          return (0, _effects.take)(actions.TOCK);

        case 4:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, this);
}

function next() {
  var remaining, steps;
  return _regenerator2.default.wrap(function next$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return (0, _effects.select)(_selectors2.default.stepsRemaining);

        case 2:
          remaining = _context3.sent;

          debug("remaining: %o", remaining);
          _context3.next = 6;
          return (0, _effects.select)(_selectors2.default.steps);

        case 6:
          steps = _context3.sent;

          debug("total steps: %o", steps.length);

          if (!(remaining > 0)) {
            _context3.next = 14;
            break;
          }

          debug("putting TICK");
          // updates state for current step
          _context3.next = 12;
          return (0, _effects.put)(actions.tick());

        case 12:
          debug("put TICK");

          remaining--; // local update, just for convenience

        case 14:
          if (!remaining) {
            _context3.next = 21;
            break;
          }

          debug("putting TOCK");
          // updates step to next step in trace
          _context3.next = 18;
          return (0, _effects.put)(actions.tock());

        case 18:
          debug("put TOCK");

          _context3.next = 23;
          break;

        case 21:
          _context3.next = 23;
          return (0, _effects.put)(actions.endTrace());

        case 23:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3, this);
}

function wait() {
  return _regenerator2.default.wrap(function wait$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return (0, _effects.take)(actions.END_OF_TRACE);

        case 2:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, this);
}

function processTrace(trace) {
  var _ref4, addresses;

  return _regenerator2.default.wrap(function processTrace$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return (0, _effects.put)(actions.saveSteps(trace));

        case 2:
          _context5.next = 4;
          return (0, _effects.take)(actions.RECEIVE_ADDRESSES);

        case 4:
          _ref4 = _context5.sent;
          addresses = _ref4.addresses;

          debug("received addresses");

          return _context5.abrupt("return", addresses);

        case 8:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5, this);
}

function saga() {
  return _regenerator2.default.wrap(function saga$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          return _context6.delegateYield(waitForTrace(), "t0", 1);

        case 1:
          _context6.next = 3;
          return (0, _effects.takeEvery)(actions.NEXT, next);

        case 3:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6, this);
}

exports.default = (0, _helpers.prefixName)("trace", saga);

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.addSourceMap = addSourceMap;
exports.jump = jump;
var ADD_SOURCE = exports.ADD_SOURCE = "SOLIDITY_ADD_SOURCE";
function addSource(source, sourcePath, ast) {
  return {
    type: ADD_SOURCE,
    source: source, sourcePath: sourcePath, ast: ast
  };
}

var ADD_SOURCEMAP = exports.ADD_SOURCEMAP = "SOLIDITY_ADD_SOURCEMAP";
function addSourceMap(binary, sourceMap) {
  return {
    type: ADD_SOURCEMAP,
    binary: binary, sourceMap: sourceMap
  };
}

var JUMP = exports.JUMP = "JUMP";
function jump(jumpDirection) {
  return {
    type: JUMP,
    jumpDirection: jumpDirection
  };
}

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.addInstance = addInstance;
exports.call = call;
exports.create = create;
exports.returnCall = returnCall;
var ADD_CONTEXT = exports.ADD_CONTEXT = "EVM_ADD_CONTEXT";
function addContext(contractName, binary) {
  return {
    type: ADD_CONTEXT,
    contractName: contractName, binary: binary
  };
}

var ADD_INSTANCE = exports.ADD_INSTANCE = "EVM_ADD_INSTANCE";
function addInstance(address, context, binary) {
  return {
    type: ADD_INSTANCE,
    address: address, context: context, binary: binary
  };
}

var CALL = exports.CALL = "CALL";
function call(address) {
  return {
    type: CALL,
    address: address
  };
}

var CREATE = exports.CREATE = "CREATE";
function create(binary) {
  return {
    type: CREATE,
    binary: binary
  };
}

var RETURN = exports.RETURN = "RETURN";
function returnCall() {
  return {
    type: RETURN
  };
}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(3);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _slicedToArray2 = __webpack_require__(4);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _toConsumableArray2 = __webpack_require__(2);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(12);

var _selectors = __webpack_require__(7);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(9);

var _selectors4 = _interopRequireDefault(_selectors3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger:session:selectors");

var session = (0, _reselectTree.createSelectorTree)({
  /**
   * session.info
   */
  info: {

    /**
     * session.info.affectedInstances
     */
    affectedInstances: (0, _reselectTree.createLeaf)([_selectors2.default.info.instances, _selectors2.default.info.contexts, _selectors4.default.info.sources, _selectors4.default.info.sourceMaps], function (instances, contexts, sources, sourceMaps) {
      return _assign2.default.apply(Object, [{}].concat((0, _toConsumableArray3.default)((0, _entries2.default)(instances).map(function (_ref) {
        var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
            address = _ref2[0],
            context = _ref2[1].context;

        var _contexts$context = contexts[context],
            contractName = _contexts$context.contractName,
            binary = _contexts$context.binary;
        var sourceMap = sourceMaps[context].sourceMap;

        var _ref3 = sourceMap ?
        // look for source ID between second and third colons (HACK)
        sources[sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]] : {},
            source = _ref3.source;

        return (0, _defineProperty3.default)({}, address, {
          contractName: contractName, source: source, binary: binary
        });
      }))));
    })
  }
});

exports.default = session;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(3);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _asyncToGenerator2 = __webpack_require__(10);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getIterator2 = __webpack_require__(17);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var prepareDebugger = function () {
  var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(testName, sources) {
    var provider, web3, _ref3, abstractions, contracts, files, instance, receipt, txHash, bugger, session, breakpoint;

    return _regenerator2.default.wrap(function _callee$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            provider = _ganacheCli2.default.provider({ seed: "debugger", gasLimit: 7000000 });
            web3 = new _web2.default(provider);
            _context2.next = 4;
            return (0, _helpers.prepareContracts)(provider, sources);

          case 4:
            _ref3 = _context2.sent;
            abstractions = _ref3.abstractions;
            contracts = _ref3.artifacts;
            files = _ref3.files;
            _context2.next = 10;
            return abstractions[contractName(testName)].deployed();

          case 10:
            instance = _context2.sent;
            _context2.next = 13;
            return instance.run();

          case 13:
            receipt = _context2.sent;
            txHash = receipt.tx;
            _context2.next = 17;
            return _debugger2.default.forTx(txHash, { provider: provider, files: files, contracts: contracts });

          case 17:
            bugger = _context2.sent;
            session = bugger.connect();
            breakpoint = {
              address: instance.address,
              line: lastStatementLine(sources[fileName(testName)])
            };


            session.continueUntil(breakpoint);

            return _context2.abrupt("return", session);

          case 22:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee, this);
  }));

  return function prepareDebugger(_x, _x2) {
    return _ref2.apply(this, arguments);
  };
}();

var getDecode = function () {
  var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(session) {
    var definitions, refs, decode;
    return _regenerator2.default.wrap(function _callee2$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            definitions = session.view(_selectors2.default.current.identifiers.definitions);
            refs = session.view(_selectors2.default.current.identifiers.refs);
            decode = session.view(_selectors2.default.views.decoder);
            return _context3.abrupt("return", function (name) {
              return (0, _utils.cleanBigNumbers)(decode(definitions[name], refs[name]));
            });

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee2, this);
  }));

  return function getDecode(_x3) {
    return _ref4.apply(this, arguments);
  };
}();

exports.generateUints = generateUints;
exports.describeDecoding = describeDecoding;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _ganacheCli = __webpack_require__(23);

var _ganacheCli2 = _interopRequireDefault(_ganacheCli);

var _web = __webpack_require__(11);

var _web2 = _interopRequireDefault(_web);

var _chai = __webpack_require__(18);

var _helpers = __webpack_require__(20);

var _debugger = __webpack_require__(25);

var _debugger2 = _interopRequireDefault(_debugger);

var _utils = __webpack_require__(15);

var _selectors = __webpack_require__(36);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _marked = /*#__PURE__*/_regenerator2.default.mark(generateUints);

var debug = (0, _debug2.default)("test:data:decode");

function generateUints() {
  var x;
  return _regenerator2.default.wrap(function generateUints$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          x = 0;

        case 1:
          if (false) {
            _context.next = 7;
            break;
          }

          _context.next = 4;
          return x;

        case 4:
          x++;
          _context.next = 1;
          break;

        case 7:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

function contractName(testName) {
  return testName.replace(/ /g, "");
}

function fileName(testName) {
  return contractName(testName) + ".sol";
}

function generateTests(fixtures) {
  var _this = this;

  var _loop = function _loop(_ref) {
    var name = _ref.name,
        expected = _ref.value;

    it("correctly decodes " + name, function () {
      _chai.assert.deepEqual(_this.decode(name), expected);
    });
  };

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(fixtures), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ref = _step.value;

      _loop(_ref);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function lastStatementLine(source) {
  var lines = source.split("\n");
  for (var i = lines.length - 1; i >= 0; i--) {
    var line = lines[i];
    if (line.indexOf(";") != -1) {
      return i;
    }
  }
}

function describeDecoding(testName, fixtures, selector, generateSource) {
  var sources = (0, _defineProperty3.default)({}, fileName(testName), generateSource(contractName(testName)));

  describe(testName, function () {
    var _this2 = this;

    this.timeout(30000);

    before("runs and observes debugger", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
      var session;
      return _regenerator2.default.wrap(function _callee3$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return prepareDebugger(testName, sources);

            case 2:
              session = _context4.sent;
              _context4.next = 5;
              return getDecode(session);

            case 5:
              _this2.decode = _context4.sent;


              if (selector) {
                debug("selector %O", session.view(selector));
              }

            case 7:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee3, _this2);
    })));

    generateTests.bind(this)(fixtures);
  });
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

// runtime helper
function inManifest(id) { return global.__webpackManifest__.indexOf(id) >= 0;}
function run(id) { __webpack_require__(id);}

// modules to execute goes here
var ids = [
/*require.resolve*/(57),/*require.resolve*/(121),/*require.resolve*/(122),/*require.resolve*/(55),/*require.resolve*/(124),/*require.resolve*/(125),/*require.resolve*/(20),/*require.resolve*/(126)
];

ids.filter(inManifest).forEach(run)

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray2 = __webpack_require__(4);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(10);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _chai = __webpack_require__(18);

var _ganacheCli = __webpack_require__(23);

var _ganacheCli2 = _interopRequireDefault(_ganacheCli);

var _web = __webpack_require__(11);

var _web2 = _interopRequireDefault(_web);

var _helpers = __webpack_require__(20);

var _debugger = __webpack_require__(25);

var _debugger2 = _interopRequireDefault(_debugger);

var _selectors = __webpack_require__(21);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(9);

var _selectors4 = _interopRequireDefault(_selectors3);

var _map = __webpack_require__(47);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)("test:ast");

var __VARIABLES = "\npragma solidity ^0.4.18;\n\ncontract Variables {\n  event Result(uint256 result);\n\n  uint256 qux;\n  string quux;\n\n  function stack(uint256 foo) public returns (uint256) {\n    uint256 bar = foo + 1;\n    uint256 baz = innerStack(bar);\n\n    baz += 4;\n\n    qux = baz;\n\n    Result(baz);\n\n    return baz;\n  }\n\n  function innerStack(uint256 baz) public returns (uint256) {\n    uint256 bar = baz + 2;\n    return bar;\n  }\n}\n";

var sources = {
  "Variables.sol": __VARIABLES
};

describe("AST", function () {
  var provider;
  var web3;

  var abstractions;
  var artifacts;
  var files;

  before("Create Provider", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            provider = _ganacheCli2.default.provider({ seed: "debugger", gasLimit: 7000000 });
            web3 = new _web2.default(provider);

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  })));

  before("Prepare contracts and artifacts", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
    var prepared;
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            this.timeout(30000);

            _context2.next = 3;
            return (0, _helpers.prepareContracts)(provider, sources);

          case 3:
            prepared = _context2.sent;

            abstractions = prepared.abstractions;
            artifacts = prepared.artifacts;
            files = prepared.files;

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  })));

  describe("Node pointer", function () {
    it("traverses", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
      var instance, receipt, txHash, bugger, session, _session$view, start, length, end, node, _getRange, _getRange2, nodeStart, nodeLength, nodeEnd, pointer;

      return _regenerator2.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              this.timeout(0);
              _context3.next = 3;
              return abstractions.Variables.deployed();

            case 3:
              instance = _context3.sent;
              _context3.next = 6;
              return instance.stack(4);

            case 6:
              receipt = _context3.sent;
              txHash = receipt.tx;
              _context3.next = 10;
              return _debugger2.default.forTx(txHash, {
                provider: provider,
                files: files,
                contracts: artifacts
              });

            case 10:
              bugger = _context3.sent;
              session = bugger.connect();

              debug("ast: %O", session.view(_selectors2.default.current.tree));

              do {
                _session$view = session.view(_selectors4.default.current.sourceRange), start = _session$view.start, length = _session$view.length;
                end = start + length;
                node = session.view(_selectors2.default.current.node);
                _getRange = (0, _map.getRange)(node), _getRange2 = (0, _slicedToArray3.default)(_getRange, 2), nodeStart = _getRange2[0], nodeLength = _getRange2[1];
                nodeEnd = nodeStart + nodeLength;
                pointer = session.view(_selectors2.default.current.pointer);


                _chai.assert.isAtMost(nodeStart, start, "Node " + pointer + " at should not begin after instruction source range");
                _chai.assert.isAtLeast(nodeEnd, end, "Node " + pointer + " should not end after source");

                session.stepNext();
              } while (!session.finished);

            case 14:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    })));
  });
});

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var used = []
  , exports = module.exports = {};

/*!
 * Chai version
 */

exports.version = '3.5.0';

/*!
 * Assertion Error
 */

exports.AssertionError = __webpack_require__(38);

/*!
 * Utils for plugins (not exported)
 */

var util = __webpack_require__(59);

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(this, util);
    used.push(fn);
  }

  return this;
};

/*!
 * Utility Functions
 */

exports.util = util;

/*!
 * Configuration
 */

var config = __webpack_require__(19);
exports.config = config;

/*!
 * Primary `Assertion` prototype
 */

var assertion = __webpack_require__(78);
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = __webpack_require__(79);
exports.use(core);

/*!
 * Expect interface
 */

var expect = __webpack_require__(80);
exports.use(expect);

/*!
 * Should interface
 */

var should = __webpack_require__(81);
exports.use(should);

/*!
 * Assert interface
 */

var assert = __webpack_require__(82);
exports.use(assert);


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Main exports
 */

var exports = module.exports = {};

/*!
 * test utility
 */

exports.test = __webpack_require__(60);

/*!
 * type utility
 */

exports.type = __webpack_require__(29);

/*!
 * expectTypes utility
 */
exports.expectTypes = __webpack_require__(62);

/*!
 * message utility
 */

exports.getMessage = __webpack_require__(63);

/*!
 * actual utility
 */

exports.getActual = __webpack_require__(39);

/*!
 * Inspect util
 */

exports.inspect = __webpack_require__(30);

/*!
 * Object Display util
 */

exports.objDisplay = __webpack_require__(41);

/*!
 * Flag utility
 */

exports.flag = __webpack_require__(16);

/*!
 * Flag transferring utility
 */

exports.transferFlags = __webpack_require__(42);

/*!
 * Deep equal utility
 */

exports.eql = __webpack_require__(66);

/*!
 * Deep path value
 */

exports.getPathValue = __webpack_require__(71);

/*!
 * Deep path info
 */

exports.getPathInfo = __webpack_require__(43);

/*!
 * Check if a property exists
 */

exports.hasProperty = __webpack_require__(44);

/*!
 * Function name
 */

exports.getName = __webpack_require__(40);

/*!
 * add Property
 */

exports.addProperty = __webpack_require__(72);

/*!
 * add Method
 */

exports.addMethod = __webpack_require__(73);

/*!
 * overwrite Property
 */

exports.overwriteProperty = __webpack_require__(74);

/*!
 * overwrite Method
 */

exports.overwriteMethod = __webpack_require__(75);

/*!
 * Add a chainable method
 */

exports.addChainableMethod = __webpack_require__(76);

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = __webpack_require__(77);


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = __webpack_require__(16);

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name test
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , expr = args[0];
  return negate ? !expr : expr;
};


/***/ }),
/* 61 */
/***/ (function(module, exports) {

/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */
var objectTypeRegexp = /^\[object (.*)\]$/;

function getType(obj) {
  var type = Object.prototype.toString.call(obj).match(objectTypeRegexp)[1].toLowerCase();
  // Let "new String('')" return 'object'
  if (typeof Promise === 'function' && obj instanceof Promise) return 'promise';
  // PhantomJS has type "DOMWindow" for null
  if (obj === null) return 'null';
  // PhantomJS has type "DOMWindow" for undefined
  if (obj === undefined) return 'undefined';
  return type;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library() {
  if (!(this instanceof Library)) return new Library();
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function(type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function(obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### expectTypes(obj, types)
 *
 * Ensures that the object being tested against is of a valid type.
 *
 *     utils.expectTypes(this, ['array', 'object', 'string']);
 *
 * @param {Mixed} obj constructed Assertion
 * @param {Array} type A list of allowed types for this assertion
 * @namespace Utils
 * @name expectTypes
 * @api public
 */

var AssertionError = __webpack_require__(38);
var flag = __webpack_require__(16);
var type = __webpack_require__(29);

module.exports = function (obj, types) {
  var obj = flag(obj, 'object');
  types = types.map(function (t) { return t.toLowerCase(); });
  types.sort();

  // Transforms ['lorem', 'ipsum'] into 'a lirum, or an ipsum'
  var str = types.map(function (t, index) {
    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';
    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';
    return or + art + ' ' + t;
  }).join(', ');

  if (!types.some(function (expected) { return type(obj) === expected; })) {
    throw new AssertionError(
      'object tested must be ' + str + ', but ' + type(obj) + ' given'
    );
  }
};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = __webpack_require__(16)
  , getActual = __webpack_require__(39)
  , inspect = __webpack_require__(30)
  , objDisplay = __webpack_require__(41);

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getMessage
 * @api public
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , val = flag(obj, 'object')
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, 'message');

  if(typeof msg === "function") msg = msg();
  msg = msg || '';
  msg = msg
    .replace(/#\{this\}/g, function () { return objDisplay(val); })
    .replace(/#\{act\}/g, function () { return objDisplay(actual); })
    .replace(/#\{exp\}/g, function () { return objDisplay(expected); });

  return flagMsg ? flagMsg + ': ' + msg : msg;
};


/***/ }),
/* 64 */
/***/ (function(module, exports) {

/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(object);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(object);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};


/***/ }),
/* 65 */
/***/ (function(module, exports) {

/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getEnumerableProperties
 * @api public
 */

module.exports = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(67);


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var type = __webpack_require__(68);

/*!
 * Buffer.isBuffer browser shim
 */

var Buffer;
try { Buffer = __webpack_require__(70).Buffer; }
catch(ex) {
  Buffer = {};
  Buffer.isBuffer = function() { return false; }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

function deepEqual(a, b, m) {
  if (sameValue(a, b)) {
    return true;
  } else if ('date' === type(a)) {
    return dateEqual(a, b);
  } else if ('regexp' === type(a)) {
    return regexpEqual(a, b);
  } else if (Buffer.isBuffer(a)) {
    return bufferEqual(a, b);
  } else if ('arguments' === type(a)) {
    return argumentsEqual(a, b, m);
  } else if (!typeEqual(a, b)) {
    return false;
  } else if (('object' !== type(a) && 'object' !== type(b))
  && ('array' !== type(a) && 'array' !== type(b))) {
    return sameValue(a, b);
  } else {
    return objectEqual(a, b, m);
  }
}

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

function sameValue(a, b) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  return a !== a && b !== b;
}

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function typeEqual(a, b) {
  return type(a) === type(b);
}

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

function dateEqual(a, b) {
  if ('date' !== type(b)) return false;
  return sameValue(a.getTime(), b.getTime());
}

/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

function regexpEqual(a, b) {
  if ('regexp' !== type(b)) return false;
  return sameValue(a.toString(), b.toString());
}

/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

function argumentsEqual(a, b, m) {
  if ('arguments' !== type(b)) return false;
  a = [].slice.call(a);
  b = [].slice.call(b);
  return deepEqual(a, b, m);
}

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

function enumerable(a) {
  var res = [];
  for (var key in a) res.push(key);
  return res;
}

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

function iterableEqual(a, b) {
  if (a.length !==  b.length) return false;

  var i = 0;
  var match = true;

  for (; i < a.length; i++) {
    if (a[i] !== b[i]) {
      match = false;
      break;
    }
  }

  return match;
}

/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function bufferEqual(a, b) {
  if (!Buffer.isBuffer(b)) return false;
  return iterableEqual(a, b);
}

/*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

function isValue(a) {
  return a !== null && a !== undefined;
}

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function objectEqual(a, b, m) {
  if (!isValue(a) || !isValue(b)) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  var i;
  if (m) {
    for (i = 0; i < m.length; i++) {
      if ((m[i][0] === a && m[i][1] === b)
      ||  (m[i][0] === b && m[i][1] === a)) {
        return true;
      }
    }
  } else {
    m = [];
  }

  try {
    var ka = enumerable(a);
    var kb = enumerable(b);
  } catch (ex) {
    return false;
  }

  ka.sort();
  kb.sort();

  if (!iterableEqual(ka, kb)) {
    return false;
  }

  m.push([ a, b ]);

  var key;
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], m)) {
      return false;
    }
  }

  return true;
}


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(69);


/***/ }),
/* 69 */
/***/ (function(module, exports) {

/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Array]': 'array'
  , '[object RegExp]': 'regexp'
  , '[object Function]': 'function'
  , '[object Arguments]': 'arguments'
  , '[object Date]': 'date'
};

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

function getType (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library () {
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function (type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function (obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};


/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

var getPathInfo = __webpack_require__(43);

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */
module.exports = function(path, obj) {
  var info = getPathInfo(path, obj);
  return info.value;
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = __webpack_require__(19);
var flag = __webpack_require__(16);

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @namespace Utils
 * @name addProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  Object.defineProperty(ctx, name,
    { get: function addProperty() {
        var old_ssfi = flag(this, 'ssfi');
        if (old_ssfi && config.includeStack === false)
          flag(this, 'ssfi', addProperty);

        var result = getter.call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = __webpack_require__(19);

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @namespace Utils
 * @name addMethod
 * @api public
 */
var flag = __webpack_require__(16);

module.exports = function (ctx, name, method) {
  ctx[name] = function () {
    var old_ssfi = flag(this, 'ssfi');
    if (old_ssfi && config.includeStack === false)
      flag(this, 'ssfi', ctx[name]);
    var result = method.apply(this, arguments);
    return result === undefined ? this : result;
  };
};


/***/ }),
/* 74 */
/***/ (function(module, exports) {

/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @namespace Utils
 * @name overwriteProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get && 'function' === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter(_super).call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};


/***/ }),
/* 75 */
/***/ (function(module, exports) {

/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @namespace Utils
 * @name overwriteMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  var _method = ctx[name]
    , _super = function () { return this; };

  if (_method && 'function' === typeof _method)
    _super = _method;

  ctx[name] = function () {
    var result = method(_super).apply(this, arguments);
    return result === undefined ? this : result;
  }
};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var transferFlags = __webpack_require__(42);
var flag = __webpack_require__(16);
var config = __webpack_require__(19);

/*!
 * Module variables
 */

// Check whether `__proto__` is supported
var hasProtoSupport = '__proto__' in Object;

// Without `__proto__` support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
var excludeNames = /^(?:length|name|arguments|caller)$/;

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @namespace Utils
 * @name addChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function () {
        chainableBehavior.chainingBehavior.call(this);

        var assert = function assert() {
          var old_ssfi = flag(this, 'ssfi');
          if (old_ssfi && config.includeStack === false)
            flag(this, 'ssfi', assert);
          var result = chainableBehavior.method.apply(this, arguments);
          return result === undefined ? this : result;
        };

        // Use `__proto__` if available
        if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = assert.__proto__ = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (!excludeNames.test(asserterName)) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(this, assert);
        return assert;
      }
    , configurable: true
  });
};


/***/ }),
/* 77 */
/***/ (function(module, exports) {

/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @namespace Utils
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function () {
    var result = chainingBehavior(_chainingBehavior).call(this);
    return result === undefined ? this : result;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function () {
    var result = method(_method).apply(this, arguments);
    return result === undefined ? this : result;
  };
};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = __webpack_require__(19);

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

  function Assertion (obj, msg, stack) {
    flag(this, 'ssfi', stack || arguments.callee);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function() {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function(value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, 'showDiff', {
    get: function() {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function(value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (true !== showDiff) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      var msg = util.getMessage(this, arguments)
        , actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, '_obj',
    { get: function () {
        return flag(this, 'object');
      }
    , set: function (val) {
        flag(this, 'object', val);
      }
  });
};


/***/ }),
/* 79 */
/***/ (function(module, exports) {

/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */

  [ 'to', 'be', 'been'
  , 'is', 'and', 'has', 'have'
  , 'with', 'that', 'which', 'at'
  , 'of', 'same' ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * `.deep.property` special characters can be escaped
   * by adding two slashes before the `.` or `[]`.
   *
   *     var deepCss = { '.link': { '[target]': 42 }};
   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
   *
   * @name deep
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });

  /**
   * ### .any
   *
   * Sets the `any` flag, (opposite of the `all` flag)
   * later used in the `keys` assertion.
   *
   *     expect(foo).to.have.any.keys('bar', 'baz');
   *
   * @name any
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('any', function () {
    flag(this, 'any', true);
    flag(this, 'all', false)
  });


  /**
   * ### .all
   *
   * Sets the `all` flag (opposite of the `any` flag)
   * later used by the `keys` assertion.
   *
   *     expect(foo).to.have.all.keys('bar', 'baz');
   *
   * @name all
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('all', function () {
    flag(this, 'all', true);
    flag(this, 'any', false);
  });

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Error).to.be.an('error');
   *     expect(new Promise).to.be.a('promise');
   *     expect(new Float32Array()).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   *     // es6 overrides
   *     expect({[Symbol.toStringTag]:()=>'foo'}).to.be.a('foo');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object')
      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

    this.assert(
        type === _.type(obj)
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    );
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contains` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, 'contains', true);
  }

  function include (val, msg) {
    _.expectTypes(this, ['array', 'object', 'string']);

    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var expected = false;

    if (_.type(obj) === 'array' && _.type(val) === 'object') {
      for (var i in obj) {
        if (_.eql(obj[i], val)) {
          expected = true;
          break;
        }
      }
    } else if (_.type(val) === 'object') {
      if (!flag(this, 'negate')) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {};
      for (var k in val) subset[k] = obj[k];
      expected = _.eql(subset, val);
    } else {
      expected = (obj != undefined) && ~obj.indexOf(val);
    }
    this.assert(
        expected
      , 'expected #{this} to include ' + _.inspect(val)
      , 'expected #{this} to not include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
  Assertion.addChainableMethod('includes', include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everything').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy');
  });

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(
        true === flag(this, 'object')
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(
        false === flag(this, 'object')
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).to.not.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(
        null === flag(this, 'object')
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    );
  });

  /**
   * ### .NaN
   * Asserts that the target is `NaN`.
   *
   *     expect('foo').to.be.NaN;
   *     expect(4).not.to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('NaN', function () {
    this.assert(
        isNaN(flag(this, 'object'))
        , 'expected #{this} to be NaN'
        , 'expected #{this} not to be NaN'
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('exist', function () {
    this.assert(
        null != flag(this, 'object')
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays and strings, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var obj = flag(this, 'object')
      , expected = obj;

    if (Array.isArray(obj) || 'string' === typeof object) {
      expected = obj.length;
    } else if (typeof obj === 'object') {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, 'object')
      , type = Object.prototype.toString.call(obj);
    this.assert(
        '[object Arguments]' === type
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    );
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'deep')) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len > n
        , 'expected #{this} to have a length above #{exp} but got #{act}'
        , 'expected #{this} to not have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj > n
        , 'expected #{this} to be above ' + n
        , 'expected #{this} to be at most ' + n
      );
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= n
        , 'expected #{this} to have a length at least #{exp} but got #{act}'
        , 'expected #{this} to have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj >= n
        , 'expected #{this} to be at least ' + n
        , 'expected #{this} to be below ' + n
      );
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len < n
        , 'expected #{this} to have a length below #{exp} but got #{act}'
        , 'expected #{this} to not have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj < n
        , 'expected #{this} to be below ' + n
        , 'expected #{this} to be at least ' + n
      );
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len <= n
        , 'expected #{this} to have a length at most #{exp} but got #{act}'
        , 'expected #{this} to have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj <= n
        , 'expected #{this} to be at most ' + n
        , 'expected #{this} to be above ' + n
      );
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , range = start + '..' + finish;
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= start && len <= finish
        , 'expected #{this} to have a length within ' + range
        , 'expected #{this} to not have a length within ' + range
      );
    } else {
      this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, 'object') instanceof constructor
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    );
  };

  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };
   *
   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * Note that dots and bracket in `name` must be backslash-escaped when
   * the `deep` flag is set, while they must NOT be escaped when the `deep`
   * flag is not set.
   *
   *     // simple referencing
   *     var css = { '.link[target]': 42 };
   *     expect(css).to.have.property('.link[target]', 42);
   *
   *     // deep referencing
   *     var deepCss = { '.link': { '[target]': 42 }};
   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('property', function (name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var isDeep = !!flag(this, 'deep')
      , descriptor = isDeep ? 'deep property ' : 'property '
      , negate = flag(this, 'negate')
      , obj = flag(this, 'object')
      , pathInfo = isDeep ? _.getPathInfo(name, obj) : null
      , hasProperty = isDeep
        ? pathInfo.exists
        : _.hasProperty(name, obj)
      , value = isDeep
        ? pathInfo.value
        : obj[name];

    if (negate && arguments.length > 1) {
      if (undefined === value) {
        msg = (msg != null) ? msg + ': ' : '';
        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          hasProperty
        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (arguments.length > 1) {
      this.assert(
          val === value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      );
    }

    flag(this, 'object', value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        obj.hasOwnProperty(name)
      , 'expected #{this} to have own property ' + _.inspect(name)
      , 'expected #{this} to not have own property ' + _.inspect(name)
    );
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, message]])
   *
   * Asserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.
   *
   *     expect('test').to.have.ownPropertyDescriptor('length');
   *     expect('test').to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 4 });
   *     expect('test').not.to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 3 });
   *     expect('test').ownPropertyDescriptor('length').to.have.property('enumerable', false);
   *     expect('test').ownPropertyDescriptor('length').to.have.keys('value');
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnPropertyDescriptor (name, descriptor, msg) {
    if (typeof descriptor === 'string') {
      msg = descriptor;
      descriptor = null;
    }
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
    if (actualDescriptor && descriptor) {
      this.assert(
          _.eql(descriptor, actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)
        , descriptor
        , actualDescriptor
        , true
      );
    } else {
      this.assert(
          actualDescriptor
        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)
        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)
      );
    }
    flag(this, 'object', actualDescriptor);
  }

  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);

  /**
   * ### .length
   *
   * Sets the `doLength` flag later used as a chain precursor to a value
   * comparison for the `length` property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * *Deprecation notice:* Using `length` as an assertion will be deprecated
   * in version 2.4.0 and removed in 3.0.0. Code using the old style of
   * asserting for `length` property value using `length(value)` should be
   * switched to use `lengthOf(value)` instead.
   *
   * @name length
   * @namespace BDD
   * @api public
   */

  /**
   * ### .lengthOf(value[, message])
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.lengthOf(3);
   *     expect('foobar').to.have.lengthOf(6);
   *
   * @name lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertLengthChain () {
    flag(this, 'doLength', true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).to.have.property('length');
    var len = obj.length;

    this.assert(
        len == n
      , 'expected #{this} to have a length of #{exp} but got #{act}'
      , 'expected #{this} to not have a length of #{act}'
      , n
      , len
    );
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addMethod('lengthOf', assertLength);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @alias matches
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */
  function assertMatch(re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    );
  }

  Assertion.addMethod('match', assertMatch);
  Assertion.addMethod('matches', assertMatch);

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('string');

    this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target contains any or all of the passed-in keys.
   * Use in combination with `any`, `all`, `contains`, or `have` will affect
   * what will pass.
   *
   * When used in conjunction with `any`, at least one key that is passed
   * in must exist in the target object. This is regardless whether or not
   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`
   * should be used in the assertion. If neither are used, the assertion is
   * defaulted to `all`.
   *
   * When both `all` and `contain` are used, the target object must have at
   * least all of the passed-in keys but may have more keys not listed.
   *
   * When both `all` and `have` are used, the target object must both contain
   * all of the passed-in keys AND the number of keys in the target object must
   * match the number of keys passed in (in other words, a target object must
   * have all and only all of the passed-in keys).
   *
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo': 7});
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys({'bar': 6});
   *
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, 'object')
      , str
      , ok = true
      , mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments';

    switch (_.type(keys)) {
      case "array":
        if (arguments.length > 1) throw (new Error(mixedArgsMsg));
        break;
      case "object":
        if (arguments.length > 1) throw (new Error(mixedArgsMsg));
        keys = Object.keys(keys);
        break;
      default:
        keys = Array.prototype.slice.call(arguments);
    }

    if (!keys.length) throw new Error('keys required');

    var actual = Object.keys(obj)
      , expected = keys
      , len = keys.length
      , any = flag(this, 'any')
      , all = flag(this, 'all');

    if (!any && !all) {
      all = true;
    }

    // Has any
    if (any) {
      var intersection = expected.filter(function(key) {
        return ~actual.indexOf(key);
      });
      ok = intersection.length > 0;
    }

    // Has all
    if (all) {
      ok = keys.every(function(key){
        return ~actual.indexOf(key);
      });
      if (!flag(this, 'negate') && !flag(this, 'contains')) {
        ok = ok && keys.length == actual.length;
      }
    }

    // Key string
    if (len > 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      if (all) {
        str = keys.join(', ') + ', and ' + last;
      }
      if (any) {
        str = keys.join(', ') + ', or ' + last;
      }
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

    // Assertion
    this.assert(
        ok
      , 'expected #{this} to ' + str
      , 'expected #{this} to not ' + str
      , expected.slice(0).sort()
      , actual.sort()
      , true
    );
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('function');

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor && constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === 'function') {
      name = constructor.prototype.name;
      if (!name || (name === 'Error' && constructor !== Error)) {
        name = constructor.name || (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp}'
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, 'object', err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, 'object', err);
          return this;
        }
      }

      // next, check message
      var message = 'error' === _.type(err) && "message" in err
        ? err.message
        : '' + err;

      if ((message != null) && errMsg && errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , 'expected #{this} to throw error matching #{exp} but got #{act}'
          , 'expected #{this} to throw error not matching #{exp}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , 'expected #{this} to throw error including #{exp} but got #{act}'
          , 'expected #{this} to throw error not including #{act}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = ''
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? '#{exp}' //_.inspect(desiredError)
          : 'an error';

    if (thrown) {
      actuallyGot = ' but #{act} was thrown'
    }

    this.assert(
        thrown === true
      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, 'object', thrownError);
  };

  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function respondTo (method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , itself = flag(this, 'itself')
      , context = ('function' === _.type(obj) && !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        'function' === typeof context
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    );
  }

  Assertion.addMethod('respondTo', respondTo);
  Assertion.addMethod('respondsTo', respondTo);

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo('bar');
   *     expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num > 0; });
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function satisfy (matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var result = matcher(obj);
    this.assert(
        result
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , this.negate ? false : true
      , result
    );
  }

  Assertion.addMethod('satisfy', satisfy);
  Assertion.addMethod('satisfies', satisfy);

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function closeTo(expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj, msg).is.a('number');
    if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {
      throw new Error('the arguments to closeTo or approximately must be numbers');
    }

    this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    );
  }

  Assertion.addMethod('closeTo', closeTo);
  Assertion.addMethod('approximately', closeTo);

  function isSubsetOf(subset, superset, cmp) {
    return subset.every(function(elem) {
      if (!cmp) return superset.indexOf(elem) !== -1;

      return superset.some(function(elem2) {
        return cmp(elem, elem2);
      });
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj).to.be.an('array');
    new Assertion(subset).to.be.an('array');

    var cmp = flag(this, 'deep') ? _.eql : undefined;

    if (flag(this, 'contains')) {
      return this.assert(
          isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to be a superset of #{act}'
        , 'expected #{this} to not be a superset of #{act}'
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to have the same members as #{act}'
        , 'expected #{this} to not have the same members as #{act}'
        , obj
        , subset
    );
  });

  /**
   * ### .oneOf(list)
   *
   * Assert that a value appears somewhere in the top level of array `list`.
   *
   *     expect('a').to.be.oneOf(['a', 'b', 'c']);
   *     expect(9).to.not.be.oneOf(['z']);
   *     expect([3]).to.not.be.oneOf([1, 2, [3]]);
   *
   *     var three = [3];
   *     // for object-types, contents are not compared
   *     expect(three).to.not.be.oneOf([1, 2, [3]]);
   *     // comparing references works
   *     expect(three).to.be.oneOf([1, 2, three]);
   *
   * @name oneOf
   * @param {Array<*>} list
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function oneOf (list, msg) {
    if (msg) flag(this, 'message', msg);
    var expected = flag(this, 'object');
    new Assertion(list).to.be.an('array');

    this.assert(
        list.indexOf(expected) > -1
      , 'expected #{this} to be one of #{exp}'
      , 'expected #{this} to not be one of #{exp}'
      , list
      , expected
    );
  }

  Assertion.addMethod('oneOf', oneOf);


  /**
   * ### .change(function)
   *
   * Asserts that a function changes an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 3 };
   *     var noChangeFn = function() { return 'foo' + 'bar'; }
   *     expect(fn).to.change(obj, 'val');
   *     expect(noChangeFn).to.not.change(obj, 'val')
   *
   * @name change
   * @alias changes
   * @alias Change
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertChanges (object, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object');
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a('function');

    var initial = object[prop];
    fn();

    this.assert(
      initial !== object[prop]
      , 'expected .' + prop + ' to change'
      , 'expected .' + prop + ' to not change'
    );
  }

  Assertion.addChainableMethod('change', assertChanges);
  Assertion.addChainableMethod('changes', assertChanges);

  /**
   * ### .increase(function)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     expect(fn).to.increase(obj, 'val');
   *
   * @name increase
   * @alias increases
   * @alias Increase
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertIncreases (object, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object');
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a('function');

    var initial = object[prop];
    fn();

    this.assert(
      object[prop] - initial > 0
      , 'expected .' + prop + ' to increase'
      , 'expected .' + prop + ' to not increase'
    );
  }

  Assertion.addChainableMethod('increase', assertIncreases);
  Assertion.addChainableMethod('increases', assertIncreases);

  /**
   * ### .decrease(function)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     expect(fn).to.decrease(obj, 'val');
   *
   * @name decrease
   * @alias decreases
   * @alias Decrease
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertDecreases (object, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object');
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a('function');

    var initial = object[prop];
    fn();

    this.assert(
      object[prop] - initial < 0
      , 'expected .' + prop + ' to decrease'
      , 'expected .' + prop + ' to not decrease'
    );
  }

  Assertion.addChainableMethod('decrease', assertDecreases);
  Assertion.addChainableMethod('decreases', assertDecreases);

  /**
   * ### .extensible
   *
   * Asserts that the target is extensible (can have new properties added to
   * it).
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect({}).to.be.extensible;
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('extensible', function() {
    var obj = flag(this, 'object');

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

    var isExtensible;

    try {
      isExtensible = Object.isExtensible(obj);
    } catch (err) {
      if (err instanceof TypeError) isExtensible = false;
      else throw err;
    }

    this.assert(
      isExtensible
      , 'expected #{this} to be extensible'
      , 'expected #{this} to not be extensible'
    );
  });

  /**
   * ### .sealed
   *
   * Asserts that the target is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect({}).to.not.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('sealed', function() {
    var obj = flag(this, 'object');

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

    var isSealed;

    try {
      isSealed = Object.isSealed(obj);
    } catch (err) {
      if (err instanceof TypeError) isSealed = true;
      else throw err;
    }

    this.assert(
      isSealed
      , 'expected #{this} to be sealed'
      , 'expected #{this} to not be sealed'
    );
  });

  /**
   * ### .frozen
   *
   * Asserts that the target is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect({}).to.not.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('frozen', function() {
    var obj = flag(this, 'object');

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

    var isFrozen;

    try {
      isFrozen = Object.isFrozen(obj);
    } catch (err) {
      if (err instanceof TypeError) isFrozen = true;
      else throw err;
    }

    this.assert(
      isFrozen
      , 'expected #{this} to be frozen'
      , 'expected #{this} to not be frozen'
    );
  });
};


/***/ }),
/* 80 */
/***/ (function(module, exports) {

/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Expect
   * @api public
   */

  chai.expect.fail = function (actual, expected, message, operator) {
    message = message || 'expect.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, chai.expect.fail);
  };
};


/***/ }),
/* 81 */
/***/ (function(module, exports) {

/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number || this instanceof Boolean ) {
        return new Assertion(this.valueOf(), null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    /**
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @namespace Should
     * @api public
     */

    should.fail = function (actual, expected, message, operator) {
      message = message || 'should.fail()';
      throw new chai.AssertionError(message, {
          actual: actual
        , expected: expected
        , operator: operator
      }, should.fail);
    };

    /**
     * ### .equal(actual, expected, [message])
     *
     * Asserts non-strict equality (`==`) of `actual` and `expected`.
     *
     *     should.equal(3, '3', '== coerces values to strings');
     *
     * @name equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    /**
     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
     *
     * Asserts that `function` will throw an error that is an instance of
     * `constructor`, or alternately that it will throw an error with message
     * matching `regexp`.
     *
     *     should.throw(fn, 'function throws a reference error');
     *     should.throw(fn, /function throws a reference error/);
     *     should.throw(fn, ReferenceError);
     *     should.throw(fn, ReferenceError, 'function throws a reference error');
     *     should.throw(fn, ReferenceError, /function throws a reference error/);
     *
     * @name throw
     * @alias Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    /**
     * ### .exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var foo = 'hi';
     *
     *     should.exist(foo, 'foo exists');
     *
     * @name exist
     * @namespace Should
     * @api public
     */

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    /**
     * ### .not.equal(actual, expected, [message])
     *
     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
     *
     *     should.not.equal(3, 4, 'these numbers are not equal');
     *
     * @name not.equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    /**
     * ### .throw(function, [constructor/regexp], [message])
     *
     * Asserts that `function` will _not_ throw an error that is an instance of
     * `constructor`, or alternately that it will not throw an error with message
     * matching `regexp`.
     *
     *     should.not.throw(fn, Error, 'function does not throw');
     *
     * @name not.throw
     * @alias not.Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    /**
     * ### .not.exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var bar = null;
     *
     *     should.not.exist(bar, 'bar does not exist');
     *
     * @name not.exist
     * @namespace Should
     * @api public
     */

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};


/***/ }),
/* 82 */
/***/ (function(module, exports) {

/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


module.exports = function (chai, util) {

  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @namespace Assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert);
    test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    );
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Assert
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isOk = function (val, msg) {
    new Assertion(val, msg).is.ok;
  };

  /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotOk = function (val, msg) {
    new Assertion(val, msg).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal);

    test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual);

    test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.eql(exp);
  };

   /**
   * ### .isAbove(valueToCheck, valueToBeAbove, [message])
   *
   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`
   *
   *     assert.isAbove(5, 2, '5 is strictly greater than 2');
   *
   * @name isAbove
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAbove
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAbove = function (val, abv, msg) {
    new Assertion(val, msg).to.be.above(abv);
  };

   /**
   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
   *
   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`
   *
   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
   *
   * @name isAtLeast
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtLeast
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAtLeast = function (val, atlst, msg) {
    new Assertion(val, msg).to.be.least(atlst);
  };

   /**
   * ### .isBelow(valueToCheck, valueToBeBelow, [message])
   *
   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`
   *
   *     assert.isBelow(3, 6, '3 is strictly less than 6');
   *
   * @name isBelow
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeBelow
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isBelow = function (val, blw, msg) {
    new Assertion(val, msg).to.be.below(blw);
  };

   /**
   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
   *
   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`
   *
   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
   *
   * @name isAtMost
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtMost
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAtMost = function (val, atmst, msg) {
    new Assertion(val, msg).to.be.most(atmst);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg).is['true'];
  };

  /**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that `value` is not true.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotTrue(tea, 'great, time for tea!');
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotTrue = function (val, msg) {
    new Assertion(val, msg).to.not.equal(true);
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg).is['false'];
  };

  /**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that `value` is not false.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotFalse(tea, 'great, time for tea!');
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotFalse = function (val, msg) {
    new Assertion(val, msg).to.not.equal(false);
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg).to.not.equal(null);
  };

  /**
   * ### .isNaN
   * Asserts that value is NaN
   *
   *    assert.isNaN('foo', 'foo is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNaN = function (val, msg) {
    new Assertion(val, msg).to.be.NaN;
  };

  /**
   * ### .isNotNaN
   * Asserts that value is not NaN
   *
   *    assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */
  assert.isNotNaN = function (val, msg) {
    new Assertion(val, msg).not.to.be.NaN;
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg).to.be.a('function');
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('function');
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
   * _The assertion does not match subclassed objects._
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg).to.be.a('object');
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('object');
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg).to.be.an('array');
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg).to.not.be.an('array');
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg).to.be.a('string');
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('string');
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg).to.be.a('number');
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('number');
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg).to.be.a('boolean');
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('boolean');
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude).not.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.property(prop);
  };

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop);
  };

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.property(prop, val);
  };

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.propertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 6, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg).to.have.length(len);
  };

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throws(fn, 'function throws a reference error');
   *     assert.throws(fn, /function throws a reference error/);
   *     assert.throws(fn, ReferenceError);
   *     assert.throws(fn, ReferenceError, 'function throws a reference error');
   *     assert.throws(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */

  assert.throws = function (fn, errt, errs, msg) {
    if ('string' === typeof errt || errt instanceof RegExp) {
      errs = errt;
      errt = null;
    }

    var assertErr = new Assertion(fn, msg).to.throw(errt, errs);
    return flag(assertErr, 'object');
  };

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */

  assert.doesNotThrow = function (fn, type, msg) {
    if ('string' === typeof type) {
      msg = type;
      type = null;
    }

    new Assertion(fn, msg).to.not.Throw(type);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    var ok;
    switch(operator) {
      case '==':
        ok = val == val2;
        break;
      case '===':
        ok = val === val2;
        break;
      case '>':
        ok = val > val2;
        break;
      case '>=':
        ok = val >= val2;
        break;
      case '<':
        ok = val < val2;
        break;
      case '<=':
        ok = val <= val2;
        break;
      case '!=':
        ok = val != val2;
        break;
      case '!==':
        ok = val !== val2;
        break;
      default:
        throw new Error('Invalid operator "' + operator + '"');
    }
    var test = new Assertion(ok, msg);
    test.assert(
        true === flag(test, 'object')
      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  /**
   * ### .approximately(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
   *
   * @name approximately
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.approximately = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.approximately(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.members(set2);
  }

  /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members - using a deep equality checking.
   * Order is not taken into account.
   *
   *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.deep.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.members(subset);
  }

  /**
   * ### .includeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` - using deep equality checking.
   * Order is not taken into account.
   * Duplicates are ignored.
   *
   *     assert.includeDeepMembers([ {a: 1}, {b: 2}, {c: 3} ], [ {b: 2}, {a: 1}, {b: 2} ], 'include deep members');
   *
   * @name includeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.deep.members(subset);
  }

  /**
   * ### .oneOf(inList, list, [message])
   *
   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
   *
   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
   *
   * @name oneOf
   * @param {*} inList
   * @param {Array<*>} list
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.oneOf = function (inList, list, msg) {
    new Assertion(inList, msg).to.be.oneOf(list);
  }

   /**
   * ### .changes(function, object, property)
   *
   * Asserts that a function changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.changes = function (fn, obj, prop) {
    new Assertion(fn).to.change(obj, prop);
  }

   /**
   * ### .doesNotChange(function, object, property)
   *
   * Asserts that a function does not changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { console.log('foo'); };
   *     assert.doesNotChange(fn, obj, 'val');
   *
   * @name doesNotChange
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotChange = function (fn, obj, prop) {
    new Assertion(fn).to.not.change(obj, prop);
  }

   /**
   * ### .increases(function, object, property)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.increases = function (fn, obj, prop) {
    new Assertion(fn).to.increase(obj, prop);
  }

   /**
   * ### .doesNotIncrease(function, object, property)
   *
   * Asserts that a function does not increase object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotIncrease = function (fn, obj, prop) {
    new Assertion(fn).to.not.increase(obj, prop);
  }

   /**
   * ### .decreases(function, object, property)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.decreases = function (fn, obj, prop) {
    new Assertion(fn).to.decrease(obj, prop);
  }

   /**
   * ### .doesNotDecrease(function, object, property)
   *
   * Asserts that a function does not decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotDecrease = function (fn, obj, prop) {
    new Assertion(fn).to.not.decrease(obj, prop);
  }

  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */

  assert.ifError = function (val) {
    if (val) {
      throw(val);
    }
  };

  /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isExtensible = function (obj, msg) {
    new Assertion(obj, msg).to.be.extensible;
  };

  /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freese({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotExtensible = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.extensible;
  };

  /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isSealed = function (obj, msg) {
    new Assertion(obj, msg).to.be.sealed;
  };

  /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotSealed = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.sealed;
  };

  /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isFrozen = function (obj, msg) {
    new Assertion(obj, msg).to.be.frozen;
  };

  /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotFrozen = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.frozen;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  ('isOk', 'ok')
  ('isNotOk', 'notOk')
  ('throws', 'throw')
  ('throws', 'Throw')
  ('isExtensible', 'extensible')
  ('isNotExtensible', 'notExtensible')
  ('isSealed', 'sealed')
  ('isNotSealed', 'notSealed')
  ('isFrozen', 'frozen')
  ('isNotFrozen', 'notFrozen');
};


/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports = require("fs-extra");

/***/ }),
/* 85 */
/***/ (function(module, exports) {

module.exports = require("async");

/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = require("truffle-workflow-compile");

/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = require("truffle-debug-utils");

/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports = require("truffle-artifactor");

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = require("truffle-migrate");

/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = require("truffle-box");

/***/ }),
/* 91 */
/***/ (function(module, exports) {

module.exports = require("truffle-resolver");

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = __webpack_require__(17);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _values = __webpack_require__(93);

var _values2 = _interopRequireDefault(_values);

var _typeof2 = __webpack_require__(46);

var _typeof3 = _interopRequireDefault(_typeof2);

var _promise = __webpack_require__(31);

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = __webpack_require__(32);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(33);

var _createClass3 = _interopRequireDefault(_createClass2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _selectors = __webpack_require__(26);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(7);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(21);

var _selectors6 = _interopRequireDefault(_selectors5);

var _selectors7 = __webpack_require__(9);

var _selectors8 = _interopRequireDefault(_selectors7);

var _store = __webpack_require__(97);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(48);

var controller = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(35);

var actions = _interopRequireWildcard(_actions2);

var _sagas = __webpack_require__(102);

var _sagas2 = _interopRequireDefault(_sagas);

var _reducers = __webpack_require__(115);

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger:session");

/**
 * Debugger Session
 */
var Session = function () {
  /**
   * @param {Array<Contract>} contracts - contract definitions
   * @param {Array<String>} files - array of filenames for sourceMap indexes
   * @param {string} txHash - transaction hash
   * @param {Web3Provider} provider - web3 provider
   * @private
   */
  function Session(contracts, files, txHash, provider) {
    (0, _classCallCheck3.default)(this, Session);

    /**
     * @private
     */
    this._store = (0, _store2.default)(_reducers2.default, _sagas2.default);

    var _Session$normalize = Session.normalize(contracts, files),
        contexts = _Session$normalize.contexts,
        sources = _Session$normalize.sources;

    // record contracts


    this._store.dispatch(actions.recordContracts(contexts, sources));

    this._store.dispatch(actions.start(txHash, provider));
  }

  (0, _createClass3.default)(Session, [{
    key: "ready",
    value: function ready() {
      var _this = this;

      return new _promise2.default(function (accept, reject) {
        _this._store.subscribe(function () {
          if (_this.state.session == "ACTIVE") {
            accept();
          } else if ((0, _typeof3.default)(_this.state.session) == "object") {
            reject(_this.state.session.error);
          }
        });
      });
    }

    /**
     * Split up artifacts into "contexts" and "sources", dividing artifact
     * data into appropriate buckets.
     *
     * Multiple contracts can be defined in the same source file, but have
     * different bytecodes.
     *
     * This iterates over the contracts and collects binaries separately
     * from sources, using the optional `files` argument to force
     * source ordering.
     * @private
     */

  }, {
    key: "view",
    value: function view(selector) {
      return selector(this.state);
    }
  }, {
    key: "dispatch",
    value: function dispatch(action) {
      if (this.finished) {
        debug("finished: intercepting action %o", action);

        return false;
      }

      this._store.dispatch(action);

      return true;
    }
  }, {
    key: "interrupt",
    value: function interrupt() {
      return this.dispatch(controller.interrupt());
    }
  }, {
    key: "advance",
    value: function advance() {
      return this.dispatch(controller.advance());
    }
  }, {
    key: "stepNext",
    value: function stepNext() {
      return this.dispatch(controller.stepNext());
    }
  }, {
    key: "stepOver",
    value: function stepOver() {
      return this.dispatch(controller.stepOver());
    }
  }, {
    key: "stepInto",
    value: function stepInto() {
      return this.dispatch(controller.stepInto());
    }
  }, {
    key: "stepOut",
    value: function stepOut() {
      return this.dispatch(controller.stepOut());
    }
  }, {
    key: "continueUntil",
    value: function continueUntil() {
      return this.dispatch(controller.continueUntil.apply(controller, arguments));
    }
  }, {
    key: "state",
    get: function get() {
      return this._store.getState();
    }
  }, {
    key: "finished",
    get: function get() {
      return this.state.session == "FINISHED";
    }
  }, {
    key: "failed",
    get: function get() {
      return this.finished && this.view(_selectors4.default.current.callstack).length;
    }
  }], [{
    key: "normalize",
    value: function normalize(contracts) {
      var files = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var sourcesByPath = {};
      var contexts = [];
      var sources = void 0;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(contracts), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var contract = _step.value;
          var contractName = contract.contractName,
              binary = contract.binary,
              sourceMap = contract.sourceMap,
              deployedBinary = contract.deployedBinary,
              deployedSourceMap = contract.deployedSourceMap,
              sourcePath = contract.sourcePath,
              source = contract.source,
              _ast = contract.ast;

          sourcesByPath[sourcePath] = { sourcePath: sourcePath, source: source, ast: _ast };

          if (binary && binary != "0x") {
            contexts.push({
              contractName: contractName,
              binary: binary,
              sourceMap: sourceMap
            });
          }

          if (deployedBinary && deployedBinary != "0x") {
            contexts.push({
              contractName: contractName,
              binary: deployedBinary,
              sourceMap: deployedSourceMap
            });
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (!files) {
        sources = (0, _values2.default)(sourcesByPath);
      } else {
        sources = files.map(function (file) {
          return sourcesByPath[file];
        });
      }

      return { contexts: contexts, sources: sources };
    }
  }]);
  return Session;
}();

exports.default = Session;

/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/values");

/***/ }),
/* 94 */
/***/ (function(module, exports) {

module.exports = require("truffle-solidity-utils");

/***/ }),
/* 95 */
/***/ (function(module, exports) {

module.exports = require("truffle-code-utils");

/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = require("node-interval-tree");

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {
  module.exports = require("./production");
} else if (true) {
  module.exports = __webpack_require__(98);
} else {
  module.exports = require("./development");
}

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(99);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = _common2.default;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(3);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _slicedToArray2 = __webpack_require__(4);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _toConsumableArray2 = __webpack_require__(2);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

exports.abbreviateValues = abbreviateValues;
exports.default = configureStore;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(22);

var _reduxSaga = __webpack_require__(100);

var _reduxSaga2 = _interopRequireDefault(_reduxSaga);

var _reduxCliLogger = __webpack_require__(101);

var _reduxCliLogger2 = _interopRequireDefault(_reduxCliLogger);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger:store:common");
var reduxDebug = (0, _debug2.default)("debugger:redux");

function abbreviateValues(value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  options.stringLimit = options.stringLimit || 66;
  options.arrayLimit = options.arrayLimit || 8;
  options.recurseLimit = options.recurseLimit || 4;

  if (depth > options.recurseLimit) {
    return "...";
  }

  var recurse = function recurse(child) {
    return abbreviateValues(child, options, depth + 1);
  };

  if (value instanceof Array) {
    if (value.length > options.arrayLimit) {
      value = [].concat((0, _toConsumableArray3.default)(value.slice(0, options.arrayLimit / 2)), ["..."], (0, _toConsumableArray3.default)(value.slice(value.length - options.arrayLimit / 2 + 1)));
    }

    return value.map(recurse);
  } else if (value instanceof Object) {
    return _assign2.default.apply(Object, [{}].concat((0, _toConsumableArray3.default)((0, _entries2.default)(value).map(function (_ref) {
      var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      return (0, _defineProperty3.default)({}, recurse(k), recurse(v));
    }))));
  } else if (typeof value === "string" && value.length > options.stringLimit) {
    var inner = "...";
    var extractAmount = (options.stringLimit - inner.length) / 2;
    var leading = value.slice(0, Math.ceil(extractAmount));
    var trailing = value.slice(value.length - Math.floor(extractAmount));
    return "" + leading + inner + trailing;
  } else {
    return value;
  }
}

function configureStore(reducer, saga, initialState, composeEnhancers) {
  var sagaMiddleware = (0, _reduxSaga2.default)();

  if (!composeEnhancers) {
    composeEnhancers = _redux.compose;
  }

  var loggerMiddleware = (0, _reduxCliLogger2.default)({
    log: reduxDebug,
    stateTransformer: function stateTransformer(state) {
      return abbreviateValues(state, {
        arrayLimit: 4,
        recurseLimit: 3
      });
    },
    actionTransformer: abbreviateValues
  });

  var store = (0, _redux.createStore)(reducer, initialState, composeEnhancers((0, _redux.applyMiddleware)(sagaMiddleware, loggerMiddleware)));

  sagaMiddleware.run(saga);

  return store;
}

/***/ }),
/* 100 */
/***/ (function(module, exports) {

module.exports = require("redux-saga");

/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports = require("redux-cli-logger");

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = __webpack_require__(17);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _toConsumableArray2 = __webpack_require__(2);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(14);

var _helpers = __webpack_require__(6);

var _sagas = __webpack_require__(103);

var ast = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(108);

var controller = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(110);

var solidity = _interopRequireWildcard(_sagas3);

var _sagas4 = __webpack_require__(111);

var evm = _interopRequireWildcard(_sagas4);

var _sagas5 = __webpack_require__(51);

var trace = _interopRequireWildcard(_sagas5);

var _sagas6 = __webpack_require__(49);

var data = _interopRequireWildcard(_sagas6);

var _sagas7 = __webpack_require__(112);

var web3 = _interopRequireWildcard(_sagas7);

var _actions = __webpack_require__(35);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _marked = /*#__PURE__*/_regenerator2.default.mark(saga),
    _marked2 = /*#__PURE__*/_regenerator2.default.mark(forkListeners),
    _marked3 = /*#__PURE__*/_regenerator2.default.mark(fetchTx),
    _marked4 = /*#__PURE__*/_regenerator2.default.mark(recordContexts),
    _marked5 = /*#__PURE__*/_regenerator2.default.mark(recordSources),
    _marked6 = /*#__PURE__*/_regenerator2.default.mark(recordInstance),
    _marked7 = /*#__PURE__*/_regenerator2.default.mark(ready),
    _marked8 = /*#__PURE__*/_regenerator2.default.mark(error);

var debug = (0, _debug2.default)("debugger:session:sagas");

function saga() {
  var listeners, _ref, contexts, sources, _ref2, txHash, provider, err;

  return _regenerator2.default.wrap(function saga$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          debug("starting listeners");
          return _context.delegateYield(forkListeners(), "t0", 2);

        case 2:
          listeners = _context.t0;

          // receiving & saving contracts into state
          debug("waiting for contract information");
          _context.next = 6;
          return (0, _effects.take)(actions.RECORD_CONTRACTS);

        case 6:
          _ref = _context.sent;
          contexts = _ref.contexts;
          sources = _ref.sources;

          debug("recording contract binaries");
          return _context.delegateYield(recordContexts.apply(undefined, (0, _toConsumableArray3.default)(contexts)), "t1", 11);

        case 11:

          debug("recording contract sources");
          return _context.delegateYield(recordSources.apply(undefined, (0, _toConsumableArray3.default)(sources)), "t2", 13);

        case 13:

          debug("waiting for start");
          // wait for start signal
          _context.next = 16;
          return (0, _effects.take)(actions.START);

        case 16:
          _ref2 = _context.sent;
          txHash = _ref2.txHash;
          provider = _ref2.provider;

          debug("starting");

          // process transaction
          debug("fetching transaction info");
          return _context.delegateYield(fetchTx(txHash, provider), "t3", 22);

        case 22:
          err = _context.t3;

          if (!err) {
            _context.next = 28;
            break;
          }

          debug("error %o", err);
          return _context.delegateYield(error(err), "t4", 26);

        case 26:
          _context.next = 37;
          break;

        case 28:
          debug("visiting ASTs");
          // visit asts
          return _context.delegateYield(ast.visitAll(), "t5", 30);

        case 30:

          debug("readying");
          // signal that stepping can begin
          return _context.delegateYield(ready(), "t6", 32);

        case 32:

          debug("waiting for trace EOT");
          // wait until trace hits EOT
          return _context.delegateYield(trace.wait(), "t7", 34);

        case 34:

          debug("finishing");
          // finish
          _context.next = 37;
          return (0, _effects.put)(actions.finish());

        case 37:

          debug("stopping listeners");
          _context.next = 40;
          return (0, _effects.all)(listeners.map(function (task) {
            return (0, _effects.cancel)(task);
          }));

        case 40:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

exports.default = (0, _helpers.prefixName)("session", saga);

function forkListeners() {
  return _regenerator2.default.wrap(function forkListeners$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return (0, _effects.all)([ast, controller, data, evm, solidity, trace, web3].map(function (app) {
            return (0, _effects.fork)(app.saga);
          }));

        case 2:
          return _context2.abrupt("return", _context2.sent);

        case 3:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, this);
}

function fetchTx(txHash, provider) {
  var result, addresses, binaries;
  return _regenerator2.default.wrap(function fetchTx$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          return _context3.delegateYield(web3.inspectTransaction(txHash, provider), "t0", 1);

        case 1:
          result = _context3.t0;

          if (!result.error) {
            _context3.next = 4;
            break;
          }

          return _context3.abrupt("return", result.error);

        case 4:
          return _context3.delegateYield(evm.begin(result), "t1", 5);

        case 5:
          return _context3.delegateYield(trace.processTrace(result.trace), "t2", 6);

        case 6:
          addresses = _context3.t2;

          if (result.address && addresses.indexOf(result.address) == -1) {
            addresses.push(result.address);
          }

          return _context3.delegateYield(web3.obtainBinaries(addresses), "t3", 9);

        case 9:
          binaries = _context3.t3;
          _context3.next = 12;
          return (0, _effects.all)(addresses.map(function (address, i) {
            return (0, _effects.call)(recordInstance, address, binaries[i]);
          }));

        case 12:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3, this);
}

function recordContexts() {
  for (var _len = arguments.length, contexts = Array(_len), _key = 0; _key < _len; _key++) {
    contexts[_key] = arguments[_key];
  }

  var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _ref3, contractName, binary, sourceMap;

  return _regenerator2.default.wrap(function recordContexts$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context4.prev = 3;
          _iterator = (0, _getIterator3.default)(contexts);

        case 5:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context4.next = 14;
            break;
          }

          _ref3 = _step.value;
          contractName = _ref3.contractName, binary = _ref3.binary, sourceMap = _ref3.sourceMap;
          return _context4.delegateYield(evm.addContext(contractName, binary), "t0", 9);

        case 9:
          if (!sourceMap) {
            _context4.next = 11;
            break;
          }

          return _context4.delegateYield(solidity.addSourceMap(binary, sourceMap), "t1", 11);

        case 11:
          _iteratorNormalCompletion = true;
          _context4.next = 5;
          break;

        case 14:
          _context4.next = 20;
          break;

        case 16:
          _context4.prev = 16;
          _context4.t2 = _context4["catch"](3);
          _didIteratorError = true;
          _iteratorError = _context4.t2;

        case 20:
          _context4.prev = 20;
          _context4.prev = 21;

          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }

        case 23:
          _context4.prev = 23;

          if (!_didIteratorError) {
            _context4.next = 26;
            break;
          }

          throw _iteratorError;

        case 26:
          return _context4.finish(23);

        case 27:
          return _context4.finish(20);

        case 28:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, this, [[3, 16, 20, 28], [21,, 23, 27]]);
}

function recordSources() {
  for (var _len2 = arguments.length, sources = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    sources[_key2] = arguments[_key2];
  }

  var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _ref4, sourcePath, source, _ast;

  return _regenerator2.default.wrap(function recordSources$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context5.prev = 3;
          _iterator2 = (0, _getIterator3.default)(sources);

        case 5:
          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
            _context5.next = 12;
            break;
          }

          _ref4 = _step2.value;
          sourcePath = _ref4.sourcePath, source = _ref4.source, _ast = _ref4.ast;
          return _context5.delegateYield(solidity.addSource(source, sourcePath, _ast), "t0", 9);

        case 9:
          _iteratorNormalCompletion2 = true;
          _context5.next = 5;
          break;

        case 12:
          _context5.next = 18;
          break;

        case 14:
          _context5.prev = 14;
          _context5.t1 = _context5["catch"](3);
          _didIteratorError2 = true;
          _iteratorError2 = _context5.t1;

        case 18:
          _context5.prev = 18;
          _context5.prev = 19;

          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }

        case 21:
          _context5.prev = 21;

          if (!_didIteratorError2) {
            _context5.next = 24;
            break;
          }

          throw _iteratorError2;

        case 24:
          return _context5.finish(21);

        case 25:
          return _context5.finish(18);

        case 26:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5, this, [[3, 14, 18, 26], [19,, 21, 25]]);
}

function recordInstance(address, binary) {
  return _regenerator2.default.wrap(function recordInstance$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          return _context6.delegateYield(evm.addInstance(address, binary), "t0", 1);

        case 1:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6, this);
}

function ready() {
  return _regenerator2.default.wrap(function ready$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          _context7.next = 2;
          return (0, _effects.put)(actions.ready());

        case 2:
        case "end":
          return _context7.stop();
      }
    }
  }, _marked7, this);
}

function error(err) {
  return _regenerator2.default.wrap(function error$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _context8.next = 2;
          return (0, _effects.put)(actions.error(err));

        case 2:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked8, this);
}

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = __webpack_require__(2);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _getIterator2 = __webpack_require__(17);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _slicedToArray2 = __webpack_require__(4);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

exports.visitAll = visitAll;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(14);

var _helpers = __webpack_require__(6);

var _sagas = __webpack_require__(49);

var data = _interopRequireWildcard(_sagas);

var _actions = __webpack_require__(107);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(21);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _marked = /*#__PURE__*/_regenerator2.default.mark(walk),
    _marked2 = /*#__PURE__*/_regenerator2.default.mark(handleEnter),
    _marked3 = /*#__PURE__*/_regenerator2.default.mark(handleExit),
    _marked4 = /*#__PURE__*/_regenerator2.default.mark(walkSaga),
    _marked5 = /*#__PURE__*/_regenerator2.default.mark(visitAll),
    _marked6 = /*#__PURE__*/_regenerator2.default.mark(saga);

var debug = (0, _debug2.default)("debugger:ast:sagas");

function walk(sourceId, node) {
  var pointer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
  var parentId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _ref, _ref2, i, child, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _ref3, _ref4, key, _child;

  return _regenerator2.default.wrap(function walk$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          debug("walking %o %o", pointer, node);

          return _context.delegateYield(handleEnter(sourceId, node, pointer, parentId), "t0", 2);

        case 2:
          if (!(node instanceof Array)) {
            _context.next = 34;
            break;
          }

          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 6;
          _iterator = (0, _getIterator3.default)(node.entries());

        case 8:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 18;
            break;
          }

          _ref = _step.value;
          _ref2 = (0, _slicedToArray3.default)(_ref, 2);
          i = _ref2[0];
          child = _ref2[1];
          _context.next = 15;
          return (0, _effects.call)(walk, sourceId, child, pointer + "/" + i, parentId);

        case 15:
          _iteratorNormalCompletion = true;
          _context.next = 8;
          break;

        case 18:
          _context.next = 24;
          break;

        case 20:
          _context.prev = 20;
          _context.t1 = _context["catch"](6);
          _didIteratorError = true;
          _iteratorError = _context.t1;

        case 24:
          _context.prev = 24;
          _context.prev = 25;

          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }

        case 27:
          _context.prev = 27;

          if (!_didIteratorError) {
            _context.next = 30;
            break;
          }

          throw _iteratorError;

        case 30:
          return _context.finish(27);

        case 31:
          return _context.finish(24);

        case 32:
          _context.next = 64;
          break;

        case 34:
          if (!(node instanceof Object)) {
            _context.next = 64;
            break;
          }

          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context.prev = 38;
          _iterator2 = (0, _getIterator3.default)((0, _entries2.default)(node));

        case 40:
          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
            _context.next = 50;
            break;
          }

          _ref3 = _step2.value;
          _ref4 = (0, _slicedToArray3.default)(_ref3, 2);
          key = _ref4[0];
          _child = _ref4[1];
          _context.next = 47;
          return (0, _effects.call)(walk, sourceId, _child, pointer + "/" + key, node.id);

        case 47:
          _iteratorNormalCompletion2 = true;
          _context.next = 40;
          break;

        case 50:
          _context.next = 56;
          break;

        case 52:
          _context.prev = 52;
          _context.t2 = _context["catch"](38);
          _didIteratorError2 = true;
          _iteratorError2 = _context.t2;

        case 56:
          _context.prev = 56;
          _context.prev = 57;

          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }

        case 59:
          _context.prev = 59;

          if (!_didIteratorError2) {
            _context.next = 62;
            break;
          }

          throw _iteratorError2;

        case 62:
          return _context.finish(59);

        case 63:
          return _context.finish(56);

        case 64:
          return _context.delegateYield(handleExit(sourceId, node, pointer), "t3", 65);

        case 65:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this, [[6, 20, 24, 32], [25,, 27, 31], [38, 52, 56, 64], [57,, 59, 63]]);
}

function handleEnter(sourceId, node, pointer, parentId) {
  return _regenerator2.default.wrap(function handleEnter$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (node instanceof Object) {
            _context2.next = 2;
            break;
          }

          return _context2.abrupt("return");

        case 2:

          debug("entering %s", pointer);

          if (!(node.id !== undefined)) {
            _context2.next = 6;
            break;
          }

          debug("%s recording scope %s", pointer, node.id);
          return _context2.delegateYield(data.scope(node.id, pointer, parentId, sourceId), "t0", 6);

        case 6:
          _context2.t1 = node.nodeType;
          _context2.next = _context2.t1 === "VariableDeclaration" ? 9 : 12;
          break;

        case 9:
          debug("%s recording variable %o", pointer, node);
          return _context2.delegateYield(data.declare(node), "t2", 11);

        case 11:
          return _context2.abrupt("break", 12);

        case 12:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, this);
}

function handleExit(sourceId, node, pointer) {
  return _regenerator2.default.wrap(function handleExit$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          debug("exiting %s", pointer);

        // no-op right now

        case 1:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3, this);
}

function walkSaga(_ref5) {
  var sourceId = _ref5.sourceId,
      ast = _ref5.ast;
  return _regenerator2.default.wrap(function walkSaga$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return walk(sourceId, ast);

        case 2:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, this);
}

function visitAll(idx) {
  var sources, tasks;
  return _regenerator2.default.wrap(function visitAll$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return (0, _effects.select)(_selectors2.default.views.sources);

        case 2:
          sources = _context5.sent;
          _context5.next = 5;
          return (0, _effects.all)((0, _entries2.default)(sources).filter(function (_ref6) {
            var _ref7 = (0, _slicedToArray3.default)(_ref6, 2),
                id = _ref7[0],
                ast = _ref7[1].ast;

            return !!ast;
          }).map(function (_ref8) {
            var _ref9 = (0, _slicedToArray3.default)(_ref8, 2),
                id = _ref9[0],
                ast = _ref9[1].ast;

            return (0, _effects.fork)(function () {
              return (0, _effects.put)(actions.visit(id, ast));
            });
          }));

        case 5:
          tasks = _context5.sent;

          if (!(tasks.length > 0)) {
            _context5.next = 9;
            break;
          }

          _context5.next = 9;
          return _effects.join.apply(undefined, (0, _toConsumableArray3.default)(tasks));

        case 9:
          _context5.next = 11;
          return (0, _effects.put)(actions.doneVisiting());

        case 11:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5, this);
}

function saga() {
  return _regenerator2.default.wrap(function saga$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _context6.next = 2;
          return (0, _effects.race)({
            visitor: (0, _effects.takeEvery)(actions.VISIT, walkSaga),
            done: (0, _effects.take)(actions.DONE_VISITING)
          });

        case 2:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6, this);
}

exports.default = (0, _helpers.prefixName)("ast", saga);

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __webpack_require__(4);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _defineProperty2 = __webpack_require__(3);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _extends2 = __webpack_require__(13);

var _extends3 = _interopRequireDefault(_extends2);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _toConsumableArray2 = __webpack_require__(2);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

exports.read = read;
exports.decodeValue = decodeValue;
exports.decodeMemoryReference = decodeMemoryReference;
exports.decodeStorageReference = decodeStorageReference;
exports.default = decode;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _bignumber = __webpack_require__(27);

var _memory = __webpack_require__(105);

var memory = _interopRequireWildcard(_memory);

var _storage = __webpack_require__(106);

var storage = _interopRequireWildcard(_storage);

var _utils = __webpack_require__(15);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger:data:decode");

function read(pointer, state) {
  if (pointer.stack != undefined && state.stack && pointer.stack < state.stack.length) {
    return state.stack[pointer.stack];
  } else if (pointer.storage != undefined && state.storage) {
    return storage.readRange(state.storage, pointer.storage);
  } else if (pointer.memory != undefined && state.memory) {
    return memory.readBytes(state.memory, pointer.memory.start, pointer.memory.length);
  } else if (pointer.literal) {
    return pointer.literal;
  }
}

function decodeValue(definition, pointer, state) {
  var bytes = read(pointer, state);
  if (!bytes) {
    return undefined;
  }

  switch (utils.typeClass(definition)) {
    case "bool":
      return !utils.toBigNumber(bytes).isZero();

    case "uint":
      return utils.toBigNumber(bytes);

    case "int":
      return utils.toSignedBigNumber(bytes);

    case "address":
      return utils.toHexString(bytes, true);

    case "bytes":
      debug("typeIdentifier %s %o", utils.typeIdentifier(definition), bytes);
      var length = utils.specifiedSize(definition);
      return utils.toHexString(bytes, length);

    case "string":
      debug("typeIdentifier %s %o", utils.typeIdentifier(definition), bytes);
      return String.fromCharCode.apply(null, bytes);

    default:
      debug("Unknown value type: %s", utils.typeIdentifier(definition));
      return null;
  }
}

function decodeMemoryReference(definition, pointer, state) {
  for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    args[_key - 3] = arguments[_key];
  }

  var rawValue = utils.toBigNumber(read(pointer, state)).toNumber();

  var bytes;
  switch (utils.typeClass(definition)) {

    case "bytes":
    case "string":
      bytes = read({
        memory: { start: rawValue, length: _utils.WORD_SIZE }
      }, state); // bytes contain length

      return decodeValue.apply(undefined, [definition, {
        memory: { start: rawValue + _utils.WORD_SIZE, length: bytes }
      }, state].concat(args));

    case "array":
      bytes = utils.toBigNumber(read({
        memory: { start: rawValue, length: _utils.WORD_SIZE }
      }, state)).toNumber(); // bytes contain array length

      bytes = read({ memory: {
          start: rawValue + _utils.WORD_SIZE, length: bytes * _utils.WORD_SIZE
        } }, state); // now bytes contain items

      return memory.chunk(bytes, _utils.WORD_SIZE).map(function (chunk) {
        return decode.apply(undefined, [utils.baseDefinition(definition), {
          literal: chunk
        }, state].concat(args));
      });

    case "struct":
      var refs = args[0];

      var structDefinition = refs[definition.typeName.referencedDeclaration];
      var structVariables = structDefinition.variables || [];

      return _assign2.default.apply(Object, [{}].concat((0, _toConsumableArray3.default)(structVariables.map(function (_ref, i) {
        var name = _ref.name,
            id = _ref.id;

        var memberDefinition = refs[id].definition;
        var memberPointer = {
          memory: { start: rawValue + i * _utils.WORD_SIZE, length: _utils.WORD_SIZE }
        };
        // let memberPointer = memory.read(state.memory, pointer + i * WORD_SIZE);

        // HACK
        memberDefinition = (0, _extends3.default)({}, memberDefinition, {

          typeDescriptions: (0, _extends3.default)({}, memberDefinition.typeDescriptions, {

            typeIdentifier: memberDefinition.typeDescriptions.typeIdentifier.replace(/_storage_/g, "_memory_")
          })
        });

        return (0, _defineProperty3.default)({}, name, decode.apply(undefined, [memberDefinition, memberPointer, state].concat(args)));
      }))));

    default:
      debug("Unknown memory reference type: %s", utils.typeIdentifier(definition));
      return null;

  }
}

function decodeStorageReference(definition, pointer, state) {
  for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    args[_key2 - 3] = arguments[_key2];
  }

  var data;
  var bytes;
  var length;
  var slot;

  switch (utils.typeClass(definition)) {
    case "array":
      debug("storage array! %o", pointer);
      data = read(pointer, state);
      if (!data) {
        return null;
      }

      length = utils.toBigNumber(data).toNumber();
      debug("length %o", length);

      var baseSize = utils.storageSize(utils.baseDefinition(definition));
      var perWord = Math.floor(_utils.WORD_SIZE / baseSize);
      debug("baseSize %o", baseSize);
      debug("perWord %d", perWord);

      var offset = function offset(i) {
        if (perWord == 1) {
          return i;
        }

        return Math.floor(i * baseSize / _utils.WORD_SIZE);
      };

      var index = function index(i) {
        if (perWord == 1) {
          return _utils.WORD_SIZE - baseSize;
        }

        var position = perWord - i % perWord - 1;
        return position * baseSize;
      };

      debug("pointer: %o", pointer);
      return [].concat((0, _toConsumableArray3.default)(Array(length).keys())).map(function (i) {
        var childFrom = pointer.storage.from.offset != undefined ? {
          slot: ["0x" + utils.toBigNumber(utils.keccak256.apply(utils, (0, _toConsumableArray3.default)(pointer.storage.from.slot))).plus(pointer.storage.from.offset).toString(16)],
          offset: offset(i),
          index: index(i)
        } : {
          slot: [pointer.storage.from.slot],
          offset: offset(i),
          index: index(i)
        };
        return childFrom;
      }).map(function (childFrom, idx) {
        debug("childFrom %d, %o", idx, childFrom);
        return decode.apply(undefined, [utils.baseDefinition(definition), { storage: {
            from: childFrom,
            length: baseSize
          } }, state].concat(args));
      });

    case "bytes":
    case "string":
      data = read(pointer, state);
      if (!data) {
        return null;
      }

      if (data[_utils.WORD_SIZE - 1] % 2 == 0) {
        // string lives in word, length is last byte / 2
        length = data[_utils.WORD_SIZE - 1] / 2;
        debug("in-word; length %o", length);
        if (length == 0) {
          return "";
        }

        return decodeValue.apply(undefined, [definition, { storage: {
            from: { slot: pointer.storage.from.slot, index: 0 },
            to: { slot: pointer.storage.from.slot, index: length - 1 }
          } }, state].concat(args));
      } else {
        length = utils.toBigNumber(data).minus(1).div(2).toNumber();
        debug("new-word, length %o", length);

        return decodeValue.apply(undefined, [definition, { storage: {
            from: { slot: [pointer.storage.from.slot], index: 0 },
            length: length
          } }, state].concat(args));
      }

    case "struct":
      var refs = args[0];

      return _assign2.default.apply(Object, [{}].concat((0, _toConsumableArray3.default)((0, _entries2.default)(pointer.storage.children).map(function (_ref3) {
        var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),
            id = _ref4[0],
            childPointer = _ref4[1];

        return (0, _defineProperty3.default)({}, childPointer.name, decode.apply(undefined, [refs[id].definition, { storage: childPointer }, state].concat(args)));
      }))));

    default:
      debug("Unknown storage reference type: %s", utils.typeIdentifier(definition));
      return undefined;
  }
}

function decode(definition) {
  for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  if (!utils.isReference(definition)) {
    return decodeValue.apply(undefined, [definition].concat(args));
  }

  switch (utils.referenceType(definition)) {
    case "memory":
      return decodeMemoryReference.apply(undefined, [definition].concat(args));
    case "storage":
      return decodeStorageReference.apply(undefined, [definition].concat(args));
    default:
      debug("Unknown reference category: %s", utils.typeIdentifier(definition));
      return undefined;
  }
}

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.read = read;
exports.readBytes = readBytes;
exports.chunk = chunk;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _bignumber = __webpack_require__(27);

var _utils = __webpack_require__(15);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger:data:decode:memory");

/**
 * read word from memory
 *
 * requires `byte` to be a multiple of WORD_SIZE (32)
 *
 * @param memory - Uint8Array
 * @return {BigNumber}
 */
function read(memory, byte) {
  return readBytes(memory, byte, _utils.WORD_SIZE);
}

/**
 * read <bytes> amount of bytes from memory, starting at byte <start>
 *
 * @param memory - Uint8Array
 */
function readBytes(memory, byte, length) {
  byte = utils.toBigNumber(byte);
  length = utils.toBigNumber(length);

  if (byte.toNumber() >= memory.length) {
    return new Uint8Array(length ? length.toNumber() : 0);
  }

  if (length == undefined) {
    return new Uint8Array(memory.buffer, byte.toNumber());
  }

  // grab `length` bytes no matter what, here fill this array
  var bytes = new Uint8Array(length.toNumber());

  // if we're reading past the end of memory, truncate the length to read
  var excess = byte.plus(length).minus(memory.length).toNumber();
  if (excess > 0) {
    length = new _bignumber.BigNumber(memory.length).minus(byte);
  }

  var existing = new Uint8Array(memory.buffer, byte.toNumber(), length.toNumber());

  bytes.set(existing);

  return bytes;
}

/**
 * Split memory into chunks
 */
function chunk(memory) {
  var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _utils.WORD_SIZE;

  var chunks = [];

  for (var i = 0; i < memory.length; i += size) {
    var _chunk = readBytes(memory, i, size);
    chunks.push(_chunk);
  }

  return chunks;
}

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(13);

var _extends3 = _interopRequireDefault(_extends2);

var _toConsumableArray2 = __webpack_require__(2);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

exports.read = read;
exports.readRange = readRange;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _utils = __webpack_require__(15);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger:data:decode:storage");

/**
 * read slot from storage
 *
 * @param slot - big number or array of regular numbers
 * @param offset - for array, offset from the keccak determined location
 */
function read(storage, slot) {
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  if (slot instanceof Array) {
    slot = utils.keccak256.apply(utils, (0, _toConsumableArray3.default)(slot.map(utils.toBigNumber)));
  }

  slot = utils.toBigNumber(slot).plus(offset);

  debug("reading slot: %o", utils.toHexString(slot));

  var word = storage[utils.toHexString(slot, _utils.WORD_SIZE)] || new Uint8Array(_utils.WORD_SIZE);

  debug("word %o", word);
  return word;
}

/**
 * read all bytes in some range.
 *
 * parameters `from` and `to` are objects with the following properties:
 *
 *   slot - (required) either a bignumber or a "path" array of integer offsets
 *
 *     path array values get converted into keccak256 hash as per solidity
 *     storage allocation method
 *
 *     ref: https://solidity.readthedocs.io/en/v0.4.23/miscellaneous.html#layout-of-state-variables-in-storage
 *     (search "concatenation")
 *
 *  offset - (default: 0) slot offset
 *
 *  index - (default: 0) byte index in word
 *
 * @param from - location (see ^)
 * @param to - location (see ^). inclusive.
 * @param length - instead of `to`, number of bytes after `from`
 */
function readRange(storage, _ref) {
  var from = _ref.from,
      to = _ref.to,
      length = _ref.length;

  if (!length && !to || length && to) {
    throw new Error("must specify exactly one `to`|`length`");
  }

  from = (0, _extends3.default)({}, from, {
    offset: from.offset || 0
  });

  if (length) {
    to = {
      slot: from.slot,
      offset: from.offset + Math.floor((from.index + length - 1) / _utils.WORD_SIZE),
      index: (from.index + length - 1) % _utils.WORD_SIZE
    };
  } else {
    to = (0, _extends3.default)({}, to, {
      offset: to.offset || 0
    });
  }

  debug("readRange %o", { from: from, to: to });

  var totalWords = to.offset - from.offset + 1;
  debug("totalWords %o", totalWords);

  var data = new Uint8Array(totalWords * _utils.WORD_SIZE);

  for (var i = 0; i < totalWords; i++) {
    var offset = i + from.offset;
    data.set(read(storage, from.slot, offset), i * _utils.WORD_SIZE);
  }
  debug("words %o", data);

  data = data.slice(from.index, (totalWords - 1) * _utils.WORD_SIZE + to.index + 1);

  debug("data: %o", data);

  return data;
}

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.visit = visit;
exports.doneVisiting = doneVisiting;
var VISIT = exports.VISIT = "VISIT";
function visit(sourceId, ast) {
  return {
    type: VISIT,
    sourceId: sourceId, ast: ast
  };
}

var DONE_VISITING = exports.DONE_VISITING = "DONE_VISITING";
function doneVisiting() {
  return {
    type: DONE_VISITING
  };
}

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _set = __webpack_require__(37);

var _set2 = _interopRequireDefault(_set);

var _defineProperty2 = __webpack_require__(3);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _CONTROL_SAGAS;

exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(14);

var _helpers = __webpack_require__(6);

var _sagas = __webpack_require__(51);

var trace = _interopRequireWildcard(_sagas);

var _actions = __webpack_require__(48);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(109);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _marked = /*#__PURE__*/_regenerator2.default.mark(saga),
    _marked2 = /*#__PURE__*/_regenerator2.default.mark(advance),
    _marked3 = /*#__PURE__*/_regenerator2.default.mark(stepNext),
    _marked4 = /*#__PURE__*/_regenerator2.default.mark(stepInto),
    _marked5 = /*#__PURE__*/_regenerator2.default.mark(stepOut),
    _marked6 = /*#__PURE__*/_regenerator2.default.mark(stepOver),
    _marked7 = /*#__PURE__*/_regenerator2.default.mark(continueUntil);

var debug = (0, _debug2.default)("debugger:controller:sagas");

var CONTROL_SAGAS = (_CONTROL_SAGAS = {}, (0, _defineProperty3.default)(_CONTROL_SAGAS, actions.ADVANCE, advance), (0, _defineProperty3.default)(_CONTROL_SAGAS, actions.STEP_NEXT, stepNext), (0, _defineProperty3.default)(_CONTROL_SAGAS, actions.STEP_OVER, stepOver), (0, _defineProperty3.default)(_CONTROL_SAGAS, actions.STEP_INTO, stepInto), (0, _defineProperty3.default)(_CONTROL_SAGAS, actions.STEP_OUT, stepOut), (0, _defineProperty3.default)(_CONTROL_SAGAS, actions.CONTINUE_UNTIL, continueUntil), _CONTROL_SAGAS);

/** AST node types that are skipped to filter out some noise */
var SKIPPED_TYPES = new _set2.default(["ContractDefinition", "VariableDeclaration"]);

function saga() {
  var action, _saga;

  return _regenerator2.default.wrap(function saga$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (false) {
            _context.next = 13;
            break;
          }

          debug("waiting for control action");
          _context.next = 4;
          return (0, _effects.take)((0, _keys2.default)(CONTROL_SAGAS));

        case 4:
          action = _context.sent;

          debug("got control action");
          _saga = CONTROL_SAGAS[action.type];
          _context.next = 9;
          return (0, _effects.put)(actions.beginStep(action.type));

        case 9:
          _context.next = 11;
          return (0, _effects.race)({
            exec: (0, _effects.call)(_saga, action),
            interrupt: (0, _effects.take)(actions.INTERRUPT)
          });

        case 11:
          _context.next = 0;
          break;

        case 13:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

exports.default = (0, _helpers.prefixName)("controller", saga);

/**
 * Advance the state by one instruction
 */

function advance() {
  return _regenerator2.default.wrap(function advance$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          return _context2.delegateYield(trace.advance(), "t0", 1);

        case 1:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, this);
}

/**
 * stepNext - step to the next logical code segment
 *
 * Note: It might take multiple instructions to express the same section of code.
 * "Stepping", then, is stepping to the next logical item, not stepping to the next
 * instruction. See advance() if you'd like to advance by one instruction.
 */
function stepNext() {
  var startingRange, upcoming;
  return _regenerator2.default.wrap(function stepNext$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return (0, _effects.select)(_selectors2.default.current.location.sourceRange);

        case 2:
          startingRange = _context3.sent;

        case 3:
          return _context3.delegateYield(advance(), "t0", 4);

        case 4:
          _context3.next = 6;
          return (0, _effects.select)(_selectors2.default.current.location);

        case 6:
          upcoming = _context3.sent;

        case 7:
          if (!upcoming.node || SKIPPED_TYPES.has(upcoming.node.nodeType) || upcoming.sourceRange.start == startingRange.start && upcoming.sourceRange.length == startingRange.length) {
            _context3.next = 3;
            break;
          }

        case 8:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3, this);
}

/**
 * stepInto - step into the current function
 *
 * Conceptually this is easy, but from a programming standpoint it's hard.
 * Code like `getBalance(msg.sender)` might be highlighted, but there could
 * be a number of different intermediate steps (like evaluating `msg.sender`)
 * before `getBalance` is stepped into. This function will step into the first
 * function available (where instruction.jump == "i"), ignoring any intermediate
 * steps that fall within the same code range. If there's a step encountered
 * that exists outside of the range, then stepInto will only execute until that
 * step.
 */
function stepInto() {
  var startingDepth, startingRange, currentDepth, currentRange;
  return _regenerator2.default.wrap(function stepInto$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return (0, _effects.select)(_selectors2.default.current.willJump);

        case 2:
          if (!_context4.sent) {
            _context4.next = 5;
            break;
          }

          return _context4.delegateYield(stepNext(), "t0", 4);

        case 4:
          return _context4.abrupt("return");

        case 5:
          _context4.next = 7;
          return (0, _effects.select)(_selectors2.default.current.location.isMultiline);

        case 7:
          if (!_context4.sent) {
            _context4.next = 10;
            break;
          }

          return _context4.delegateYield(stepOver(), "t1", 9);

        case 9:
          return _context4.abrupt("return");

        case 10:
          _context4.next = 12;
          return (0, _effects.select)(_selectors2.default.current.functionDepth);

        case 12:
          startingDepth = _context4.sent;
          _context4.next = 15;
          return (0, _effects.select)(_selectors2.default.current.location.sourceRange);

        case 15:
          startingRange = _context4.sent;

        case 16:
          return _context4.delegateYield(stepNext(), "t2", 17);

        case 17:
          _context4.next = 19;
          return (0, _effects.select)(_selectors2.default.current.functionDepth);

        case 19:
          currentDepth = _context4.sent;
          _context4.next = 22;
          return (0, _effects.select)(_selectors2.default.current.location.sourceRange);

        case 22:
          currentRange = _context4.sent;

        case 23:
          if (
          // the function stack has not increased,
          currentDepth <= startingDepth &&

          // the current source range begins on or after the starting range
          currentRange.start >= startingRange.start &&

          // and the current range ends on or before the starting range ends
          currentRange.start + currentRange.length <= startingRange.start + startingRange.length) {
            _context4.next = 16;
            break;
          }

        case 24:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, this);
}

/**
 * Step out of the current function
 *
 * This will run until the debugger encounters a decrease in function depth.
 */
function stepOut() {
  var startingDepth, currentDepth;
  return _regenerator2.default.wrap(function stepOut$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return (0, _effects.select)(_selectors2.default.current.location.isMultiline);

        case 2:
          if (!_context5.sent) {
            _context5.next = 5;
            break;
          }

          return _context5.delegateYield(stepOver(), "t0", 4);

        case 4:
          return _context5.abrupt("return");

        case 5:
          _context5.next = 7;
          return (0, _effects.select)(_selectors2.default.current.functionDepth);

        case 7:
          startingDepth = _context5.sent;

        case 8:
          return _context5.delegateYield(stepNext(), "t1", 9);

        case 9:
          _context5.next = 11;
          return (0, _effects.select)(_selectors2.default.current.functionDepth);

        case 11:
          currentDepth = _context5.sent;

        case 12:
          if (currentDepth >= startingDepth) {
            _context5.next = 8;
            break;
          }

        case 13:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5, this);
}

/**
 * stepOver - step over the current line
 *
 * Step over the current line. This will step to the next instruction that
 * exists on a different line of code within the same function depth.
 */
function stepOver() {
  var startingDepth, startingRange, currentDepth, currentRange;
  return _regenerator2.default.wrap(function stepOver$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _context6.next = 2;
          return (0, _effects.select)(_selectors2.default.current.functionDepth);

        case 2:
          startingDepth = _context6.sent;
          _context6.next = 5;
          return (0, _effects.select)(_selectors2.default.current.location.sourceRange);

        case 5:
          startingRange = _context6.sent;

        case 6:
          return _context6.delegateYield(stepNext(), "t0", 7);

        case 7:
          _context6.next = 9;
          return (0, _effects.select)(_selectors2.default.current.functionDepth);

        case 9:
          currentDepth = _context6.sent;
          _context6.next = 12;
          return (0, _effects.select)(_selectors2.default.current.location.sourceRange);

        case 12:
          currentRange = _context6.sent;

        case 13:
          if (
          // keep stepping provided:
          //
          // we haven't jumped out
          !(currentDepth < startingDepth) && (

          // either: function depth is greater than starting (ignore function calls)
          // or, if we're at the same depth, keep stepping until we're on a new
          // line.
          currentDepth > startingDepth || currentRange.lines.start.line == startingRange.lines.start.line)) {
            _context6.next = 6;
            break;
          }

        case 14:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6, this);
}

/**
 * continueUntil - step through execution until a breakpoint
 *
 * @param breakpoints - array of breakpoints ({ ...call, line })
 */
function continueUntil(_ref) {
  var breakpoints = _ref.breakpoints;
  var currentCall, currentLocation, breakpointHit;
  return _regenerator2.default.wrap(function continueUntil$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          breakpointHit = false;

        case 1:
          return _context7.delegateYield(stepNext(), "t0", 2);

        case 2:
          _context7.next = 4;
          return (0, _effects.select)(_selectors2.default.current.executionContext);

        case 4:
          currentCall = _context7.sent;
          _context7.next = 7;
          return (0, _effects.select)(_selectors2.default.current.location);

        case 7:
          currentLocation = _context7.sent;

          breakpointHit = breakpoints.filter(function (_ref2) {
            var address = _ref2.address,
                binary = _ref2.binary,
                line = _ref2.line,
                node = _ref2.node;
            return (address == currentCall.address || binary == currentCall.binary) && (line == currentLocation.sourceRange.lines.start.line || node == currentLocation.node.id);
          }).length > 0;

        case 9:
          if (!breakpointHit) {
            _context7.next = 1;
            break;
          }

        case 10:
        case "end":
          return _context7.stop();
      }
    }
  }, _marked7, this);
}

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(12);

var _selectors = __webpack_require__(7);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(9);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(21);

var _selectors6 = _interopRequireDefault(_selectors5);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger:controller:sagas");

/**
 * @private
 */
var identity = function identity(x) {
  return x;
};

/**
 * controller
 */
var controller = (0, _reselectTree.createSelectorTree)({

  /**
   * controller.current
   */
  current: {
    /**
     * controller.current.functionDepth
     */
    functionDepth: (0, _reselectTree.createLeaf)([_selectors4.default.current.functionDepth], identity),

    /**
     * controller.current.executionContext
     */
    executionContext: (0, _reselectTree.createLeaf)([_selectors2.default.current.call], identity),

    /**
     * controller.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], identity),

    /**
     * controller.current.location
     */
    location: {
      /**
       * controller.current.location.sourceRange
       */
      sourceRange: (0, _reselectTree.createLeaf)([_selectors4.default.current.sourceRange], identity),

      /**
       * controller.current.location.node
       */
      node: (0, _reselectTree.createLeaf)([_selectors6.default.current.node], identity),

      /**
       * controller.current.location.isMultiline
       */
      isMultiline: (0, _reselectTree.createLeaf)([_selectors4.default.current.isMultiline], identity)
    }
  }
});

exports.default = controller;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

exports.addSource = addSource;
exports.addSourceMap = addSourceMap;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(14);

var _helpers = __webpack_require__(6);

var _actions = __webpack_require__(52);

var actions = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(28);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _marked = /*#__PURE__*/_regenerator2.default.mark(addSource),
    _marked2 = /*#__PURE__*/_regenerator2.default.mark(addSourceMap),
    _marked3 = /*#__PURE__*/_regenerator2.default.mark(functionDepthSaga),
    _marked4 = /*#__PURE__*/_regenerator2.default.mark(saga);

var debug = (0, _debug2.default)("debugger:solidity:sagas");

function addSource(source, sourcePath, ast) {
  return _regenerator2.default.wrap(function addSource$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return (0, _effects.put)(actions.addSource(source, sourcePath, ast));

        case 2:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

function addSourceMap(binary, sourceMap) {
  return _regenerator2.default.wrap(function addSourceMap$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return (0, _effects.put)(actions.addSourceMap(binary, sourceMap));

        case 2:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, this);
}

function functionDepthSaga() {
  var instruction, jumpDirection;
  return _regenerator2.default.wrap(function functionDepthSaga$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          if (false) {
            _context3.next = 18;
            break;
          }

          _context3.next = 3;
          return (0, _effects.take)(_actions2.TICK);

        case 3:
          debug("got TICK");
          _context3.next = 6;
          return (0, _effects.select)(_selectors2.default.current.instruction);

        case 6:
          instruction = _context3.sent;

          debug("instruction: %o", instruction);

          _context3.next = 10;
          return (0, _effects.select)(_selectors2.default.current.willJump);

        case 10:
          if (!_context3.sent) {
            _context3.next = 16;
            break;
          }

          _context3.next = 13;
          return (0, _effects.select)(_selectors2.default.current.jumpDirection);

        case 13:
          jumpDirection = _context3.sent;
          _context3.next = 16;
          return (0, _effects.put)(actions.jump(jumpDirection));

        case 16:
          _context3.next = 0;
          break;

        case 18:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3, this);
}

function saga() {
  return _regenerator2.default.wrap(function saga$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return (0, _effects.call)(functionDepthSaga);

        case 2:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, this);
}

exports.default = (0, _helpers.prefixName)("solidity", saga);

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

exports.addContext = addContext;
exports.addInstance = addInstance;
exports.begin = begin;
exports.callstackSaga = callstackSaga;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(14);

var _helpers = __webpack_require__(6);

var _actions = __webpack_require__(28);

var _actions2 = __webpack_require__(53);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(7);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _marked = /*#__PURE__*/_regenerator2.default.mark(addContext),
    _marked2 = /*#__PURE__*/_regenerator2.default.mark(addInstance),
    _marked3 = /*#__PURE__*/_regenerator2.default.mark(begin),
    _marked4 = /*#__PURE__*/_regenerator2.default.mark(callstackSaga),
    _marked5 = /*#__PURE__*/_regenerator2.default.mark(saga);

var debug = (0, _debug2.default)("debugger:evm:sagas");

/**
 * Adds EVM bytecode context
 *
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function addContext(contractName, binary) {
  return _regenerator2.default.wrap(function addContext$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return (0, _effects.put)(actions.addContext(contractName, binary));

        case 2:
          return _context.abrupt("return", (0, _helpers.keccak256)(binary));

        case 3:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

/**
 * Adds known deployed instance of binary at address
 *
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function addInstance(address, binary) {
  var search, _search, context;

  return _regenerator2.default.wrap(function addInstance$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return (0, _effects.select)(_selectors2.default.info.binaries.search);

        case 2:
          search = _context2.sent;
          _search = search(binary), context = _search.context;
          _context2.next = 6;
          return (0, _effects.put)(actions.addInstance(address, context, binary));

        case 6:
          return _context2.abrupt("return", context);

        case 7:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, this);
}

function begin(_ref) {
  var address = _ref.address,
      binary = _ref.binary;
  return _regenerator2.default.wrap(function begin$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          if (!address) {
            _context3.next = 5;
            break;
          }

          _context3.next = 3;
          return (0, _effects.put)(actions.call(address));

        case 3:
          _context3.next = 7;
          break;

        case 5:
          _context3.next = 7;
          return (0, _effects.put)(actions.create(binary));

        case 7:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3, this);
}

function callstackSaga() {
  var address, binary;
  return _regenerator2.default.wrap(function callstackSaga$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          if (false) {
            _context4.next = 34;
            break;
          }

          _context4.next = 3;
          return (0, _effects.take)(_actions.TICK);

        case 3:
          debug("got TICK");

          _context4.next = 6;
          return (0, _effects.select)(_selectors2.default.current.step.isCall);

        case 6:
          if (!_context4.sent) {
            _context4.next = 15;
            break;
          }

          debug("got call");
          _context4.next = 10;
          return (0, _effects.select)(_selectors2.default.current.step.callAddress);

        case 10:
          address = _context4.sent;
          _context4.next = 13;
          return (0, _effects.put)(actions.call(address));

        case 13:
          _context4.next = 32;
          break;

        case 15:
          _context4.next = 17;
          return (0, _effects.select)(_selectors2.default.current.step.isCreate);

        case 17:
          if (!_context4.sent) {
            _context4.next = 26;
            break;
          }

          debug("got create");
          _context4.next = 21;
          return (0, _effects.select)(_selectors2.default.current.step.createBinary);

        case 21:
          binary = _context4.sent;
          _context4.next = 24;
          return (0, _effects.put)(actions.create(binary));

        case 24:
          _context4.next = 32;
          break;

        case 26:
          _context4.next = 28;
          return (0, _effects.select)(_selectors2.default.current.step.isHalting);

        case 28:
          if (!_context4.sent) {
            _context4.next = 32;
            break;
          }

          debug("got return");
          _context4.next = 32;
          return (0, _effects.put)(actions.returnCall());

        case 32:
          _context4.next = 0;
          break;

        case 34:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, this);
}

function saga() {
  return _regenerator2.default.wrap(function saga$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return (0, _effects.call)(callstackSaga);

        case 2:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5, this);
}

exports.default = (0, _helpers.prefixName)("evm", saga);

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

exports.inspectTransaction = inspectTransaction;
exports.obtainBinaries = obtainBinaries;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(14);

var _helpers = __webpack_require__(6);

var _actions = __webpack_require__(113);

var actions = _interopRequireWildcard(_actions);

var _adapter = __webpack_require__(114);

var _adapter2 = _interopRequireDefault(_adapter);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _marked = /*#__PURE__*/_regenerator2.default.mark(fetchTransactionInfo),
    _marked2 = /*#__PURE__*/_regenerator2.default.mark(fetchBinary),
    _marked3 = /*#__PURE__*/_regenerator2.default.mark(inspectTransaction),
    _marked4 = /*#__PURE__*/_regenerator2.default.mark(obtainBinaries),
    _marked5 = /*#__PURE__*/_regenerator2.default.mark(receiveBinary),
    _marked6 = /*#__PURE__*/_regenerator2.default.mark(saga);

var debug = (0, _debug2.default)("debugger:web3:sagas");

function fetchTransactionInfo(adapter, _ref) {
  var txHash = _ref.txHash;
  var trace, tx, receipt;
  return _regenerator2.default.wrap(function fetchTransactionInfo$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          debug("inspecting transaction");
          _context.prev = 1;
          _context.next = 4;
          return (0, _effects.apply)(adapter, adapter.getTrace, [txHash]);

        case 4:
          trace = _context.sent;
          _context.next = 13;
          break;

        case 7:
          _context.prev = 7;
          _context.t0 = _context["catch"](1);

          debug("putting error");
          _context.next = 12;
          return (0, _effects.put)(actions.error(_context.t0));

        case 12:
          return _context.abrupt("return");

        case 13:

          debug("got trace");
          _context.next = 16;
          return (0, _effects.put)(actions.receiveTrace(trace));

        case 16:
          _context.next = 18;
          return (0, _effects.apply)(adapter, adapter.getTransaction, [txHash]);

        case 18:
          tx = _context.sent;

          if (!(tx.to && tx.to != "0x0")) {
            _context.next = 23;
            break;
          }

          _context.next = 22;
          return (0, _effects.put)(actions.receiveCall({ address: tx.to }));

        case 22:
          return _context.abrupt("return");

        case 23:
          _context.next = 25;
          return (0, _effects.apply)(adapter, adapter.getReceipt, [txHash]);

        case 25:
          receipt = _context.sent;

          if (!receipt.contractAddress) {
            _context.next = 30;
            break;
          }

          _context.next = 29;
          return (0, _effects.put)(actions.receiveCall({ binary: tx.input }));

        case 29:
          return _context.abrupt("return");

        case 30:
          throw new Error("Could not find contract associated with transaction. " + "Please make sure you're debugging a transaction that executes a " + "contract function or creates a new contract.");

        case 31:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this, [[1, 7]]);
}

function fetchBinary(adapter, _ref2) {
  var address = _ref2.address;
  var binary;
  return _regenerator2.default.wrap(function fetchBinary$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          debug("fetching binary for %s", address);
          _context2.next = 3;
          return (0, _effects.apply)(adapter, adapter.getDeployedCode, [address]);

        case 3:
          binary = _context2.sent;

          debug("received binary for %s", address);
          _context2.next = 7;
          return (0, _effects.put)(actions.receiveBinary(address, binary));

        case 7:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, this);
}

function inspectTransaction(txHash, provider) {
  var action, trace, _ref4, address, binary;

  return _regenerator2.default.wrap(function inspectTransaction$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return (0, _effects.put)(actions.init(provider));

        case 2:
          _context3.next = 4;
          return (0, _effects.put)(actions.inspect(txHash));

        case 4:
          _context3.next = 6;
          return (0, _effects.take)(function (_ref3) {
            var type = _ref3.type;
            return type == actions.RECEIVE_TRACE || type == actions.ERROR_WEB3;
          });

        case 6:
          action = _context3.sent;

          debug("action %o", action);

          if (!(action.type == actions.RECEIVE_TRACE)) {
            _context3.next = 13;
            break;
          }

          trace = action.trace;
          debug("received trace");
          _context3.next = 14;
          break;

        case 13:
          return _context3.abrupt("return", { error: action.error });

        case 14:
          _context3.next = 16;
          return (0, _effects.take)(actions.RECEIVE_CALL);

        case 16:
          _ref4 = _context3.sent;
          address = _ref4.address;
          binary = _ref4.binary;

          debug("received call");

          return _context3.abrupt("return", { trace: trace, address: address, binary: binary });

        case 21:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3, this);
}

function obtainBinaries(addresses) {
  var tasks, binaries;
  return _regenerator2.default.wrap(function obtainBinaries$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return (0, _effects.all)(addresses.map(function (address) {
            return (0, _effects.fork)(receiveBinary, address);
          }));

        case 2:
          tasks = _context4.sent;

          debug("requesting binaries");
          _context4.next = 6;
          return (0, _effects.all)(addresses.map(function (address) {
            return (0, _effects.put)(actions.fetchBinary(address));
          }));

        case 6:
          binaries = [];
          _context4.next = 9;
          return (0, _effects.all)(tasks.map(function (task) {
            return (0, _effects.join)(task);
          }));

        case 9:
          binaries = _context4.sent;

          debug("binaries %o", binaries);

          return _context4.abrupt("return", binaries);

        case 12:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, this);
}

function receiveBinary(address) {
  var _ref5, binary;

  return _regenerator2.default.wrap(function receiveBinary$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return (0, _effects.take)(function (action) {
            return action.type == actions.RECEIVE_BINARY && action.address == address;
          });

        case 2:
          _ref5 = _context5.sent;
          binary = _ref5.binary;

          debug("got binary for %s", address);

          return _context5.abrupt("return", binary);

        case 6:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5, this);
}

function saga() {
  var _ref6, provider, adapter;

  return _regenerator2.default.wrap(function saga$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _context6.next = 2;
          return (0, _effects.take)(actions.INIT_WEB3);

        case 2:
          _ref6 = _context6.sent;
          provider = _ref6.provider;
          adapter = new _adapter2.default(provider);
          _context6.next = 7;
          return (0, _effects.takeEvery)(actions.INSPECT, fetchTransactionInfo, adapter);

        case 7:
          _context6.next = 9;
          return (0, _effects.takeEvery)(actions.FETCH_BINARY, fetchBinary, adapter);

        case 9:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6, this);
}

exports.default = (0, _helpers.prefixName)("web3", saga);

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports.inspect = inspect;
exports.fetchBinary = fetchBinary;
exports.receiveBinary = receiveBinary;
exports.receiveTrace = receiveTrace;
exports.receiveCall = receiveCall;
exports.error = error;
var INIT_WEB3 = exports.INIT_WEB3 = "INIT_WEB3";
function init(provider) {
  return {
    type: INIT_WEB3,
    provider: provider
  };
}

var INSPECT = exports.INSPECT = "INSPECT_TRANSACTION";
function inspect(txHash) {
  return {
    type: INSPECT,
    txHash: txHash
  };
}

var FETCH_BINARY = exports.FETCH_BINARY = "FETCH_BINARY";
function fetchBinary(address) {
  return {
    type: FETCH_BINARY,
    address: address
  };
}

var RECEIVE_BINARY = exports.RECEIVE_BINARY = "RECEIVE_BINARY";
function receiveBinary(address, binary) {
  return {
    type: RECEIVE_BINARY,
    address: address, binary: binary
  };
}

var RECEIVE_TRACE = exports.RECEIVE_TRACE = "RECEIVE_TRACE";
function receiveTrace(trace) {
  return {
    type: RECEIVE_TRACE,
    trace: trace
  };
}

var RECEIVE_CALL = exports.RECEIVE_CALL = "RECEIVE_CALL";
function receiveCall(_ref) {
  var address = _ref.address,
      binary = _ref.binary;

  return {
    type: RECEIVE_CALL,
    address: address, binary: binary
  };
}

var ERROR_WEB3 = exports.ERROR_WEB3 = "ERROR_WEB3";
function error(error) {
  return {
    type: ERROR_WEB3,
    error: error
  };
}

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = __webpack_require__(31);

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = __webpack_require__(10);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(32);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(33);

var _createClass3 = _interopRequireDefault(_createClass2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _web = __webpack_require__(11);

var _web2 = _interopRequireDefault(_web);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger:web3:adapter");

var Web3Adapter = function () {
  function Web3Adapter(provider) {
    (0, _classCallCheck3.default)(this, Web3Adapter);

    this.web3 = new _web2.default(provider);
  }

  (0, _createClass3.default)(Web3Adapter, [{
    key: "getTrace",
    value: function () {
      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(txHash) {
        var _this = this;

        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new _promise2.default(function (accept, reject) {
                  _this.web3.currentProvider.sendAsync({
                    jsonrpc: "2.0",
                    method: "debug_traceTransaction",
                    params: [txHash, {}],
                    id: new Date().getTime()
                  }, function (err, result) {
                    if (err) return reject(err);
                    if (result.error) return reject(new Error(result.error.message));
                    debug("result: %o", result);
                    accept(result.result.structLogs);
                  });
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getTrace(_x) {
        return _ref.apply(this, arguments);
      }

      return getTrace;
    }()
  }, {
    key: "getTransaction",
    value: function () {
      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(txHash) {
        var _this2 = this;

        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", new _promise2.default(function (accept, reject) {
                  _this2.web3.eth.getTransaction(txHash, function (err, tx) {
                    if (err) return reject(err);

                    return accept(tx);
                  });
                }));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getTransaction(_x2) {
        return _ref2.apply(this, arguments);
      }

      return getTransaction;
    }()
  }, {
    key: "getReceipt",
    value: function () {
      var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(txHash) {
        var _this3 = this;

        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", new _promise2.default(function (accept, reject) {
                  _this3.web3.eth.getTransactionReceipt(txHash, function (err, receipt) {
                    if (err) return reject(err);

                    return accept(receipt);
                  });
                }));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getReceipt(_x3) {
        return _ref3.apply(this, arguments);
      }

      return getReceipt;
    }()
  }, {
    key: "getDeployedCode",

    /**
     * getDeployedCode - get the deployed code for an address from the client
     * @param  {String} address
     * @return {String}         deployedBinary
     */
    value: function () {
      var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(address) {
        var _this4 = this;

        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                debug("getting deployed code for %s", address);
                return _context4.abrupt("return", new _promise2.default(function (accept, reject) {
                  _this4.web3.eth.getCode(address, function (err, deployedBinary) {
                    if (err) debug("error: %o", err);
                    if (err) return reject(err);
                    debug("got deployed code for %s", address);
                    accept(deployedBinary);
                  });
                }));

              case 2:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getDeployedCode(_x4) {
        return _ref4.apply(this, arguments);
      }

      return getDeployedCode;
    }()
  }]);
  return Web3Adapter;
}();

exports.default = Web3Adapter;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FINISHED = exports.ERROR = exports.ACTIVE = exports.WAITING = undefined;
exports.session = session;

var _redux = __webpack_require__(22);

var _reducers = __webpack_require__(116);

var _reducers2 = _interopRequireDefault(_reducers);

var _reducers3 = __webpack_require__(117);

var _reducers4 = _interopRequireDefault(_reducers3);

var _reducers5 = __webpack_require__(119);

var _reducers6 = _interopRequireDefault(_reducers5);

var _reducers7 = __webpack_require__(120);

var _reducers8 = _interopRequireDefault(_reducers7);

var _actions = __webpack_require__(35);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var WAITING = exports.WAITING = "WAITING";
var ACTIVE = exports.ACTIVE = "ACTIVE";
var ERROR = exports.ERROR = "ERROR";
var FINISHED = exports.FINISHED = "FINISHED";

function session() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : WAITING;
  var action = arguments[1];

  switch (action.type) {
    case actions.READY:
      return ACTIVE;

    case actions.ERROR:
      return { error: action.error };

    case actions.FINISH:
      return FINISHED;

    default:
      return state;
  }
}

var reduceState = (0, _redux.combineReducers)({
  session: session,
  data: _reducers2.default,
  evm: _reducers4.default,
  solidity: _reducers6.default,
  trace: _reducers8.default
});

exports.default = reduceState;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __webpack_require__(4);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = __webpack_require__(5);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _toConsumableArray2 = __webpack_require__(2);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _defineProperty2 = __webpack_require__(3);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _extends4 = __webpack_require__(13);

var _extends5 = _interopRequireDefault(_extends4);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(22);

var _actions = __webpack_require__(50);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var debug = (0, _debug2.default)("debugger:data:reducers");

var DEFAULT_SCOPES = {
  byId: {}
};

function scopes() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_SCOPES;
  var action = arguments[1];

  var context;
  var scope;
  var variables;

  switch (action.type) {
    case actions.SCOPE:
      scope = state.byId[action.id] || {};

      return {
        byId: (0, _extends5.default)({}, state.byId, (0, _defineProperty3.default)({}, action.id, (0, _extends5.default)({}, scope, {

          id: action.id,
          sourceId: action.sourceId,
          parentId: action.parentId,
          pointer: action.pointer
        })))
      };

    case actions.DECLARE:
      scope = state.byId[action.node.scope] || {};
      variables = scope.variables || [];

      return {
        byId: (0, _extends5.default)({}, state.byId, (0, _defineProperty3.default)({}, action.node.scope, (0, _extends5.default)({}, scope, {

          variables: [].concat((0, _toConsumableArray3.default)(variables), [{ name: action.node.name, id: action.node.id }])
        })))
      };

    default:
      return state;
  }
}

var info = (0, _redux.combineReducers)({
  scopes: scopes
});

var DEFAULT_ASSIGNMENTS = {
  byId: {}
};

function assignments() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_ASSIGNMENTS;
  var action = arguments[1];

  switch (action.type) {
    case actions.ASSIGN:
      return {
        byId: (0, _extends5.default)({}, state.byId, _assign2.default.apply(Object, [{}].concat((0, _toConsumableArray3.default)((0, _entries2.default)(action.assignments).map(function (_ref) {
          var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
              id = _ref2[0],
              ref = _ref2[1];

          return (0, _defineProperty3.default)({}, id, (0, _extends5.default)({}, state.byId[id], {
            ref: ref
          }));
        })))))
      };

    default:
      return state;
  }
};

var proc = (0, _redux.combineReducers)({
  assignments: assignments
});

var reducer = (0, _redux.combineReducers)({
  info: info,
  proc: proc
});

exports.default = reducer;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(37);

var _set2 = _interopRequireDefault(_set);

var _from = __webpack_require__(118);

var _from2 = _interopRequireDefault(_from);

var _defineProperty2 = __webpack_require__(3);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _extends6 = __webpack_require__(13);

var _extends7 = _interopRequireDefault(_extends6);

exports.callstack = callstack;

var _redux = __webpack_require__(22);

var _actions = __webpack_require__(53);

var actions = _interopRequireWildcard(_actions);

var _helpers = __webpack_require__(6);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var DEFAULT_CONTEXTS = {
  byContext: {},
  byBinary: {}
};

function contexts() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_CONTEXTS;
  var action = arguments[1];

  switch (action.type) {
    /*
     * Adding a new context
     */
    case actions.ADD_CONTEXT:
      var contractName = action.contractName,
          binary = action.binary;

      if (state.byBinary[binary]) {
        return state;
      }

      var context = (0, _helpers.keccak256)(binary);

      return {
        byContext: (0, _extends7.default)({}, state.byContext, (0, _defineProperty3.default)({}, context, { context: context, binary: binary, contractName: contractName })),

        byBinary: (0, _extends7.default)({}, state.byBinary, (0, _defineProperty3.default)({}, binary, { context: context }))
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

var DEFAULT_INSTANCES = {
  byAddress: {},
  byContext: {}
};

function instances() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_INSTANCES;
  var action = arguments[1];

  switch (action.type) {
    /*
     * Adding a new address for context
     */
    case actions.ADD_INSTANCE:
      var address = action.address,
          context = action.context,
          binary = action.binary;

      // get known addresses for this context

      var otherInstances = state.byContext[context] || [];
      var otherAddresses = otherInstances.map(function (_ref) {
        var address = _ref.address;
        return address;
      });

      return {
        byAddress: (0, _extends7.default)({}, state.byAddress, (0, _defineProperty3.default)({}, address, { context: context, binary: binary })),

        byContext: (0, _extends7.default)({}, state.byContext, (0, _defineProperty3.default)({}, context, (0, _from2.default)(new _set2.default(otherAddresses).add(address)).map(function (address) {
          return { address: address };
        })))
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

var info = (0, _redux.combineReducers)({
  contexts: contexts,
  instances: instances
});

function callstack() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var action = arguments[1];

  switch (action.type) {
    case actions.CALL:
      var address = action.address;
      return state.concat([{ address: address }]);

    case actions.CREATE:
      var binary = action.binary;
      return state.concat([{ binary: binary }]);

    case actions.RETURN:
      return state.slice(0, -1); // pop

    default:
      return state;
  };
}

var proc = (0, _redux.combineReducers)({
  callstack: callstack
});

var reducer = (0, _redux.combineReducers)({
  info: info,
  proc: proc
});

exports.default = reducer;

/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/array/from");

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(3);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _extends4 = __webpack_require__(13);

var _extends5 = _interopRequireDefault(_extends4);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

exports.functionDepth = functionDepth;

var _redux = __webpack_require__(22);

var _helpers = __webpack_require__(6);

var _actions = __webpack_require__(52);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var DEFAULT_SOURCES = {
  byId: {}
};

function sources() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_SOURCES;
  var action = arguments[1];

  switch (action.type) {
    /*
     * Adding a new source
     */
    case actions.ADD_SOURCE:
      var ast = action.ast,
          source = action.source,
          sourcePath = action.sourcePath;

      var id = (0, _keys2.default)(state.byId).length;

      return {
        byId: (0, _extends5.default)({}, state.byId, (0, _defineProperty3.default)({}, id, {
          id: id,
          ast: ast,
          source: source,
          sourcePath: sourcePath
        }))

        /*
         * Default case
         */
      };default:
      return state;
  }
}

var DEFAULT_SOURCEMAPS = {
  byContext: {}
};

function sourceMaps() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_SOURCEMAPS;
  var action = arguments[1];

  switch (action.type) {
    /*
     * Adding a new sourceMap
     */
    case actions.ADD_SOURCEMAP:
      var binary = action.binary,
          sourceMap = action.sourceMap;

      var context = (0, _helpers.keccak256)(binary);

      return {
        byContext: (0, _extends5.default)({}, state.byContext, (0, _defineProperty3.default)({}, context, {
          context: context,
          sourceMap: sourceMap
        }))
      };

    /*
     * Default Case
     */
    default:
      return state;
  }
}

var info = (0, _redux.combineReducers)({
  sources: sources,
  sourceMaps: sourceMaps
});

function functionDepth() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  var action = arguments[1];

  if (action.type === actions.JUMP) {
    var delta = spelunk(action.jumpDirection);
    return state + delta;
  } else {
    return state;
  }
}

function spelunk(jump) {
  if (jump == "i") {
    return 1;
  } else if (jump == "o") {
    return -1;
  } else {
    return 0;
  }
}

var proc = (0, _redux.combineReducers)({
  functionDepth: functionDepth
});

var reducer = (0, _redux.combineReducers)({
  info: info,
  proc: proc
});

exports.default = reducer;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.index = index;
exports.steps = steps;

var _redux = __webpack_require__(22);

var _actions = __webpack_require__(28);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function index() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var action = arguments[1];

  if (action.type == actions.TOCK || action.type == actions.END_OF_TRACE) {
    return state + 1;
  } else {
    return state;
  }
}

function steps() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var action = arguments[1];

  if (action.type == actions.SAVE_STEPS) {
    return action.steps;
  } else {
    return state;
  }
}

var info = (0, _redux.combineReducers)({
  steps: steps
});

var proc = (0, _redux.combineReducers)({
  index: index
});

var reducer = (0, _redux.combineReducers)({
  info: info,
  proc: proc
});

exports.default = reducer;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(10);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _chai = __webpack_require__(18);

var _ganacheCli = __webpack_require__(23);

var _ganacheCli2 = _interopRequireDefault(_ganacheCli);

var _web = __webpack_require__(11);

var _web2 = _interopRequireDefault(_web);

var _helpers = __webpack_require__(20);

var _debugger = __webpack_require__(25);

var _debugger2 = _interopRequireDefault(_debugger);

var _selectors = __webpack_require__(54);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(26);

var _selectors4 = _interopRequireDefault(_selectors3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)("test:context");

var __OUTER = "\npragma solidity ^0.4.18;\n\nimport \"./InnerContract.sol\";\n\ncontract OuterContract {\n  event Outer();\n\n  InnerContract inner;\n\n  function OuterContract(address _inner) public {\n    inner = InnerContract(_inner);\n  }\n\n  function run() public {\n    inner.run();\n\n    Outer();\n  }\n}\n";

var __INNER = "\npragma solidity ^0.4.18;\n\ncontract InnerContract {\n  event Inner();\n\n  function run() public {\n    Inner();\n  }\n}\n";

var __MIGRATION = "\nlet OuterContract = artifacts.require(\"OuterContract\");\nlet InnerContract = artifacts.require(\"InnerContract\");\n\nmodule.exports = function(deployer) {\n  return deployer\n    .then(function() {\n      return deployer.deploy(InnerContract);\n    })\n    .then(function() {\n      return InnerContract.deployed();\n    })\n    .then(function(inner) {\n      return deployer.deploy(OuterContract, inner.address);\n    });\n};\n";

var migrations = {
  "2_deploy_contracts.js": __MIGRATION
};

var sources = {
  "OuterLibrary.sol": __OUTER,
  "InnerContract.sol": __INNER
};

describe("Contexts", function () {
  var provider;
  var web3;

  var abstractions;
  var artifacts;

  before("Create Provider", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            provider = _ganacheCli2.default.provider({ seed: "debugger", gasLimit: 7000000 });
            web3 = new _web2.default(provider);

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  })));

  before("Prepare contracts and artifacts", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
    var prepared;
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            this.timeout(30000);

            _context2.next = 3;
            return (0, _helpers.prepareContracts)(provider, sources, migrations);

          case 3:
            prepared = _context2.sent;

            abstractions = prepared.abstractions;
            artifacts = prepared.artifacts;

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  })));

  it("returns view of addresses affected", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
    var outer, inner, result, txHash, bugger, session, affectedInstances, affectedAddresses;
    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return abstractions.OuterContract.deployed();

          case 2:
            outer = _context3.sent;
            _context3.next = 5;
            return abstractions.InnerContract.deployed();

          case 5:
            inner = _context3.sent;
            _context3.next = 8;
            return outer.run();

          case 8:
            result = _context3.sent;


            _chai.assert.equal(2, result.receipt.logs.length, "There should be two logs");

            txHash = result.tx;
            _context3.next = 13;
            return _debugger2.default.forTx(txHash, {
              provider: provider,
              contracts: artifacts
            });

          case 13:
            bugger = _context3.sent;

            debug("debugger ready");

            session = bugger.connect();
            affectedInstances = session.view(_selectors2.default.info.affectedInstances);

            debug("affectedInstances: %o", affectedInstances);

            affectedAddresses = (0, _keys2.default)(affectedInstances);


            _chai.assert.equal(2, affectedAddresses.length);

            _chai.assert.include(affectedAddresses, outer.address, "OuterContract should be an affected address");

            _chai.assert.include(affectedAddresses, inner.address, "InnerContract should be an affected address");

          case 22:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  })));
});

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _stringify = __webpack_require__(123);

var _stringify2 = _interopRequireDefault(_stringify);

var _toConsumableArray2 = __webpack_require__(2);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _selectors = __webpack_require__(7);

var _selectors2 = _interopRequireDefault(_selectors);

var _helpers = __webpack_require__(55);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)("test:data:decode");

var uints = (0, _helpers.generateUints)();

function generateArray(length) {
  return [].concat((0, _toConsumableArray3.default)(Array(length))).map(function () {
    return uints.next().value;
  });
}

var fixtures = [{
  name: "multipleFullWordArray",
  type: "uint[]",
  value: generateArray(3) // takes up 3 whole words
}, {
  name: "withinWordArray",
  type: "uint16[]",
  value: generateArray(10) // takes up >1/2 word
}, {
  name: "multiplePartWordArray",
  type: "uint64[]",
  value: generateArray(9) // takes up 2.25 words
}, {
  name: "inconvenientlyWordOffsetArray",
  type: "uint240[]",
  value: generateArray(3) // takes up ~2.8 words
}, {
  name: "shortString",
  type: "string",
  value: "hello world"
}, {
  name: "longString",
  type: "string",
  value: "solidity allocation is a fun lesson in endianness"
}];

describe("Decoding", function () {

  /*
   * Storage Tests
   */
  (0, _helpers.describeDecoding)("Storage Variables", fixtures, _selectors2.default.current.state.storage, function (contractName) {
    return "pragma solidity ^0.4.23;\n\ncontract " + contractName + " {\n\n  event Done();\n\n  // declarations\n  " + fixtures.map(function (_ref) {
      var type = _ref.type,
          name = _ref.name;
      return type + " " + name + ";";
    }).join("\n  ") + "\n\n  function run() public {\n    " + fixtures.map(function (_ref2) {
      var name = _ref2.name,
          value = _ref2.value;
      return name + " = " + (0, _stringify2.default)(value) + ";";
    }).join("\n    ") + "\n\n    emit Done();\n  }\n}\n";
  });

  /*
   * Memory Tests
   */
  (0, _helpers.describeDecoding)("Memory Variables", fixtures, _selectors2.default.current.state.memory, function (contractName) {
    var separator = ";\n    ";

    function declareAssign(_ref3) {
      var name = _ref3.name,
          type = _ref3.type,
          value = _ref3.value;

      if (type.indexOf("[]") != -1) {
        // array, must `new`
        var declare = type + " memory " + name + " = new " + type + "(" + value.length + ")";
        var assigns = value.map(function (k, i) {
          return name + "[" + i + "] = " + k;
        });
        return "" + declare + separator + assigns.join(separator);
      } else {
        return type + " memory " + name + " = " + (0, _stringify2.default)(value);
      }
    }

    return "pragma solidity ^0.4.23;\n\ncontract " + contractName + " {\n\n  event Done();\n\n  function run() public {\n    uint i;\n    // declarations\n    " + fixtures.map(declareAssign).join(separator) + ";\n\n    emit Done();\n  }\n}\n";
  });
});

/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/json/stringify");

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _chai = __webpack_require__(18);

var _bignumber = __webpack_require__(27);

var _utils = __webpack_require__(15);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)("test:data:decode:utils");

describe("Utils", function () {
  describe("toBigNumber()", function () {
    it("returns correct value", function () {
      var bytes = [0xf5, 0xe2, 0xc5, 0x17];
      var expectedValue = new _bignumber.BigNumber("f5e2c517", 16);

      var result = utils.toBigNumber(bytes);

      _chai.assert.equal(result.toString(), expectedValue.toString());
    });
  });

  describe("toSignedBigNumber()", function () {
    it("returns correct negative value", function () {
      var bytes = [0xf5, 0xe2, 0xc5, 0x17]; // starts with 0b1
      var raw = new _bignumber.BigNumber("f5e2c517", 16);
      var bitfipped = new _bignumber.BigNumber(raw.toString(2).replace(/0/g, "x").replace(/1/g, "0").replace(/x/g, "1"), 2);

      var expectedValue = bitfipped.plus(1).negated();

      var result = utils.toSignedBigNumber(bytes);

      _chai.assert.equal(result.toString(), expectedValue.toString());
    });

    it("returns correct positive value", function () {
      var bytes = [0x05, 0xe2, 0xc5, 0x17]; // starts with 0b0
      var raw = new _bignumber.BigNumber("05e2c517", 16);
      var expectedValue = raw;

      var result = utils.toSignedBigNumber(bytes);

      _chai.assert.equal(result.toString(), expectedValue.toString());
    });
  });

  describe("toHexString()", function () {
    it("returns correct representation with full bytes", function () {
      // ie, 0x00 instead of 0x0
      _chai.assert.equal(utils.toHexString([0x05, 0x11]), "0x0511");
      _chai.assert.equal(utils.toHexString([0xff, 0x00, 0xff]), "0xff00ff");
    });

    it("allows removing leading zeroes", function () {
      _chai.assert.equal(utils.toHexString([0x00, 0x00, 0xcc], true), "0xcc");
    });
  });
});

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(10);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _chai = __webpack_require__(18);

var _ganacheCli = __webpack_require__(23);

var _ganacheCli2 = _interopRequireDefault(_ganacheCli);

var _web = __webpack_require__(11);

var _web2 = _interopRequireDefault(_web);

var _helpers = __webpack_require__(20);

var _debugger = __webpack_require__(25);

var _debugger2 = _interopRequireDefault(_debugger);

var _selectors = __webpack_require__(7);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)("test:solidity");

var __OUTER = "\npragma solidity ^0.4.18;\n\nimport \"./Inner.sol\";\n\ncontract Outer {\n  event Called();\n\n  Inner inner;\n\n  function Outer(address _inner) {\n    inner = Inner(_inner);\n  }\n\n  function runSingle() public {\n  }\n\n  function run() public {\n    inner.run();\n  }\n}\n";

var __INNER = "\npragma solidity ^0.4.18;\n\ncontract Inner {\n  function run() public {\n  }\n}\n";

var __MIGRATION = "\nlet Outer = artifacts.require(\"Outer\");\nlet Inner = artifacts.require(\"Inner\");\n\nmodule.exports = function(deployer) {\n  return deployer\n    .then(function() {\n      return deployer.deploy(Inner);\n    })\n    .then(function() {\n      return Inner.deployed();\n    })\n    .then(function(inner) {\n      return deployer.deploy(Outer, inner.address);\n    });\n};\n";

var sources = {
  "Inner.sol": __INNER,
  "Outer.sol": __OUTER
};

var migrations = {
  "2_deploy_contracts.js": __MIGRATION
};

describe("EVM Debugging", function () {
  var provider;
  var web3;

  var abstractions;
  var artifacts;
  var files;

  before("Create Provider", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            provider = _ganacheCli2.default.provider({ seed: "debugger", gasLimit: 7000000 });
            web3 = new _web2.default(provider);

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  })));

  before("Prepare contracts and artifacts", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
    var prepared;
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            this.timeout(30000);

            _context2.next = 3;
            return (0, _helpers.prepareContracts)(provider, sources, migrations);

          case 3:
            prepared = _context2.sent;

            abstractions = prepared.abstractions;
            artifacts = prepared.artifacts;
            files = prepared.files;

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  })));

  describe("Function Depth", function () {
    it("remains at 1 in absence of cross-contract calls", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
      var maxExpected, instance, receipt, txHash, bugger, session, stepped, actual;
      return _regenerator2.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              maxExpected = 1;
              _context3.next = 3;
              return abstractions.Inner.deployed();

            case 3:
              instance = _context3.sent;
              _context3.next = 6;
              return instance.run();

            case 6:
              receipt = _context3.sent;
              txHash = receipt.tx;
              _context3.next = 10;
              return _debugger2.default.forTx(txHash, {
                provider: provider,
                files: files,
                contracts: artifacts
              });

            case 10:
              bugger = _context3.sent;
              session = bugger.connect();
              // session steppers return false when done

              do {
                stepped = session.stepNext();

                actual = session.view(_selectors2.default.current.callstack).length;


                _chai.assert.isAtMost(actual, maxExpected);
              } while (stepped);

            case 13:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    })));

    it("tracks callstack correctly", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
      var instance, receipt, txHash, bugger, session, expectedDepthSequence, actualSequence, stepped, currentDepth, lastKnown;
      return _regenerator2.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return abstractions.Outer.deployed();

            case 2:
              instance = _context4.sent;
              _context4.next = 5;
              return instance.run();

            case 5:
              receipt = _context4.sent;
              txHash = receipt.tx;
              _context4.next = 9;
              return _debugger2.default.forTx(txHash, {
                provider: provider,
                files: files,
                contracts: artifacts
              });

            case 9:
              bugger = _context4.sent;
              session = bugger.connect();

              // follow callstack length values in list
              // see source above

              expectedDepthSequence = [1, 2, 1, 0];
              actualSequence = [session.view(_selectors2.default.current.callstack).length];


              do {
                stepped = session.stepNext();

                currentDepth = session.view(_selectors2.default.current.callstack).length;
                lastKnown = actualSequence[actualSequence.length - 1];


                if (currentDepth !== lastKnown) {
                  actualSequence.push(currentDepth);
                }
              } while (stepped);

              _chai.assert.deepEqual(actualSequence, expectedDepthSequence);

            case 15:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    })));
  });
});

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(10);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _chai = __webpack_require__(18);

var _ganacheCli = __webpack_require__(23);

var _ganacheCli2 = _interopRequireDefault(_ganacheCli);

var _web = __webpack_require__(11);

var _web2 = _interopRequireDefault(_web);

var _helpers = __webpack_require__(20);

var _debugger = __webpack_require__(25);

var _debugger2 = _interopRequireDefault(_debugger);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)("test:solidity");

var __SINGLE_CALL = "\npragma solidity ^0.4.18;\n\ncontract SingleCall {\n  event Called();\n\n  function run() public {\n    Called();\n  }\n}\n";

var __NESTED_CALL = "pragma solidity ^0.4.18;\n\ncontract NestedCall {\n  event First();\n  event Second();\n\n  // run()\n  //   first()    1\n  //     inner()  2\n  //       event  3\n  //              2\n  //   second     1\n  //     event    2\n  //              1\n  function run() public {\n    first();\n    second();\n  }\n\n  function first() public {\n    inner();\n  }\n\n  function inner() public {\n    First();\n  }\n\n  function second() public {\n    Second();\n  }\n\n}\n";

var sources = {
  "SingleCall.sol": __SINGLE_CALL,
  "NestedCall.sol": __NESTED_CALL
};

describe("Solidity Debugging", function () {
  var provider;
  var web3;

  var abstractions;
  var artifacts;
  var files;

  before("Create Provider", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            provider = _ganacheCli2.default.provider({ seed: "debugger", gasLimit: 7000000 });
            web3 = new _web2.default(provider);

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  })));

  before("Prepare contracts and artifacts", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
    var prepared;
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            this.timeout(30000);

            _context2.next = 3;
            return (0, _helpers.prepareContracts)(provider, sources);

          case 3:
            prepared = _context2.sent;

            abstractions = prepared.abstractions;
            artifacts = prepared.artifacts;
            files = prepared.files;

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  })));

  it("exposes functionality to stop at breakpoints", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
    var instance, receipt, txHash, bugger, session, breakpoint, breakpointStopped, range;
    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return abstractions.NestedCall.deployed();

          case 2:
            instance = _context3.sent;
            _context3.next = 5;
            return instance.run();

          case 5:
            receipt = _context3.sent;
            txHash = receipt.tx;
            _context3.next = 9;
            return _debugger2.default.forTx(txHash, {
              provider: provider,
              files: files,
              contracts: artifacts
            });

          case 9:
            bugger = _context3.sent;
            session = bugger.connect();

            // at `second();`

            breakpoint = { "address": instance.address, line: 16 };
            breakpointStopped = false;

          case 13:
            session.continueUntil(breakpoint);

            if (session.finished) {
              _context3.next = 20;
              break;
            }

            _context3.next = 17;
            return session.view(_selectors2.default.current.sourceRange);

          case 17:
            range = _context3.sent;

            _chai.assert.equal(range.lines.start.line, 16);

            breakpointStopped = true;

          case 20:
            if (!session.finished) {
              _context3.next = 13;
              break;
            }

          case 21:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  })));

  describe("Function Depth", function () {
    it("remains at 1 in absence of inner function calls", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
      var maxExpected, instance, receipt, txHash, bugger, session, stepped, actual;
      return _regenerator2.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              maxExpected = 1;
              _context4.next = 3;
              return abstractions.SingleCall.deployed();

            case 3:
              instance = _context4.sent;
              _context4.next = 6;
              return instance.run();

            case 6:
              receipt = _context4.sent;
              txHash = receipt.tx;
              _context4.next = 10;
              return _debugger2.default.forTx(txHash, {
                provider: provider,
                files: files,
                contracts: artifacts
              });

            case 10:
              bugger = _context4.sent;
              session = bugger.connect();
              // session steppers return false when done

              do {
                stepped = session.stepNext();

                actual = session.view(_selectors2.default.current.functionDepth);


                _chai.assert.isAtMost(actual, maxExpected);
              } while (stepped);

            case 13:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    })));

    it("spelunks correctly", (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
      var instance, receipt, txHash, bugger, session, expectedDepthSequence, actualSequence, stepped, currentDepth, lastKnown;
      return _regenerator2.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return abstractions.NestedCall.deployed();

            case 2:
              instance = _context5.sent;
              _context5.next = 5;
              return instance.run();

            case 5:
              receipt = _context5.sent;
              txHash = receipt.tx;
              _context5.next = 9;
              return _debugger2.default.forTx(txHash, {
                provider: provider,
                files: files,
                contracts: artifacts
              });

            case 9:
              bugger = _context5.sent;
              session = bugger.connect();

              // follow functionDepth values in list
              // see source above

              expectedDepthSequence = [1, 2, 3, 2, 1, 2, 1, 0];
              actualSequence = [session.view(_selectors2.default.current.functionDepth)];


              do {
                stepped = session.stepNext();

                currentDepth = session.view(_selectors2.default.current.functionDepth);
                lastKnown = actualSequence[actualSequence.length - 1];


                if (currentDepth !== lastKnown) {
                  actualSequence.push(currentDepth);
                }
              } while (stepped);

              _chai.assert.deepEqual(actualSequence, expectedDepthSequence);

            case 15:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    })));
  });
});

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrL2Jvb3RzdHJhcCBhYmQzMDllZTc4MDQ5M2VmNzlmMSIsImV4dGVybmFsIFwiZGVidWdcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvclwiIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXlcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5XCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZW50cmllc1wiIiwibGliL2hlbHBlcnMvaW5kZXguanMiLCJsaWIvZXZtL3NlbGVjdG9ycy9pbmRleC5qcyIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ25cIiIsImxpYi9zb2xpZGl0eS9zZWxlY3RvcnMvaW5kZXguanMiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIiLCJleHRlcm5hbCBcIndlYjNcIiIsImV4dGVybmFsIFwicmVzZWxlY3QtdHJlZVwiIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kc1wiIiwiZXh0ZXJuYWwgXCJyZWR1eC1zYWdhL2VmZmVjdHNcIiIsImxpYi9kYXRhL2RlY29kZS91dGlscy5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9mbGFnLmpzIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvaW5kZXguanMiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29uZmlnLmpzIiwidGVzdC9oZWxwZXJzLmpzIiwibGliL2FzdC9zZWxlY3RvcnMvaW5kZXguanMiLCJleHRlcm5hbCBcInJlZHV4XCIiLCJleHRlcm5hbCBcImdhbmFjaGUtY2xpXCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5c1wiIiwibGliL2RlYnVnZ2VyLmpzIiwibGliL3RyYWNlL3NlbGVjdG9ycy9pbmRleC5qcyIsImV4dGVybmFsIFwiYmlnbnVtYmVyLmpzXCIiLCJsaWIvdHJhY2UvYWN0aW9ucy9pbmRleC5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvdHlwZS1kZXRlY3QvaW5kZXguanMiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvaW5zcGVjdC5qcyIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2VcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiIiwiZXh0ZXJuYWwgXCJqc29uLXBvaW50ZXJcIiIsImxpYi9zZXNzaW9uL2FjdGlvbnMvaW5kZXguanMiLCJsaWIvZGF0YS9zZWxlY3RvcnMvaW5kZXguanMiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXRcIiIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvYXNzZXJ0aW9uLWVycm9yL2luZGV4LmpzIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldEFjdHVhbC5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXROYW1lLmpzIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL29iakRpc3BsYXkuanMiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvdHJhbnNmZXJGbGFncy5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRQYXRoSW5mby5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9oYXNQcm9wZXJ0eS5qcyIsImV4dGVybmFsIFwidHJ1ZmZsZS1leHBlY3RcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiIiwibGliL2FzdC9tYXAuanMiLCJsaWIvY29udHJvbGxlci9hY3Rpb25zL2luZGV4LmpzIiwibGliL2RhdGEvc2FnYXMvaW5kZXguanMiLCJsaWIvZGF0YS9hY3Rpb25zL2luZGV4LmpzIiwibGliL3RyYWNlL3NhZ2FzL2luZGV4LmpzIiwibGliL3NvbGlkaXR5L2FjdGlvbnMvaW5kZXguanMiLCJsaWIvZXZtL2FjdGlvbnMvaW5kZXguanMiLCJsaWIvc2Vzc2lvbi9zZWxlY3RvcnMvaW5kZXguanMiLCJ0ZXN0L2RhdGEvZGVjb2RlL2hlbHBlcnMuanMiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvcGFja2FnZXMvdHJ1ZmZsZS1kZWJ1Z2dlci9ub2RlX21vZHVsZXMvbW9jaGEtd2VicGFjay9saWIvZW50cnkuanMiLCJ0ZXN0L2FzdC5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pbmRleC5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy90ZXN0LmpzIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy90eXBlLWRldGVjdC9saWIvdHlwZS5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9leHBlY3RUeXBlcy5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRNZXNzYWdlLmpzIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldFByb3BlcnRpZXMuanMiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMuanMiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL2luZGV4LmpzIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9kZWVwLWVxbC9saWIvZXFsLmpzIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9kZWVwLWVxbC9ub2RlX21vZHVsZXMvdHlwZS1kZXRlY3QvaW5kZXguanMiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL25vZGVfbW9kdWxlcy90eXBlLWRldGVjdC9saWIvdHlwZS5qcyIsImV4dGVybmFsIFwiYnVmZmVyXCIiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0UGF0aFZhbHVlLmpzIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2FkZFByb3BlcnR5LmpzIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2FkZE1ldGhvZC5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9vdmVyd3JpdGVQcm9wZXJ0eS5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9vdmVyd3JpdGVNZXRob2QuanMiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkQ2hhaW5hYmxlTWV0aG9kLmpzIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZC5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9hc3NlcnRpb24uanMiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29yZS9hc3NlcnRpb25zLmpzIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9leHBlY3QuanMiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvaW50ZXJmYWNlL3Nob3VsZC5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9pbnRlcmZhY2UvYXNzZXJ0LmpzIiwiZXh0ZXJuYWwgXCJwYXRoXCIiLCJleHRlcm5hbCBcImZzLWV4dHJhXCIiLCJleHRlcm5hbCBcImFzeW5jXCIiLCJleHRlcm5hbCBcInRydWZmbGUtd29ya2Zsb3ctY29tcGlsZVwiIiwiZXh0ZXJuYWwgXCJ0cnVmZmxlLWRlYnVnLXV0aWxzXCIiLCJleHRlcm5hbCBcInRydWZmbGUtYXJ0aWZhY3RvclwiIiwiZXh0ZXJuYWwgXCJ0cnVmZmxlLW1pZ3JhdGVcIiIsImV4dGVybmFsIFwidHJ1ZmZsZS1ib3hcIiIsImV4dGVybmFsIFwidHJ1ZmZsZS1yZXNvbHZlclwiIiwibGliL3Nlc3Npb24vaW5kZXguanMiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvdmFsdWVzXCIiLCJleHRlcm5hbCBcInRydWZmbGUtc29saWRpdHktdXRpbHNcIiIsImV4dGVybmFsIFwidHJ1ZmZsZS1jb2RlLXV0aWxzXCIiLCJleHRlcm5hbCBcIm5vZGUtaW50ZXJ2YWwtdHJlZVwiIiwibGliL3N0b3JlL2luZGV4LmpzIiwibGliL3N0b3JlL3Rlc3QuanMiLCJsaWIvc3RvcmUvY29tbW9uLmpzIiwiZXh0ZXJuYWwgXCJyZWR1eC1zYWdhXCIiLCJleHRlcm5hbCBcInJlZHV4LWNsaS1sb2dnZXJcIiIsImxpYi9zZXNzaW9uL3NhZ2FzL2luZGV4LmpzIiwibGliL2FzdC9zYWdhcy9pbmRleC5qcyIsImxpYi9kYXRhL2RlY29kZS9pbmRleC5qcyIsImxpYi9kYXRhL2RlY29kZS9tZW1vcnkuanMiLCJsaWIvZGF0YS9kZWNvZGUvc3RvcmFnZS5qcyIsImxpYi9hc3QvYWN0aW9ucy9pbmRleC5qcyIsImxpYi9jb250cm9sbGVyL3NhZ2FzL2luZGV4LmpzIiwibGliL2NvbnRyb2xsZXIvc2VsZWN0b3JzL2luZGV4LmpzIiwibGliL3NvbGlkaXR5L3NhZ2FzL2luZGV4LmpzIiwibGliL2V2bS9zYWdhcy9pbmRleC5qcyIsImxpYi93ZWIzL3NhZ2FzL2luZGV4LmpzIiwibGliL3dlYjMvYWN0aW9ucy9pbmRleC5qcyIsImxpYi93ZWIzL2FkYXB0ZXIuanMiLCJsaWIvc2Vzc2lvbi9yZWR1Y2Vycy5qcyIsImxpYi9kYXRhL3JlZHVjZXJzLmpzIiwibGliL2V2bS9yZWR1Y2Vycy5qcyIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb21cIiIsImxpYi9zb2xpZGl0eS9yZWR1Y2Vycy5qcyIsImxpYi90cmFjZS9yZWR1Y2Vycy5qcyIsInRlc3QvY29udGV4dC5qcyIsInRlc3QvZGF0YS9kZWNvZGUvZGVjb2RpbmcuanMiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeVwiIiwidGVzdC9kYXRhL2RlY29kZS91dGlscy5qcyIsInRlc3QvZXZtLmpzIiwidGVzdC9zb2xpZGl0eS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIkRlYnVnZ2VyXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkRlYnVnZ2VyXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkRlYnVnZ2VyXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA1Nik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYWJkMzA5ZWU3ODA0OTNlZjc5ZjEiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImRlYnVnXCJcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3JcIlxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXlcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXlcIlxuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIlxuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5XCJcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9lbnRyaWVzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9lbnRyaWVzXCJcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsga2VjY2FrMjU2IGFzIF9rZWNjYWsyNTYsIHRvSGV4U3RyaW5nIH0gZnJvbSBcImxpYi9kYXRhL2RlY29kZS91dGlsc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJlZml4TmFtZShwcmVmaXgsIGZuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ25hbWUnLCB7XG4gICAgdmFsdWU6IGAke3ByZWZpeH0uJHtmbi5uYW1lfWAsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBAcmV0dXJuIDB4LXByZWZpeCBzdHJpbmcgb2Yga2VjY2FrMjU2IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1NiguLi5hcmdzKSB7XG4gIHJldHVybiB0b0hleFN0cmluZyhfa2VjY2FrMjU2KC4uLmFyZ3MpKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvaGVscGVycy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpldm06c2VsZWN0b3JzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5pbXBvcnQgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9zZWxlY3RvcnNcIjtcblxuY29uc3QgV09SRF9TSVpFID0gMHgyMDtcblxuLyoqXG4gKiBjcmVhdGUgRVZNLWxldmVsIHNlbGVjdG9ycyBmb3IgYSBnaXZlbiB0cmFjZSBzdGVwIHNlbGVjdG9yXG4gKiBtYXkgc3BlY2lmeSBhZGRpdGlvbmFsIHNlbGVjdG9ycyB0byBpbmNsdWRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0ZXBTZWxlY3RvcnMoc3RlcCwgc3RhdGUgPSBudWxsKSB7XG4gIGxldCBiYXNlID0ge1xuICAgIC8qKlxuICAgICAqIC50cmFjZVxuICAgICAqXG4gICAgICogdHJhY2Ugc3RlcCBpbmZvIHJlbGF0ZWQgdG8gb3BlcmF0aW9uXG4gICAgICovXG4gICAgdHJhY2U6IGNyZWF0ZUxlYWYoXG4gICAgICBbc3RlcF0sICh7Z2FzQ29zdCwgb3AsIHBjfSkgPT4gKHtnYXNDb3N0LCBvcCwgcGN9KVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAucHJvZ3JhbUNvdW50ZXJcbiAgICAgKi9cbiAgICBwcm9ncmFtQ291bnRlcjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vdHJhY2VcIl0sIChzdGVwKSA9PiBzdGVwLnBjXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIC5pc0p1bXBcbiAgICAgKi9cbiAgICBpc0p1bXA6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3RyYWNlXCJdLCAoc3RlcCkgPT4gKFxuICAgICAgICBzdGVwLm9wICE9IFwiSlVNUERFU1RcIiAmJiBzdGVwLm9wLmluZGV4T2YoXCJKVU1QXCIpID09IDBcbiAgICAgIClcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogLmlzQ2FsbFxuICAgICAqXG4gICAgICogd2hldGhlciB0aGUgb3Bjb2RlIHdpbGwgc3dpdGNoIHRvIGFub3RoZXIgY2FsbGluZyBjb250ZXh0XG4gICAgICovXG4gICAgaXNDYWxsOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi90cmFjZVwiXSwgKHN0ZXApID0+IHN0ZXAub3AgPT0gXCJDQUxMXCIgfHwgc3RlcC5vcCA9PSBcIkRFTEVHQVRFQ0FMTFwiXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIC5pc0NyZWF0ZVxuICAgICAqL1xuICAgIGlzQ3JlYXRlOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi90cmFjZVwiXSwgKHN0ZXApID0+IHN0ZXAub3AgPT0gXCJDUkVBVEVcIlxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuaXNIYWx0aW5nXG4gICAgICpcbiAgICAgKiB3aGV0aGVyIHRoZSBpbnN0cnVjdGlvbiBoYWx0cyBvciByZXR1cm5zIGZyb20gYSBjYWxsaW5nIGNvbnRleHRcbiAgICAgKi9cbiAgICBpc0hhbHRpbmc6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3RyYWNlXCJdLCAoc3RlcCkgPT4gc3RlcC5vcCA9PSBcIlNUT1BcIiB8fCBzdGVwLm9wID09IFwiUkVUVVJOXCJcbiAgICApXG4gIH07XG5cbiAgaWYgKHN0YXRlKSB7XG4gICAgY29uc3QgaXNSZWxhdGl2ZSA9IChwYXRoKSA9PiAoXG4gICAgICB0eXBlb2YgcGF0aCA9PSBcInN0cmluZ1wiICYmIChcbiAgICAgICAgcGF0aC5zdGFydHNXaXRoKFwiLi9cIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiLi4vXCIpXG4gICAgICApXG4gICAgKTtcblxuICAgIGlmIChpc1JlbGF0aXZlKHN0YXRlKSkge1xuICAgICAgc3RhdGUgPSBgLi4vJHtzdGF0ZX1gO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oYmFzZSwge1xuICAgICAgLyoqXG4gICAgICAgKiAuY2FsbEFkZHJlc3NcbiAgICAgICAqXG4gICAgICAgKiBhZGRyZXNzIHRyYW5zZmVycmVkIHRvIGJ5IGNhbGwgb3BlcmF0aW9uXG4gICAgICAgKi9cbiAgICAgIGNhbGxBZGRyZXNzOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIuL2lzQ2FsbFwiLCBcIi4vdHJhY2VcIiwgc3RhdGVdLFxuXG4gICAgICAgIChtYXRjaGVzLCBzdGVwLCB7c3RhY2t9KSA9PiB7XG4gICAgICAgICAgaWYgKCFtYXRjaGVzKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgIGxldCBhZGRyZXNzID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl1cbiAgICAgICAgICBhZGRyZXNzID0gXCIweFwiICsgYWRkcmVzcy5zdWJzdHJpbmcoMjQpO1xuICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIC5jcmVhdGVCaW5hcnlcbiAgICAgICAqXG4gICAgICAgKiBiaW5hcnkgY29kZSB0byBleGVjdXRlIHZpYSBjcmVhdGUgb3BlcmF0aW9uXG4gICAgICAgKi9cbiAgICAgIGNyZWF0ZUJpbmFyeTogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiLi9pc0NyZWF0ZVwiLCBcIi4vdHJhY2VcIiwgc3RhdGVdLFxuXG4gICAgICAgIChtYXRjaGVzLCBzdGVwLCB7c3RhY2ssIG1lbW9yeX0pID0+IHtcbiAgICAgICAgICBpZiAoIW1hdGNoZXMpIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgLy8gR2V0IHRoZSBjb2RlIHRoYXQncyBnb2luZyB0byBiZSBjcmVhdGVkIGZyb20gbWVtb3J5LlxuICAgICAgICAgIC8vIE5vdGUgd2UgbXVsdGlwbHkgYnkgMiBiZWNhdXNlIHRoZXNlIG9mZnNldHMgYXJlIGluIGJ5dGVzLlxuICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHBhcnNlSW50KHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLCAxNikgKiAyO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHN0YWNrW3N0YWNrLmxlbmd0aCAtIDNdLCAxNikgKiAyO1xuXG4gICAgICAgICAgcmV0dXJuIFwiMHhcIiArIG1lbW9yeS5qb2luKFwiXCIpLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufVxuXG5jb25zdCBldm0gPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuICAvKipcbiAgICogZXZtLnN0YXRlXG4gICAqL1xuICBzdGF0ZTogKHN0YXRlKSA9PiBzdGF0ZS5ldm0sXG5cbiAgLyoqXG4gICAqIGV2bS5pbmZvXG4gICAqL1xuICBpbmZvOiB7XG4gICAgLyoqXG4gICAgICogZXZtLmluZm8uY29udGV4dHNcbiAgICAgKi9cbiAgICBjb250ZXh0czogY3JlYXRlTGVhZihbJy9zdGF0ZSddLCAoc3RhdGUpID0+IHN0YXRlLmluZm8uY29udGV4dHMuYnlDb250ZXh0KSxcblxuICAgIC8qKlxuICAgICAqIGV2bS5pbmZvLmluc3RhbmNlc1xuICAgICAqL1xuICAgIGluc3RhbmNlczogY3JlYXRlTGVhZihbJy9zdGF0ZSddLCAoc3RhdGUpID0+IHN0YXRlLmluZm8uaW5zdGFuY2VzLmJ5QWRkcmVzcyksXG5cbiAgICAvKipcbiAgICAgKiBldm0uaW5mby5iaW5hcmllc1xuICAgICAqL1xuICAgIGJpbmFyaWVzOiB7XG4gICAgICBfOiBjcmVhdGVMZWFmKFsnL3N0YXRlJ10sIChzdGF0ZSkgPT4gc3RhdGUuaW5mby5jb250ZXh0cy5ieUJpbmFyeSksXG5cbiAgICAgIC8qKlxuICAgICAgICogZXZtLmluZm8uYmluYXJpZXMuc2VhcmNoXG4gICAgICAgKlxuICAgICAgICogcmV0dXJucyBmdW5jdGlvbiAoYmluYXJ5KSA9PiBjb250ZXh0XG4gICAgICAgKi9cbiAgICAgIHNlYXJjaDogY3JlYXRlTGVhZihbJy4vXyddLCAoYmluYXJpZXMpID0+IHtcbiAgICAgICAgLy8gSEFDSyBpZ25vcmUgbGluayByZWZlcmVuY2VzIGZvciBzZWFyY2hcbiAgICAgICAgLy8gbGluayByZWZlcmVuY2VzIGNvbWUgaW4gdHdvIGZvcm1zOiB3aXRoIHVuZGVyc2NvcmVzIG9yIGFsbCB6ZXJvZXNcbiAgICAgICAgLy8gdGhlIHVuZGVyc2NvcmUgZm9ybWF0IGlzIHVzZWQgYnkgVHJ1ZmZsZSB0byByZWZlcmVuY2UgbGlua3MgYnkgbmFtZVxuICAgICAgICAvLyB6ZXJvZXMgYXJlIHVzZWQgYnkgc29sYyBkaXJlY3RseSwgYXMgbGlicmFyaWVzIGluamVjdCB0aGVpciBvd25cbiAgICAgICAgLy8gYWRkcmVzcyBhdCBDUkVBVEUtdGltZVxuICAgICAgICBjb25zdCB0b1JlZ0V4cCA9IChiaW5hcnkpID0+XG4gICAgICAgICAgbmV3IFJlZ0V4cChgXiR7YmluYXJ5LnJlcGxhY2UoL19fLnszOH18MHs0MH0vZywgXCIuezQwfVwiKX1gKVxuXG4gICAgICAgIGxldCBtYXRjaGVycyA9IE9iamVjdC5lbnRyaWVzKGJpbmFyaWVzKVxuICAgICAgICAgIC5tYXAoIChbYmluYXJ5LCB7Y29udGV4dH1dKSA9PiAoe1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHJlZ2V4OiB0b1JlZ0V4cChiaW5hcnkpXG4gICAgICAgICAgfSkpXG5cbiAgICAgICAgcmV0dXJuIChiaW5hcnkpID0+IG1hdGNoZXJzXG4gICAgICAgICAgLmZpbHRlciggKHsgY29udGV4dCwgcmVnZXggfSkgPT4gYmluYXJ5Lm1hdGNoKHJlZ2V4KSApXG4gICAgICAgICAgLm1hcCggKHsgY29udGV4dCB9KSA9PiAoeyBjb250ZXh0IH0pIClcbiAgICAgICAgICBbMF0gfHwgbnVsbDtcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBldm0uY3VycmVudFxuICAgKi9cbiAgY3VycmVudDoge1xuXG4gICAgLyoqXG4gICAgICogZXZtLmN1cnJlbnQuY2FsbHN0YWNrXG4gICAgICovXG4gICAgY2FsbHN0YWNrOiAoc3RhdGUpID0+IHN0YXRlLmV2bS5wcm9jLmNhbGxzdGFjayxcblxuICAgIC8qKlxuICAgICAqIGV2bS5jdXJyZW50LmNhbGxcbiAgICAgKi9cbiAgICBjYWxsOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9jYWxsc3RhY2tcIl0sXG5cbiAgICAgIChzdGFjaykgPT4gc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gOiB7fVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5jb250ZXh0XG4gICAgICovXG4gICAgY29udGV4dDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vY2FsbFwiLCBcIi9pbmZvL2luc3RhbmNlc1wiLCBcIi9pbmZvL2JpbmFyaWVzL3NlYXJjaFwiLCBcIi9pbmZvL2NvbnRleHRzXCJdLFxuXG4gICAgICAoe2FkZHJlc3MsIGJpbmFyeX0sIGluc3RhbmNlcywgc2VhcmNoLCBjb250ZXh0cykgPT4ge1xuICAgICAgICBsZXQgcmVjb3JkO1xuICAgICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICAgIHJlY29yZCA9IGluc3RhbmNlc1thZGRyZXNzXTtcbiAgICAgICAgICBiaW5hcnkgPSByZWNvcmQuYmluYXJ5XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjb3JkID0gc2VhcmNoKGJpbmFyeSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29udGV4dCA9IGNvbnRleHRzWyhyZWNvcmQgfHwge30pLmNvbnRleHRdO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICBiaW5hcnlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5zdGF0ZVxuICAgICAqXG4gICAgICogZXZtIHN0YXRlIGluZm86IGFzIG9mIGxhc3Qgb3BlcmF0aW9uLCBiZWZvcmUgb3AgZGVmaW5lZCBpbiBzdGVwXG4gICAgICovXG4gICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oe30sIC4uLihcbiAgICAgIFtcbiAgICAgICAgXCJkZXB0aFwiLFxuICAgICAgICBcImVycm9yXCIsXG4gICAgICAgIFwiZ2FzXCIsXG4gICAgICAgIFwibWVtb3J5XCIsXG4gICAgICAgIFwic3RhY2tcIixcbiAgICAgICAgXCJzdG9yYWdlXCJcbiAgICAgIF0ubWFwKCAocGFyYW0pID0+ICh7XG4gICAgICAgIFtwYXJhbV06IGNyZWF0ZUxlYWYoW3RyYWNlLnN0ZXBdLCAoc3RlcCkgPT4gc3RlcFtwYXJhbV0pXG4gICAgICB9KSlcbiAgICApKSxcblxuICAgIC8qKlxuICAgICAqIGV2bS5jdXJyZW50LnN0ZXBcbiAgICAgKi9cbiAgICBzdGVwOiBjcmVhdGVTdGVwU2VsZWN0b3JzKHRyYWNlLnN0ZXAsIFwiLi9zdGF0ZVwiKVxuICB9LFxuXG4gIC8qKlxuICAgKiBldm0ubmV4dFxuICAgKi9cbiAgbmV4dDoge1xuXG4gICAgLyoqXG4gICAgICogZXZtLm5leHQuc3RhdGVcbiAgICAgKlxuICAgICAqIGV2bSBzdGF0ZSBhcyBhIHJlc3VsdCBvZiBuZXh0IHN0ZXAgb3BlcmF0aW9uXG4gICAgICovXG4gICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oe30sIC4uLihcbiAgICAgIFtcbiAgICAgICAgXCJkZXB0aFwiLFxuICAgICAgICBcImVycm9yXCIsXG4gICAgICAgIFwiZ2FzXCIsXG4gICAgICAgIFwibWVtb3J5XCIsXG4gICAgICAgIFwic3RhY2tcIixcbiAgICAgICAgXCJzdG9yYWdlXCJcbiAgICAgIF0ubWFwKCAocGFyYW0pID0+ICh7XG4gICAgICAgIFtwYXJhbV06IGNyZWF0ZUxlYWYoW3RyYWNlLm5leHRdLCAoc3RlcCkgPT4gc3RlcFtwYXJhbV0pXG4gICAgICB9KSlcbiAgICApKSxcblxuICAgIHN0ZXA6IGNyZWF0ZVN0ZXBTZWxlY3RvcnModHJhY2UubmV4dCwgXCIuL3N0YXRlXCIpXG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBldm07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2V2bS9zZWxlY3RvcnMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduXCJcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNvbGlkaXR5OnNlbGVjdG9yc1wiKTtcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcbmltcG9ydCBTb2xpZGl0eVV0aWxzIGZyb20gXCJ0cnVmZmxlLXNvbGlkaXR5LXV0aWxzXCI7XG5pbXBvcnQgQ29kZVV0aWxzIGZyb20gXCJ0cnVmZmxlLWNvZGUtdXRpbHNcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcblxuZnVuY3Rpb24gZ2V0U291cmNlUmFuZ2UoaW5zdHJ1Y3Rpb24gPSB7fSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBpbnN0cnVjdGlvbi5zdGFydCB8fCAwLFxuICAgIGxlbmd0aDogaW5zdHJ1Y3Rpb24ubGVuZ3RoIHx8IDAsXG4gICAgbGluZXM6IGluc3RydWN0aW9uLnJhbmdlIHx8IHtcbiAgICAgIHN0YXJ0OiB7XG4gICAgICAgIGxpbmU6IDAsIGNvbHVtbjogMFxuICAgICAgfSxcbiAgICAgIGVuZDoge1xuICAgICAgICBsaW5lOiAwLCBjb2x1bW46IDBcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmxldCBzb2xpZGl0eSA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG4gIC8qKlxuICAgKiBzb2xpZGl0eS5zdGF0ZVxuICAgKi9cbiAgc3RhdGU6IChzdGF0ZSkgPT4gc3RhdGUuc29saWRpdHksXG5cbiAgLyoqXG4gICAqIHNvbGlkaXR5LmluZm9cbiAgICovXG4gIGluZm86IHtcbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5pbmZvLnNvdXJjZXNcbiAgICAgKi9cbiAgICBzb3VyY2VzOiBjcmVhdGVMZWFmKFsnL3N0YXRlJ10sIChzdGF0ZSkgPT4gc3RhdGUuaW5mby5zb3VyY2VzLmJ5SWQpLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuaW5mby5zb3VyY2VNYXBzXG4gICAgICovXG4gICAgc291cmNlTWFwczogY3JlYXRlTGVhZihbJy9zdGF0ZSddLCAoc3RhdGUpID0+IHN0YXRlLmluZm8uc291cmNlTWFwcy5ieUNvbnRleHQpXG4gIH0sXG5cbiAgLyoqXG4gICAqIHNvbGlkaXR5LmN1cnJlbnRcbiAgICovXG4gIGN1cnJlbnQ6IHtcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuc291cmNlTWFwXG4gICAgICovXG4gICAgc291cmNlTWFwOiBjcmVhdGVMZWFmKFxuICAgICAgW2V2bS5jdXJyZW50LmNvbnRleHQsIFwiL2luZm8vc291cmNlTWFwc1wiXSxcblxuICAgICAgKHtjb250ZXh0fSwgc291cmNlTWFwcykgPT4gc291cmNlTWFwc1tjb250ZXh0XSB8fCB7fVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbkRlcHRoOiAoc3RhdGUpID0+IHN0YXRlLnNvbGlkaXR5LnByb2MuZnVuY3Rpb25EZXB0aCxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgaW5zdHJ1Y3Rpb25zOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiL2luZm8vc291cmNlc1wiLCBldm0uY3VycmVudC5jb250ZXh0LCBcIi4vc291cmNlTWFwXCJdLFxuXG4gICAgICAoc291cmNlcywge2JpbmFyeX0sIHtzb3VyY2VNYXB9KSA9PiB7XG4gICAgICAgIGxldCBpbnN0cnVjdGlvbnMgPSBDb2RlVXRpbHMucGFyc2VDb2RlKGJpbmFyeSk7XG5cbiAgICAgICAgaWYgKCFzb3VyY2VNYXApIHtcbiAgICAgICAgICAvLyBMZXQncyBjcmVhdGUgYSBzb3VyY2UgbWFwIHRvIHVzZSBzaW5jZSBub25lIGV4aXN0cy4gVGhpcyBzb3VyY2UgbWFwXG4gICAgICAgICAgLy8gbWFwcyBqdXN0IGFzIG1hbnkgcmFuZ2VzIGFzIHRoZXJlIGFyZSBpbnN0cnVjdGlvbnMsIGFuZCBlbnN1cmVzIGV2ZXJ5XG4gICAgICAgICAgLy8gaW5zdHJ1Y3Rpb24gaXMgbWFya2VkIGFzIFwianVtcGluZyBvdXRcIi4gVGhpcyB3aWxsIGVuc3VyZSBhbGxcbiAgICAgICAgICAvLyBhdmFpbGFibGUgZGVidWdnZXIgY29tbWFuZHMgc3RlcCBvbmUgaW5zdHJ1Y3Rpb24gYXQgYSB0aW1lLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVGhpcyBpcyBraW5kb2YgYSBoYWNrOyBwZXJoYXBzIHRoaXMgc2hvdWxkIGJlIGJyb2tlbiBvdXQgaW50byBzZXBhcmF0ZVxuICAgICAgICAgIC8vIGNvbnRleHQgdHlwZXMuIFRPRE9cbiAgICAgICAgICBzb3VyY2VNYXAgPSBcIlwiO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzb3VyY2VNYXAgKz0gaSArIFwiOlwiICsgaSArIFwiOjE6LTE7XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmVBbmRDb2x1bW5NYXBwaW5ncyA9IE9iamVjdC5hc3NpZ24oe30sXG4gICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMoc291cmNlcykubWFwKFxuICAgICAgICAgICAgKFtpZCwge3NvdXJjZX1dKSA9PiAoe1xuICAgICAgICAgICAgICBbaWRdOiBTb2xpZGl0eVV0aWxzLmdldENoYXJhY3Rlck9mZnNldFRvTGluZUFuZENvbHVtbk1hcHBpbmcoc291cmNlIHx8IFwiXCIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGh1bWFuUmVhZGFibGVTb3VyY2VNYXAgPSBTb2xpZGl0eVV0aWxzLmdldEh1bWFuUmVhZGFibGVTb3VyY2VNYXAoc291cmNlTWFwKTtcblxuICAgICAgICBsZXQgcHJpbWFyeUZpbGUgPSBodW1hblJlYWRhYmxlU291cmNlTWFwWzBdLmZpbGU7XG4gICAgICAgIGRlYnVnKFwicHJpbWFyeUZpbGUgJW9cIiwgcHJpbWFyeUZpbGUpO1xuXG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbnNcbiAgICAgICAgICAubWFwKCAoaW5zdHJ1Y3Rpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAvLyBsb29rdXAgc291cmNlIG1hcCBieSBpbmRleCBhbmQgYWRkIGBpbmRleGAgcHJvcGVydHkgdG9cbiAgICAgICAgICAgIC8vIGluc3RydWN0aW9uXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VNYXAgPSBodW1hblJlYWRhYmxlU291cmNlTWFwW2luZGV4XSB8fCB7fTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb246IHsgLi4uaW5zdHJ1Y3Rpb24sIGluZGV4IH0sXG4gICAgICAgICAgICAgIHNvdXJjZU1hcCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgICAubWFwKCAoeyBpbnN0cnVjdGlvbiwgc291cmNlTWFwfSkgPT4ge1xuICAgICAgICAgICAgLy8gYWRkIHNvdXJjZSBtYXAgaW5mb3JtYXRpb24gdG8gaW5zdHJ1Y3Rpb24sIG9yIGRlZmF1bHRzXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICBjb25zdCB7IGp1bXAsIHN0YXJ0ID0gMCwgbGVuZ3RoID0gMCwgZmlsZSA9IHByaW1hcnlGaWxlIH0gPSBzb3VyY2VNYXA7XG4gICAgICAgICAgICBjb25zdCBsaW5lQW5kQ29sdW1uTWFwcGluZyA9IGxpbmVBbmRDb2x1bW5NYXBwaW5nc1tmaWxlXSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgICAgICAgICBzdGFydDogbGluZUFuZENvbHVtbk1hcHBpbmdbc3RhcnRdIHx8XG4gICAgICAgICAgICAgICAgeyBsaW5lOiBudWxsLCBjb2x1bW46IG51bGwgfSxcbiAgICAgICAgICAgICAgZW5kOiBsaW5lQW5kQ29sdW1uTWFwcGluZ1tzdGFydCArIGxlbmd0aF0gfHxcbiAgICAgICAgICAgICAgICB7IGxpbmU6IG51bGwsIGNvbHVtbjogbnVsbCB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQubGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBkZWJ1ZyhcInNvdXJjZU1hcCAlb1wiLCBzb3VyY2VNYXApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5pbnN0cnVjdGlvbixcblxuICAgICAgICAgICAgICBqdW1wLFxuICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgICByYW5nZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50Lmluc3RydWN0aW9uQXRQcm9ncmFtQ291bnRlclxuICAgICAqL1xuICAgIGluc3RydWN0aW9uQXRQcm9ncmFtQ291bnRlcjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vaW5zdHJ1Y3Rpb25zXCJdLFxuXG4gICAgICAoaW5zdHJ1Y3Rpb25zKSA9PiB7XG4gICAgICAgIGxldCBtYXAgPSBbXTtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zLmZvckVhY2goZnVuY3Rpb24oaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICBtYXBbaW5zdHJ1Y3Rpb24ucGNdID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZpbGwgaW4gZ2FwcyBpbiBtYXAgYnkgZGVmYXVsdGluZyB0byB0aGUgbGFzdCBrbm93biBpbnN0cnVjdGlvblxuICAgICAgICBsZXQgbGFzdFNlZW4gPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBbcGMsIGluc3RydWN0aW9uXSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgaWYgKGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICBsYXN0U2VlbiA9IGluc3RydWN0aW9uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXBbcGNdID0gbGFzdFNlZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb25cbiAgICAgKi9cbiAgICBpbnN0cnVjdGlvbjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vaW5zdHJ1Y3Rpb25BdFByb2dyYW1Db3VudGVyXCIsIGV2bS5jdXJyZW50LnN0ZXAucHJvZ3JhbUNvdW50ZXJdLFxuXG4gICAgICAobWFwLCBwYykgPT4gbWFwW3BjXSB8fCB7fVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LnNvdXJjZVxuICAgICAqL1xuICAgIHNvdXJjZTogY3JlYXRlTGVhZihcbiAgICAgIFtcIi9pbmZvL3NvdXJjZXNcIiwgXCIuL2luc3RydWN0aW9uXCJdLFxuXG4gICAgICAoc291cmNlcywge2ZpbGU6IGlkfSkgPT4gc291cmNlc1tpZF0gfHwge31cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5zb3VyY2VSYW5nZVxuICAgICAqL1xuICAgIHNvdXJjZVJhbmdlOiBjcmVhdGVMZWFmKFtcIi4vaW5zdHJ1Y3Rpb25cIl0sIGdldFNvdXJjZVJhbmdlKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuaXNTb3VyY2VSYW5nZUZpbmFsXG4gICAgICovXG4gICAgaXNTb3VyY2VSYW5nZUZpbmFsOiBjcmVhdGVMZWFmKFxuICAgICAgW1xuICAgICAgICBcIi4vaW5zdHJ1Y3Rpb25BdFByb2dyYW1Db3VudGVyXCIsXG4gICAgICAgIGV2bS5jdXJyZW50LnN0ZXAucHJvZ3JhbUNvdW50ZXIsXG4gICAgICAgIGV2bS5uZXh0LnN0ZXAucHJvZ3JhbUNvdW50ZXJcbiAgICAgIF0sXG5cbiAgICAgIChtYXAsIGN1cnJlbnQsIG5leHQpID0+IHtcbiAgICAgICAgaWYgKCFtYXBbbmV4dF0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPSBtYXBbY3VycmVudF07XG4gICAgICAgIG5leHQgPSBtYXBbbmV4dF07XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjdXJyZW50LnN0YXJ0ICE9IG5leHQuc3RhcnQgfHxcbiAgICAgICAgICBjdXJyZW50Lmxlbmd0aCAhPSBuZXh0Lmxlbmd0aCB8fFxuICAgICAgICAgIGN1cnJlbnQuZmlsZSAhPSBuZXh0LmZpbGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5pc011bHRpbGluZVxuICAgICAqL1xuICAgIGlzTXVsdGlsaW5lOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9zb3VyY2VSYW5nZVwiXSxcblxuICAgICAgKCB7bGluZXN9ICkgPT4gbGluZXMuc3RhcnQubGluZSAhPSBsaW5lcy5lbmQubGluZVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LndpbGxKdW1wXG4gICAgICovXG4gICAgd2lsbEp1bXA6IGNyZWF0ZUxlYWYoW2V2bS5jdXJyZW50LnN0ZXAuaXNKdW1wXSwgKGlzSnVtcCkgPT4gaXNKdW1wKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuanVtcERpcmVjdGlvblxuICAgICAqL1xuICAgIGp1bXBEaXJlY3Rpb246IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL2luc3RydWN0aW9uXCJdLCAoaSA9IHt9KSA9PiAoaS5qdW1wIHx8IFwiLVwiKVxuICAgIClcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHNvbGlkaXR5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zb2xpZGl0eS9zZWxlY3RvcnMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCJcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIndlYjNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ3ZWIzXCJcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlc2VsZWN0LXRyZWVcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZXNlbGVjdC10cmVlXCJcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIlxuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXgtc2FnYS9lZmZlY3RzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVkdXgtc2FnYS9lZmZlY3RzXCJcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpkYXRhOmRlY29kZTp1dGlsc1wiKTtcblxuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcImJpZ251bWJlci5qc1wiO1xuaW1wb3J0IFdlYjMgZnJvbSBcIndlYjNcIjtcblxuZXhwb3J0IGNvbnN0IFdPUkRfU0laRSA9IDB4MjA7XG5leHBvcnQgY29uc3QgTUFYX1dPUkQgPSBuZXcgQmlnTnVtYmVyKDIpLnBvdygyNTYpLm1pbnVzKDEpO1xuXG4vKipcbiAqIHJlY3Vyc2l2ZWx5IGNvbnZlcnRzIGJpZyBudW1iZXJzIGludG8gc29tZXRoaW5nIG5pY2VyIHRvIGxvb2sgYXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuQmlnTnVtYmVycyh2YWx1ZSkge1xuICBpZiAoQmlnTnVtYmVyLmlzQmlnTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS50b051bWJlcigpO1xuXG4gIH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUubWFwICE9IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2YWx1ZS5tYXAoIChpbm5lcikgPT4gY2xlYW5CaWdOdW1iZXJzKGlubmVyKSApO1xuXG4gIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LCAuLi5PYmplY3QuZW50cmllcyh2YWx1ZSlcbiAgICAgICAgLm1hcCggKFtrZXksIGlubmVyXSkgPT4gKHsgW2tleV06IGNsZWFuQmlnTnVtYmVycyhpbm5lcikgfSkgKVxuICAgICk7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIGRlZmluaXRpb24udHlwZURlc2NyaXB0aW9ucy50eXBlSWRlbnRpZmllcjtcbn1cblxuLyoqXG4gKiByZXR1cm5zIGJhc2ljIHR5cGUgY2xhc3MgZm9yIGEgdmFyaWFibGUgZGVmaW5pdGlvbiBub2RlXG4gKiBlLmcuOlxuICogIGB0X3VpbnQyNTZgIGJlY29tZXMgYHVpbnRgXG4gKiAgYHRfc3RydWN0JF9UaGluZ18kMjBfbWVtb3J5X3B0cmAgYmVjb21lcyBgc3RydWN0YFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHlwZUNsYXNzKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pLm1hdGNoKC90XyhbXiRfMC05XSspLylbMV07XG59XG5cbi8qKlxuICogQWxsb2NhdGUgc3RvcmFnZSBmb3IgZ2l2ZW4gdmFyaWFibGUgZGVjbGFyYXRpb25zXG4gKlxuICogUG9zdGNvbmRpdGlvbjogc3RhcnRzIGEgbmV3IHNsb3QgYW5kIG9jY3VwaWVzIHdob2xlIHNsb3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGxvY2F0ZURlY2xhcmF0aW9ucyhcbiAgZGVjbGFyYXRpb25zLFxuICByZWZzLFxuICBzbG90ID0gMCxcbiAgaW5kZXggPSBXT1JEX1NJWkUgLSAxLFxuICBwYXRoID0gW11cbikge1xuICBpZiAoaW5kZXggPCBXT1JEX1NJWkUgLSAxKSB7ICAvLyBzdGFydHMgYSBuZXcgc2xvdFxuICAgIHNsb3QrKztcbiAgICBpbmRleCA9IFdPUkRfU0laRSAtIDE7XG4gIH1cblxuICBsZXQgcGFyZW50RnJvbSA9IHsgc2xvdCwgaW5kZXg6IDAgfTtcbiAgdmFyIHBhcmVudFRvID0geyBzbG90LCBpbmRleDogV09SRF9TSVpFIC0gMSB9O1xuICBsZXQgbWFwcGluZyA9IHt9O1xuXG4gIGZvciAobGV0IGRlY2xhcmF0aW9uIG9mIGRlY2xhcmF0aW9ucykge1xuICAgIGxldCB7IGZyb20sIHRvLCBuZXh0LCBjaGlsZHJlbiB9ID1cbiAgICAgIGFsbG9jYXRlRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIHJlZnMsIHNsb3QsIGluZGV4KTtcblxuICAgIG1hcHBpbmdbZGVjbGFyYXRpb24uaWRdID0geyBmcm9tLCB0bywgbmFtZTogZGVjbGFyYXRpb24ubmFtZSB9O1xuICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtYXBwaW5nW2RlY2xhcmF0aW9uLmlkXS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH1cblxuICAgIHNsb3QgPSBuZXh0LnNsb3Q7XG4gICAgaW5kZXggPSBuZXh0LmluZGV4O1xuXG4gICAgcGFyZW50VG8gPSB7IHNsb3Q6IHRvLnNsb3QsIGluZGV4OiBXT1JEX1NJWkUgLSAxIH07XG4gIH1cblxuICBpZiAoaW5kZXggPCBXT1JEX1NJWkUgLSAxKSB7XG4gICAgc2xvdCsrO1xuICAgIGluZGV4ID0gV09SRF9TSVpFIC0gMTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZnJvbTogcGFyZW50RnJvbSxcbiAgICB0bzogcGFyZW50VG8sXG4gICAgbmV4dDogeyBzbG90LCBpbmRleCB9LFxuICAgIGNoaWxkcmVuOiBtYXBwaW5nXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFsbG9jYXRlVmFsdWUoc2xvdCwgaW5kZXgsIGJ5dGVzKSB7XG4gIGxldCBmcm9tID0gaW5kZXggLSBieXRlcyArIDEgPj0gMCA/XG4gICAgeyBzbG90LCBpbmRleDogaW5kZXggLSBieXRlcyArIDEgfSA6XG4gICAgeyBzbG90OiBzbG90ICsgMSwgaW5kZXg6IFdPUkRfU0laRSAtIGJ5dGVzIH07XG5cbiAgbGV0IHRvID0geyBzbG90OiBmcm9tLnNsb3QsIGluZGV4OiBmcm9tLmluZGV4ICsgYnl0ZXMgLSAxIH07XG5cbiAgbGV0IG5leHQgPSBmcm9tLmluZGV4ID09IDAgP1xuICAgIHsgc2xvdDogZnJvbS5zbG90ICsgMSwgaW5kZXg6IFdPUkRfU0laRSAtIDEgfSA6XG4gICAgeyBzbG90OiBmcm9tLnNsb3QsIGluZGV4OiBmcm9tLmluZGV4IC0gMSB9O1xuXG4gIHJldHVybiB7IGZyb20sIHRvLCBuZXh0IH07XG59XG5cbmZ1bmN0aW9uIGFsbG9jYXRlRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIHJlZnMsIHNsb3QsIGluZGV4KSB7XG4gIGxldCBkZWZpbml0aW9uID0gcmVmc1tkZWNsYXJhdGlvbi5pZF0uZGVmaW5pdGlvbjtcbiAgdmFyIGJ5dGVTaXplID0gc3RvcmFnZVNpemUoZGVmaW5pdGlvbik7ICAvLyB5dW1cblxuICBpZiAodHlwZUNsYXNzKGRlZmluaXRpb24pICE9IFwic3RydWN0XCIpIHtcbiAgICByZXR1cm4gYWxsb2NhdGVWYWx1ZShzbG90LCBpbmRleCwgYnl0ZVNpemUpO1xuICB9XG5cbiAgbGV0IHN0cnVjdCA9IHJlZnNbZGVmaW5pdGlvbi50eXBlTmFtZS5yZWZlcmVuY2VkRGVjbGFyYXRpb25dO1xuICBkZWJ1ZyhcInN0cnVjdDogJU9cIiwgc3RydWN0KTtcblxuICBsZXQgcmVzdWx0ID0gIGFsbG9jYXRlRGVjbGFyYXRpb25zKHN0cnVjdC52YXJpYWJsZXMgfHwgW10sIHJlZnMsIHNsb3QsIGluZGV4KTtcbiAgZGVidWcoXCJzdHJ1Y3QgcmVzdWx0ICVvXCIsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogZS5nLiB1aW50NDggLT4gNlxuICogQHJldHVybiBzaXplIGluIGJ5dGVzIGZvciBleHBsaWNpdCB0eXBlIHNpemUsIG9yIGBudWxsYCBpZiBub3Qgc3RhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGVjaWZpZWRTaXplKGRlZmluaXRpb24pIHtcbiAgbGV0IHNwZWNpZmllZCA9IHR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pLm1hdGNoKC90X1thLXpdKyhbMC05XSspLyk7XG5cbiAgaWYgKCFzcGVjaWZpZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxldCBudW0gPSBzcGVjaWZpZWRbMV07XG5cbiAgc3dpdGNoICh0eXBlQ2xhc3MoZGVmaW5pdGlvbikpIHtcbiAgICBjYXNlIFwiaW50XCI6XG4gICAgY2FzZSBcInVpbnRcIjpcbiAgICAgIHJldHVybiBudW0gLyA4O1xuXG4gICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICByZXR1cm4gbnVtO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGRlYnVnKFwiVW5rbm93biB0eXBlIGZvciBzaXplIHNwZWNpZmljYXRpb246ICVzXCIsIHR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RvcmFnZVNpemUoZGVmaW5pdGlvbikge1xuICBzd2l0Y2ggKHR5cGVDbGFzcyhkZWZpbml0aW9uKSkge1xuICAgIGNhc2UgXCJib29sXCI6XG4gICAgICByZXR1cm4gMTtcblxuICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICByZXR1cm4gMjA7XG5cbiAgICBjYXNlIFwiaW50XCI6XG4gICAgY2FzZSBcInVpbnRcIjpcbiAgICAgIC8vIGlzIHRoaXMgYSBIQUNLPyAoXCIyNTZcIiAvIDgpXG4gICAgICByZXR1cm4gdHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbikubWF0Y2goL3RfW2Etel0rKFswLTldKykvKVsxXSAvIDg7XG5cbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICByZXR1cm4gV09SRF9TSVpFO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlZmVyZW5jZShkZWZpbml0aW9uKSB7XG4gIHJldHVybiB0eXBlSWRlbnRpZmllcihkZWZpbml0aW9uKS5tYXRjaCgvXyhtZW1vcnl8c3RvcmFnZSkoX3B0cik/JC8pICE9IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWZlcmVuY2VUeXBlKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pLm1hdGNoKC9fKFteX10rKShfcHRyKT8kLylbMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXNlRGVmaW5pdGlvbihkZWZpbml0aW9uKSB7XG4gIGxldCBiYXNlSWRlbnRpZmllciA9IHR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pXG4gICAgLy8gZmlyc3QgZG9sbGFyIHNpZ24gICAgIGxhc3QgZG9sbGFyIHNpZ25cbiAgICAvLyAgIGAtLS0tLS0tLS0uICAgICAgICwtLS0nXG4gICAgLm1hdGNoKC9eW14kXStcXCRfKC4rKV9cXCRbXiRdKyQvKVsxXVxuICAgIC8vICAgICAgICAgICAgICBgLS0tLScgZ3JlZWR5IG1hdGNoXG5cbiAgLy8gSEFDSyAtIGludGVybmFsIHR5cGVzIGZvciBtZW1vcnkgb3Igc3RvcmFnZSBhbHNvIHNlZW0gdG8gYmUgcG9pbnRlcnNcbiAgaWYgKGJhc2VJZGVudGlmaWVyLm1hdGNoKC9fKG1lbW9yeXxzdG9yYWdlKSQvKSAhPSBudWxsKSB7XG4gICAgYmFzZUlkZW50aWZpZXIgPSBgJHtiYXNlSWRlbnRpZmllcn1fcHRyYDtcbiAgfVxuXG4gIC8vIGFub3RoZXIgSEFDSyAtIHdlIGdldCBhd2F5IHdpdGggaXQgYmVjYXVzZXdlJ3JlIG9ubHkgdXNpbmcgdGhhdCBvbmUgcHJvcGVydHlcbiAgcmV0dXJuIHtcbiAgICB0eXBlRGVzY3JpcHRpb25zOiB7XG4gICAgICB0eXBlSWRlbnRpZmllcjogYmFzZUlkZW50aWZpZXJcbiAgICB9XG4gIH07XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnTnVtYmVyKGJ5dGVzKSB7XG4gIGlmIChieXRlcyA9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYnl0ZXMsIDE2KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnl0ZXMgPT0gXCJudW1iZXJcIiB8fCBCaWdOdW1iZXIuaXNCaWdOdW1iZXIoYnl0ZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYnl0ZXMpO1xuICB9IGVsc2UgaWYgKGJ5dGVzLnJlZHVjZSkge1xuICAgIHJldHVybiBieXRlcy5yZWR1Y2UoXG4gICAgICAobnVtLCBieXRlKSA9PiBudW0udGltZXMoMHgxMDApLnBsdXMoYnl0ZSksXG4gICAgICBuZXcgQmlnTnVtYmVyKDApXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9TaWduZWRCaWdOdW1iZXIoYnl0ZXMpIHtcbiAgaWYgKGJ5dGVzWzBdIDwgMGIxMDAwMDAwMCkgeyAgLy8gZmlyc3QgYml0IGlzIDBcbiAgICByZXR1cm4gdG9CaWdOdW1iZXIoYnl0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b0JpZ051bWJlcihieXRlcy5tYXAoIChiKSA9PiAweGZmIC0gYiApKS5wbHVzKDEpLm5lZ2F0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSBieXRlcyAtIFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBsZW5ndGggLSBkZXNpcmVkIGJ5dGUgbGVuZ3RoIChwYWQgd2l0aCB6ZXJvZXMpXG4gKiBAcGFyYW0gdHJpbSAtIG9taXQgbGVhZGluZyB6ZXJvZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4U3RyaW5nKGJ5dGVzLCBsZW5ndGggPSAwLCB0cmltID0gZmFsc2UpIHtcbiAgaWYgKHR5cGVvZiBsZW5ndGggPT0gXCJib29sZWFuXCIpIHtcbiAgICB0cmltID0gbGVuZ3RoO1xuICAgIGxlbmd0aCA9IDA7XG4gIH1cblxuICBpZiAoQmlnTnVtYmVyLmlzQmlnTnVtYmVyKGJ5dGVzKSkge1xuICAgIGJ5dGVzID0gdG9CeXRlcyhieXRlcyk7XG4gIH1cblxuICBjb25zdCBwYWQgPSAocykgPT4gYCR7XCIwMFwiLnNsaWNlKDAsIDIgLSBzLmxlbmd0aCl9JHtzfWBcblxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgIDEgIDIgIDMgIDRcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwICAxICAyICAzICA0ICA1ICA2ICA3XG4gIC8vIGJ5dGVzLmxlbmd0aDogICAgICAgIDUgIC0gIDB4KCAgICAgICAgICBlNSBjMiBhYSAwOSAxMSApXG4gIC8vIGxlbmd0aCAocHJlZmVycmVkKTogIDggIC0gIDB4KCAwMCAwMCAwMCBlNSBjMiBhYSAwOSAxMSApXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLS0uLS0tJ1xuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgM1xuICBpZiAoYnl0ZXMubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgbGV0IHByaW9yID0gYnl0ZXM7XG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXG4gICAgYnl0ZXMuc2V0KHByaW9yLCBsZW5ndGggLSBwcmlvci5sZW5ndGgpO1xuICB9XG5cbiAgZGVidWcoXCJieXRlczogJW9cIiwgYnl0ZXMpO1xuXG4gIGxldCBzdHJpbmcgPSBieXRlcy5yZWR1Y2UoXG4gICAgKHN0ciwgYnl0ZSkgPT4gYCR7c3RyfSR7cGFkKGJ5dGUudG9TdHJpbmcoMTYpKX1gLCBcIlwiXG4gICk7XG5cbiAgaWYgKHRyaW0pIHtcbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXigwMCkrLywgXCJcIik7XG4gIH1cblxuICBpZiAoc3RyaW5nLmxlbmd0aCA9PSAwKSB7XG4gICAgc3RyaW5nID0gXCIwMFwiO1xuICB9XG5cbiAgcmV0dXJuIGAweCR7c3RyaW5nfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKG51bWJlciwgbGVuZ3RoID0gMCkge1xuICBpZiAobnVtYmVyIDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGxldCBoZXggPSBudW1iZXIudG9TdHJpbmcoMTYpO1xuICBpZiAoaGV4Lmxlbmd0aCAlIDIgPT0gMSkge1xuICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgfVxuXG4gIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFxuICAgIGhleC5tYXRjaCgvLnsyfS9nKVxuICAgICAgLm1hcCggKGJ5dGUpID0+IHBhcnNlSW50KGJ5dGUsIDE2KSApXG4gICk7XG5cbiAgaWYgKGJ5dGVzLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgIGxldCBwcmlvciA9IGJ5dGVzO1xuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBieXRlcy5zZXQocHJpb3IsIGxlbmd0aCAtIHByaW9yLmxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYoLi4uYXJncykge1xuICBsZXQgd2ViMyA9IG5ldyBXZWIzKCk7XG5cbiAgYXJncyA9IGFyZ3MubWFwKCAoYXJnKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT0gXCJudW1iZXJcIiB8fCBCaWdOdW1iZXIuaXNCaWdOdW1iZXIoYXJnKSkge1xuICAgICAgcmV0dXJuIHRvSGV4U3RyaW5nKHRvQnl0ZXMoYXJnLCBXT1JEX1NJWkUpKS5zbGljZSgyKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gd2ViMy50b0hleChhcmcpLnNsaWNlKDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH0pO1xuXG4gIGxldCBzaGEgPSB3ZWIzLnNoYTMoYXJncy5qb2luKCcnKSwgeyBlbmNvZGluZzogJ2hleCcgfSk7XG4gIGRlYnVnKFwic2hhICVvXCIsIHNoYSk7XG4gIHJldHVybiB0b0JpZ051bWJlcihzaGEpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kYXRhL2RlY29kZS91dGlscy5qcyIsIi8qIVxuICogQ2hhaSAtIGZsYWcgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIGZsYWcob2JqZWN0LCBrZXksIFt2YWx1ZV0pXG4gKlxuICogR2V0IG9yIHNldCBhIGZsYWcgdmFsdWUgb24gYW4gb2JqZWN0LiBJZiBhXG4gKiB2YWx1ZSBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHNldCwgZWxzZSBpdCB3aWxsXG4gKiByZXR1cm4gdGhlIGN1cnJlbnRseSBzZXQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgaWZcbiAqIHRoZSB2YWx1ZSBpcyBub3Qgc2V0LlxuICpcbiAqICAgICB1dGlscy5mbGFnKHRoaXMsICdmb28nLCAnYmFyJyk7IC8vIHNldHRlclxuICogICAgIHV0aWxzLmZsYWcodGhpcywgJ2ZvbycpOyAvLyBnZXR0ZXIsIHJldHVybnMgYGJhcmBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IGNvbnN0cnVjdGVkIEFzc2VydGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgKG9wdGlvbmFsKVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZmxhZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIHZhciBmbGFncyA9IG9iai5fX2ZsYWdzIHx8IChvYmouX19mbGFncyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGZsYWdzW2tleV0gPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmxhZ3Nba2V5XTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9mbGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvclwiXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2NoYWknKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcuaW5jbHVkZVN0YWNrXG4gICAqXG4gICAqIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnR5LCBpbmZsdWVuY2VzIHdoZXRoZXIgc3RhY2sgdHJhY2VcbiAgICogaXMgaW5jbHVkZWQgaW4gQXNzZXJ0aW9uIGVycm9yIG1lc3NhZ2UuIERlZmF1bHQgb2YgZmFsc2VcbiAgICogc3VwcHJlc3NlcyBzdGFjayB0cmFjZSBpbiB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICpcbiAgICogICAgIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayA9IHRydWU7ICAvLyBlbmFibGUgc3RhY2sgb24gZXJyb3JcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICAgaW5jbHVkZVN0YWNrOiBmYWxzZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy5zaG93RGlmZlxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgaW5mbHVlbmNlcyB3aGV0aGVyIG9yIG5vdFxuICAgKiB0aGUgYHNob3dEaWZmYCBmbGFnIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdGhyb3duXG4gICAqIEFzc2VydGlvbkVycm9ycy4gYGZhbHNlYCB3aWxsIGFsd2F5cyBiZSBgZmFsc2VgOyBgdHJ1ZWBcbiAgICogd2lsbCBiZSB0cnVlIHdoZW4gdGhlIGFzc2VydGlvbiBoYXMgcmVxdWVzdGVkIGEgZGlmZlxuICAgKiBiZSBzaG93bi5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBzaG93RGlmZjogdHJ1ZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZFxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgc2V0cyBsZW5ndGggdGhyZXNob2xkIGZvciBhY3R1YWwgYW5kXG4gICAqIGV4cGVjdGVkIHZhbHVlcyBpbiBhc3NlcnRpb24gZXJyb3JzLiBJZiB0aGlzIHRocmVzaG9sZCBpcyBleGNlZWRlZCwgZm9yXG4gICAqIGV4YW1wbGUgZm9yIGxhcmdlIGRhdGEgc3RydWN0dXJlcywgdGhlIHZhbHVlIGlzIHJlcGxhY2VkIHdpdGggc29tZXRoaW5nXG4gICAqIGxpa2UgYFsgQXJyYXkoMykgXWAgb3IgYHsgT2JqZWN0IChwcm9wMSwgcHJvcDIpIH1gLlxuICAgKlxuICAgKiBTZXQgaXQgdG8gemVybyBpZiB5b3Ugd2FudCB0byBkaXNhYmxlIHRydW5jYXRpbmcgYWx0b2dldGhlci5cbiAgICpcbiAgICogVGhpcyBpcyBlc3BlY2lhbGx5IHVzZXJmdWwgd2hlbiBkb2luZyBhc3NlcnRpb25zIG9uIGFycmF5czogaGF2aW5nIHRoaXNcbiAgICogc2V0IHRvIGEgcmVhc29uYWJsZSBsYXJnZSB2YWx1ZSBtYWtlcyB0aGUgZmFpbHVyZSBtZXNzYWdlcyByZWFkaWx5XG4gICAqIGluc3BlY3RhYmxlLlxuICAgKlxuICAgKiAgICAgY2hhaS5jb25maWcudHJ1bmNhdGVUaHJlc2hvbGQgPSAwOyAgLy8gZGlzYWJsZSB0cnVuY2F0aW5nXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICB0cnVuY2F0ZVRocmVzaG9sZDogNDBcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9jb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJ0ZXN0OmhlbHBlcnNcIik7XG5cbmltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgZnMgZnJvbSBcImZzLWV4dHJhXCI7XG5pbXBvcnQgYXN5bmMgZnJvbSBcImFzeW5jXCI7XG5pbXBvcnQgQ29udHJhY3RzIGZyb20gXCJ0cnVmZmxlLXdvcmtmbG93LWNvbXBpbGVcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwidHJ1ZmZsZS1kZWJ1Zy11dGlsc1wiO1xuaW1wb3J0IEFydGlmYWN0b3IgZnJvbSBcInRydWZmbGUtYXJ0aWZhY3RvclwiO1xuaW1wb3J0IFdlYjMgZnJvbSBcIndlYjNcIjtcbmltcG9ydCBNaWdyYXRlIGZyb20gXCJ0cnVmZmxlLW1pZ3JhdGVcIjtcbmltcG9ydCBCb3ggZnJvbSBcInRydWZmbGUtYm94XCI7XG5pbXBvcnQgUmVzb2x2ZXIgZnJvbSBcInRydWZmbGUtcmVzb2x2ZXJcIjtcbmltcG9ydCBleHBlY3QgZnJvbSBcInRydWZmbGUtZXhwZWN0XCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVwYXJlQ29udHJhY3RzKHByb3ZpZGVyLCBzb3VyY2VzID0ge30sIG1pZ3JhdGlvbnMpIHtcbiAgbGV0IGNvbmZpZyA9IGF3YWl0IGNyZWF0ZVNhbmRib3goKTtcblxuICBsZXQgYWNjb3VudHMgPSBhd2FpdCBnZXRBY2NvdW50cyhwcm92aWRlcik7XG5cbiAgY29uZmlnLm5ldHdvcmtzW1wiZGVidWdnZXJcIl0gPSB7XG4gICAgcHJvdmlkZXI6IHByb3ZpZGVyLFxuICAgIG5ldHdvcmtfaWQ6IFwiKlwiLFxuICAgIGZyb206IGFjY291bnRzWzBdXG4gIH1cbiAgY29uZmlnLm5ldHdvcmsgPSBcImRlYnVnZ2VyXCI7XG5cbiAgYXdhaXQgYWRkQ29udHJhY3RzKGNvbmZpZywgc291cmNlcyk7XG4gIGxldCB7IGNvbnRyYWN0cywgZmlsZXMgfSA9IGF3YWl0IGNvbXBpbGUoY29uZmlnKTtcbiAgbGV0IGNvbnRyYWN0TmFtZXMgPSBPYmplY3Qua2V5cyhjb250cmFjdHMpO1xuXG4gIGlmICghbWlncmF0aW9ucykge1xuICAgIG1pZ3JhdGlvbnMgPSBhd2FpdCBkZWZhdWx0TWlncmF0aW9ucyhjb250cmFjdE5hbWVzKTtcbiAgfVxuXG4gIGF3YWl0IGFkZE1pZ3JhdGlvbnMoY29uZmlnLCBtaWdyYXRpb25zKTtcbiAgYXdhaXQgbWlncmF0ZShjb25maWcpO1xuXG4gIGxldCBhcnRpZmFjdHMgPSBhd2FpdCBnYXRoZXJBcnRpZmFjdHMoY29uZmlnKTtcbiAgZGVidWcoXCJhcnRpZmFjdHM6ICVvXCIsIGFydGlmYWN0cy5tYXAoKGEpID0+IGEuY29udHJhY3ROYW1lKSk7XG5cbiAgbGV0IGFic3RyYWN0aW9ucyA9IHt9O1xuICBjb250cmFjdE5hbWVzLmZvckVhY2goIChuYW1lKSA9PiB7XG4gICAgYWJzdHJhY3Rpb25zW25hbWVdID0gY29uZmlnLnJlc29sdmVyLnJlcXVpcmUobmFtZSk7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgZmlsZXMsXG4gICAgYWJzdHJhY3Rpb25zLFxuICAgIGFydGlmYWN0cyxcbiAgICBjb25maWdcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFjY291bnRzKHByb3ZpZGVyKSB7XG4gIGxldCB3ZWIzID0gbmV3IFdlYjMocHJvdmlkZXIpO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oYWNjZXB0LCByZWplY3QpIHtcbiAgICB3ZWIzLmV0aC5nZXRBY2NvdW50cyhmdW5jdGlvbihlcnIsIGFjY291bnRzKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICBhY2NlcHQoYWNjb3VudHMpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNhbmRib3goKSB7XG4gIGxldCBjb25maWcgPSBhd2FpdCBuZXcgUHJvbWlzZShmdW5jdGlvbihhY2NlcHQsIHJlamVjdCkge1xuICAgIEJveC5zYW5kYm94KGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICByZXN1bHQucmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXIocmVzdWx0KTtcbiAgICAgIHJlc3VsdC5hcnRpZmFjdG9yID0gbmV3IEFydGlmYWN0b3IocmVzdWx0LmNvbnRyYWN0c19idWlsZF9kaXJlY3RvcnkpO1xuICAgICAgcmVzdWx0Lm5ldHdvcmtzID0ge307XG5cbiAgICAgIGFjY2VwdChyZXN1bHQpO1xuICAgIH0pO1xuICB9KTtcblxuICBhd2FpdCBmcy5yZW1vdmUocGF0aC5qb2luKGNvbmZpZy5jb250cmFjdHNfZGlyZWN0b3J5LCBcIk1ldGFDb2luLnNvbFwiKSk7XG4gIGF3YWl0IGZzLnJlbW92ZShwYXRoLmpvaW4oY29uZmlnLmNvbnRyYWN0c19kaXJlY3RvcnksIFwiQ29udmVydExpYi5zb2xcIikpO1xuICBhd2FpdCBmcy5yZW1vdmUocGF0aC5qb2luKGNvbmZpZy5taWdyYXRpb25zX2RpcmVjdG9yeSwgXCIyX2RlcGxveV9jb250cmFjdHMuanNcIikpO1xuXG4gIHJldHVybiBjb25maWc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRDb250cmFjdHMoY29uZmlnLCBzb3VyY2VzID0ge30pIHtcbiAgbGV0IHByb21pc2VzID0gW107XG4gIGZvciAobGV0IGZpbGVuYW1lIG9mIE9iamVjdC5rZXlzKHNvdXJjZXMpKSB7XG4gICAgbGV0IHNvdXJjZSA9IHNvdXJjZXNbZmlsZW5hbWVdO1xuICAgIHByb21pc2VzLnB1c2goXG4gICAgICBmcy5vdXRwdXRGaWxlKHBhdGguam9pbihjb25maWcuY29udHJhY3RzX2RpcmVjdG9yeSwgZmlsZW5hbWUpLCBzb3VyY2UpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRNaWdyYXRpb25zKGNvbmZpZywgbWlncmF0aW9ucyA9IHt9KSB7XG4gIGxldCBwcm9taXNlcyA9IFtdO1xuICBmb3IgKGxldCBmaWxlbmFtZSBvZiBPYmplY3Qua2V5cyhtaWdyYXRpb25zKSkge1xuICAgIGxldCBzb3VyY2UgPSBtaWdyYXRpb25zW2ZpbGVuYW1lXTtcbiAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgZnMub3V0cHV0RmlsZShwYXRoLmpvaW4oY29uZmlnLm1pZ3JhdGlvbnNfZGlyZWN0b3J5LCBmaWxlbmFtZSksIHNvdXJjZSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlZmF1bHRNaWdyYXRpb25zKGNvbnRyYWN0TmFtZXMpIHtcbiAgY29udHJhY3ROYW1lcyA9IGNvbnRyYWN0TmFtZXMuZmlsdGVyKChuYW1lKSA9PiBuYW1lICE9IFwiTWlncmF0aW9uc1wiKTtcblxuICBsZXQgbWlncmF0aW9ucyA9IHt9O1xuXG4gIGNvbnRyYWN0TmFtZXMuZm9yRWFjaCggKGNvbnRyYWN0TmFtZSwgaSkgPT4ge1xuICAgIGxldCBpbmRleCA9IGkgKyAyOyAgLy8gc3RhcnQgYXQgMiBjYXVzZSBNaWdyYXRpb25zIG1pZ3JhdGlvblxuICAgIGxldCBmaWxlbmFtZSA9IGAke2luZGV4fV9taWdyYXRlXyR7Y29udHJhY3ROYW1lfS5qc2A7XG4gICAgbGV0IHNvdXJjZSA9IGBcbiAgICAgIHZhciAke2NvbnRyYWN0TmFtZX0gPSBhcnRpZmFjdHMucmVxdWlyZShcIiR7Y29udHJhY3ROYW1lfVwiKTtcblxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkZXBsb3llcikge1xuICAgICAgICBkZXBsb3llci5kZXBsb3koJHtjb250cmFjdE5hbWV9KTtcbiAgICAgIH07XG4gICAgYDtcblxuICAgIG1pZ3JhdGlvbnNbZmlsZW5hbWVdID0gc291cmNlXG4gIH0pO1xuXG4gIHJldHVybiBtaWdyYXRpb25zO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29tcGlsZShjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGFjY2VwdCwgcmVqZWN0KSB7XG4gICAgQ29udHJhY3RzLmNvbXBpbGUoY29uZmlnLndpdGgoe1xuICAgICAgYWxsOiB0cnVlLFxuICAgICAgcXVpZXQ6IHRydWVcbiAgICB9KSwgZnVuY3Rpb24oZXJyLCBjb250cmFjdHMsIGZpbGVzKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICByZXR1cm4gYWNjZXB0KHtjb250cmFjdHMsIGZpbGVzfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWlncmF0ZShjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGFjY2VwdCwgcmVqZWN0KSB7XG4gICAgTWlncmF0ZS5ydW4oY29uZmlnLndpdGgoe1xuICAgICAgcXVpZXQ6IHRydWVcbiAgICB9KSwgZnVuY3Rpb24oZXJyLCBjb250cmFjdHMpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIGFjY2VwdChjb250cmFjdHMpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdhdGhlckFydGlmYWN0cyhjb25maWcpIHtcbiAgcmV0dXJuIERlYnVnLmdhdGhlckFydGlmYWN0cyhjb25maWcpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHRlc3QvaGVscGVycy5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjphc3Q6c2VsZWN0b3JzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuaW1wb3J0IGpzb25wb2ludGVyIGZyb20gXCJqc29uLXBvaW50ZXJcIjtcblxuaW1wb3J0IHNvbGlkaXR5IGZyb20gXCJsaWIvc29saWRpdHkvc2VsZWN0b3JzXCI7XG5cbmltcG9ydCB7IGZpbmRSYW5nZSB9IGZyb20gXCIuLi9tYXBcIjtcblxuXG4vKipcbiAqIGFzdFxuICovXG5jb25zdCBhc3QgPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuICAvKipcbiAgICogYXN0LnZpZXdzXG4gICAqL1xuICB2aWV3czoge1xuICAgIC8qKlxuICAgICAqIGFzdC52aWV3cy5zb3VyY2VzXG4gICAgICovXG4gICAgc291cmNlczogY3JlYXRlTGVhZihbc29saWRpdHkuaW5mby5zb3VyY2VzXSwgc291cmNlcyA9PiBzb3VyY2VzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBhc3QuY3VycmVudFxuICAgKi9cbiAgY3VycmVudDoge1xuXG4gICAgLyoqXG4gICAgICogYXN0LmN1cnJlbnQudHJlZVxuICAgICAqXG4gICAgICogYXN0IGZvciBjdXJyZW50IHNvdXJjZVxuICAgICAqL1xuICAgIHRyZWU6IGNyZWF0ZUxlYWYoXG4gICAgICBbc29saWRpdHkuY3VycmVudC5zb3VyY2VdLCAoe2FzdH0pID0+IGFzdFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBhc3QuY3VycmVudC5pbmRleFxuICAgICAqXG4gICAgICogc291cmNlIElEXG4gICAgICovXG4gICAgaW5kZXg6IGNyZWF0ZUxlYWYoXG4gICAgICBbc29saWRpdHkuY3VycmVudC5zb3VyY2VdLCAoe2lkfSkgPT4gaWRcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogYXN0LmN1cnJlbnQucG9pbnRlclxuICAgICAqXG4gICAgICoganNvbnBvaW50ZXIgZm9yIGN1cnJlbnQgYXN0IG5vZGVcbiAgICAgKi9cbiAgICBwb2ludGVyOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi90cmVlXCIsIHNvbGlkaXR5LmN1cnJlbnQuc291cmNlUmFuZ2VdLFxuXG4gICAgICAoYXN0LCByYW5nZSkgPT4gZmluZFJhbmdlKGFzdCwgcmFuZ2Uuc3RhcnQsIHJhbmdlLmxlbmd0aClcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogYXN0LmN1cnJlbnQubm9kZVxuICAgICAqXG4gICAgICogY3VycmVudCBhc3Qgbm9kZSB0byBleGVjdXRlXG4gICAgICovXG4gICAgbm9kZTogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vdHJlZVwiLCBcIi4vcG9pbnRlclwiXSwgKGFzdCwgcG9pbnRlcikgPT5cbiAgICAgICAgKHBvaW50ZXIpXG4gICAgICAgICAgPyBqc29ucG9pbnRlci5nZXQoYXN0LCBwb2ludGVyKVxuICAgICAgICAgIDoganNvbnBvaW50ZXIuZ2V0KGFzdCwgXCJcIilcbiAgICApLFxuXG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBhc3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2FzdC9zZWxlY3RvcnMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWR1eFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJlZHV4XCJcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImdhbmFjaGUtY2xpXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZ2FuYWNoZS1jbGlcIlxuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzXCJcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgZXhwZWN0IGZyb20gXCJ0cnVmZmxlLWV4cGVjdFwiO1xuXG5pbXBvcnQgU2Vzc2lvbiBmcm9tIFwiLi9zZXNzaW9uXCI7XG5cbmltcG9ydCB7IGNyZWF0ZU5lc3RlZFNlbGVjdG9yIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcblxuaW1wb3J0IGRhdGFTZWxlY3RvciBmcm9tIFwiLi9kYXRhL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGFzdFNlbGVjdG9yIGZyb20gXCIuL2FzdC9zZWxlY3RvcnNcIjtcbmltcG9ydCB0cmFjZVNlbGVjdG9yIGZyb20gXCIuL3RyYWNlL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGV2bVNlbGVjdG9yIGZyb20gXCIuL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCBzb2xpZGl0eVNlbGVjdG9yIGZyb20gXCIuL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNlc3Npb25TZWxlY3RvciBmcm9tIFwiLi9zZXNzaW9uL3NlbGVjdG9yc1wiO1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXJcIik7XG5cbi8qKlxuICogQGV4YW1wbGVcbiAqIGxldCBzZXNzaW9uID0gRGVidWdnZXJcbiAqICAgLmZvclR4KDx0eEhhc2g+LCB7XG4gKiAgICAgY29udHJhY3RzOiBbPGNvbnRyYWN0IG9iaj4sIC4uLl0sXG4gKiAgICAgcHJvdmlkZXI6IDxwcm92aWRlciBpbnN0YW5jZT5cbiAqICAgfSlcbiAqICAgLmNvbm5lY3QoKTtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVidWdnZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtTZXNzaW9ufSBzZXNzaW9uIC0gZGVidWdnZXIgc2Vzc2lvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2Vzc2lvbikge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc2Vzc2lvbiA9IHNlc3Npb247XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFudGlhdGVzIGEgRGVidWdnZXIgZm9yIGEgZ2l2ZW4gdHJhbnNhY3Rpb24gaGFzaC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR4SGFzaCAtIHRyYW5zYWN0aW9uIGhhc2ggd2l0aCBsZWFkaW5nIFwiMHhcIlxuICAgKiBAcGFyYW0ge3tjb250cmFjdHM6IEFycmF5PENvbnRyYWN0PiwgZmlsZXM6IEFycmF5PFN0cmluZz4sIHByb3ZpZGVyOiBXZWIzUHJvdmlkZXJ9fSBvcHRpb25zIC1cbiAgICogQHJldHVybiB7RGVidWdnZXJ9IGluc3RhbmNlXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZm9yVHgodHhIYXNoLCBvcHRpb25zID0ge30pIHtcbiAgICBleHBlY3Qub3B0aW9ucyhvcHRpb25zLCBbXG4gICAgICBcImNvbnRyYWN0c1wiLFxuICAgICAgXCJwcm92aWRlclwiXG4gICAgXSk7XG5cbiAgICBsZXQgc2Vzc2lvbiA9IG5ldyBTZXNzaW9uKFxuICAgICAgb3B0aW9ucy5jb250cmFjdHMsIG9wdGlvbnMuZmlsZXMsXG4gICAgICB0eEhhc2gsIG9wdGlvbnMucHJvdmlkZXJcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHNlc3Npb24ucmVhZHkoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgdGhpcyhzZXNzaW9uKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIHRoZSBpbnN0YW50aWF0ZWQgRGVidWdnZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge1Nlc3Npb259IHNlc3Npb24gaW5zdGFuY2VcbiAgICovXG4gIGNvbm5lY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nlc3Npb247XG4gIH1cblxuICAvKipcbiAgICogRXhwb3J0ZWQgc2VsZWN0b3JzXG4gICAqXG4gICAqIFNlZSBpbmRpdmlkdWFsIHNlbGVjdG9yIGRvY3MgZm9yIGZ1bGwgbGlzdGluZ1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBEZWJ1Z2dlci5zZWxlY3RvcnMuYXN0LmN1cnJlbnQudHJlZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBEZWJ1Z2dlci5zZWxlY3RvcnMuc29saWRpdHkuY3VycmVudC5pbnN0cnVjdGlvblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBEZWJ1Z2dlci5zZWxlY3RvcnMudHJhY2Uuc3RlcHNcbiAgICovXG4gIHN0YXRpYyBnZXQgc2VsZWN0b3JzKCkge1xuICAgIHJldHVybiBjcmVhdGVOZXN0ZWRTZWxlY3Rvcih7XG4gICAgICBhc3Q6IGFzdFNlbGVjdG9yLFxuICAgICAgZGF0YTogZGF0YVNlbGVjdG9yLFxuICAgICAgdHJhY2U6IHRyYWNlU2VsZWN0b3IsXG4gICAgICBldm06IGV2bVNlbGVjdG9yLFxuICAgICAgc29saWRpdHk6IHNvbGlkaXR5U2VsZWN0b3IsXG4gICAgICBzZXNzaW9uOiBzZXNzaW9uU2VsZWN0b3IsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb250cmFjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRyYWN0TmFtZSBjb250cmFjdCBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIHNvbGlkaXR5IHNvdXJjZSBjb2RlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlUGF0aCBwYXRoIHRvIHNvdXJjZSBmaWxlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYmluYXJ5IDB4LXByZWZpeGVkIGhleCBzdHJpbmcgd2l0aCBjcmVhdGUgYnl0ZWNvZGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2VNYXAgc29saWRpdHkgc291cmNlIG1hcCBmb3IgY3JlYXRlIGJ5dGVjb2RlXG4gKiBAcHJvcGVydHkge09iamVjdH0gYXN0IEFic3RyYWN0IFN5bnRheCBUcmVlIGZyb20gU29saWRpdHlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXBsb3llZEJpbmFyeSAweC1wcmVmaXhlZCBjb21waWxlZCBiaW5hcnkgKG9uIGNoYWluKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlcGxveWVkU291cmNlTWFwIHNvbGlkaXR5IHNvdXJjZSBtYXAgZm9yIG9uLWNoYWluIGJ5dGVjb2RlXG4gKi9cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGVidWdnZXIuanMiLCJpbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5sZXQgdHJhY2UgPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuICAvKipcbiAgICogdHJhY2UuaW5kZXhcbiAgICpcbiAgICogY3VycmVudCBzdGVwIGluZGV4XG4gICAqL1xuICBpbmRleDogKHN0YXRlKSA9PiBzdGF0ZS50cmFjZS5wcm9jLmluZGV4LFxuXG4gIC8qKlxuICAgKiB0cmFjZS5zdGVwc1xuICAgKlxuICAgKiBhbGwgdHJhY2Ugc3RlcHNcbiAgICovXG4gIHN0ZXBzOiAoc3RhdGUpID0+IHN0YXRlLnRyYWNlLmluZm8uc3RlcHMsXG5cbiAgLyoqXG4gICAqIHRyYWNlLnN0ZXBzUmVtYWluaW5nXG4gICAqXG4gICAqIG51bWJlciBvZiBzdGVwcyByZW1haW5pbmcgaW4gdHJhY2VcbiAgICovXG4gIHN0ZXBzUmVtYWluaW5nOiBjcmVhdGVMZWFmKFxuICAgIFtcIi4vc3RlcHNcIiwgXCIuL2luZGV4XCJdLCAoc3RlcHMsIGluZGV4KSA9PiBzdGVwcy5sZW5ndGggLSBpbmRleFxuICApLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5zdGVwXG4gICAqXG4gICAqIGN1cnJlbnQgdHJhY2Ugc3RlcFxuICAgKi9cbiAgc3RlcDogY3JlYXRlTGVhZihcbiAgICBbXCIuL3N0ZXBzXCIsIFwiLi9pbmRleFwiXSwgKHN0ZXBzLCBpbmRleCkgPT4gc3RlcHNbaW5kZXhdXG4gICksXG5cbiAgLyoqXG4gICAqIHRyYWNlLm5leHRcbiAgICpcbiAgICogbmV4dCB0cmFjZSBzdGVwIG9yIHt9XG4gICAqL1xuICBuZXh0OiBjcmVhdGVMZWFmKFxuICAgIFtcIi4vc3RlcHNcIiwgXCIuL2luZGV4XCJdLCAoc3RlcHMsIGluZGV4KSA9PlxuICAgICAgaW5kZXggPCBzdGVwcy5sZW5ndGggLSAxID8gc3RlcHNbaW5kZXggKyAxXSA6IHt9XG4gIClcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB0cmFjZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvdHJhY2Uvc2VsZWN0b3JzL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmlnbnVtYmVyLmpzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmlnbnVtYmVyLmpzXCJcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBjb25zdCBTQVZFX1NURVBTID0gXCJTQVZFX1NURVBTXCI7XG5leHBvcnQgZnVuY3Rpb24gc2F2ZVN0ZXBzKHN0ZXBzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU0FWRV9TVEVQUyxcbiAgICBzdGVwc1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVDRUlWRV9BRERSRVNTRVMgPSBcIlJFQ0VJVkVfQUREUkVTU0VTXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVjZWl2ZUFkZHJlc3NlcyhhZGRyZXNzZXMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUNFSVZFX0FERFJFU1NFUyxcbiAgICBhZGRyZXNzZXNcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IE5FWFQgPSBcIk5FWFRcIjtcbmV4cG9ydCBmdW5jdGlvbiBuZXh0KCkge1xuICByZXR1cm4ge3R5cGU6IE5FWFR9O1xufVxuXG5leHBvcnQgY29uc3QgVElDSyA9IFwiVElDS1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHRpY2soKSB7XG4gIHJldHVybiB7dHlwZTogVElDS307XG59XG5cbmV4cG9ydCBjb25zdCBUT0NLID0gXCJUT0NLXCI7XG5leHBvcnQgZnVuY3Rpb24gdG9jaygpIHtcbiAgcmV0dXJuIHt0eXBlOiBUT0NLfTtcbn1cblxuZXhwb3J0IGNvbnN0IEVORF9PRl9UUkFDRSA9IFwiRU9UXCI7XG5leHBvcnQgZnVuY3Rpb24gZW5kVHJhY2UoKSB7XG4gIHJldHVybiB7dHlwZTogRU5EX09GX1RSQUNFfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvdHJhY2UvYWN0aW9ucy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvdHlwZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy90eXBlLWRldGVjdC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhpcyBpcyAoYWxtb3N0KSBkaXJlY3RseSBmcm9tIE5vZGUuanMgdXRpbHNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9ibG9iL2Y4YzMzNWQwY2FmNDdmMTZkMzE0MTNmODlhYTI4ZWRhMzg3OGUzYWEvbGliL3V0aWwuanNcblxudmFyIGdldE5hbWUgPSByZXF1aXJlKCcuL2dldE5hbWUnKTtcbnZhciBnZXRQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9nZXRQcm9wZXJ0aWVzJyk7XG52YXIgZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2dldEVudW1lcmFibGVQcm9wZXJ0aWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zcGVjdDtcblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtCb29sZWFufSBzaG93SGlkZGVuIEZsYWcgdGhhdCBzaG93cyBoaWRkZW4gKG5vdCBlbnVtZXJhYmxlKVxuICogICAgcHJvcGVydGllcyBvZiBvYmplY3RzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIERlcHRoIGluIHdoaWNoIHRvIGRlc2NlbmQgaW4gb2JqZWN0LiBEZWZhdWx0IGlzIDIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbG9ycyBGbGFnIHRvIHR1cm4gb24gQU5TSSBlc2NhcGUgY29kZXMgdG8gY29sb3IgdGhlXG4gKiAgICBvdXRwdXQuIERlZmF1bHQgaXMgZmFsc2UgKG5vIGNvbG9yaW5nKS5cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGluc3BlY3RcbiAqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMpIHtcbiAgdmFyIGN0eCA9IHtcbiAgICBzaG93SGlkZGVuOiBzaG93SGlkZGVuLFxuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0cjsgfVxuICB9O1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnID8gMiA6IGRlcHRoKSk7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgYSBET00gZWxlbWVudC5cbnZhciBpc0RPTUVsZW1lbnQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmplY3QgJiZcbiAgICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3Qubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzKTtcbiAgICBpZiAodHlwZW9mIHJldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBJZiB0aGlzIGlzIGEgRE9NIGVsZW1lbnQsIHRyeSB0byBnZXQgdGhlIG91dGVyIEhUTUwuXG4gIGlmIChpc0RPTUVsZW1lbnQodmFsdWUpKSB7XG4gICAgaWYgKCdvdXRlckhUTUwnIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUub3V0ZXJIVE1MO1xuICAgICAgLy8gVGhpcyB2YWx1ZSBkb2VzIG5vdCBoYXZlIGFuIG91dGVySFRNTCBhdHRyaWJ1dGUsXG4gICAgICAvLyAgIGl0IGNvdWxkIHN0aWxsIGJlIGFuIFhNTCBlbGVtZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0dGVtcHQgdG8gc2VyaWFsaXplIGl0XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZG9jdW1lbnQueG1sVmVyc2lvbikge1xuICAgICAgICAgIHZhciB4bWxTZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcbiAgICAgICAgICByZXR1cm4geG1sU2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRmlyZWZveCAxMS0gZG8gbm90IHN1cHBvcnQgb3V0ZXJIVE1MXG4gICAgICAgICAgLy8gICBJdCBkb2VzLCBob3dldmVyLCBzdXBwb3J0IGlubmVySFRNTFxuICAgICAgICAgIC8vICAgVXNlIHRoZSBmb2xsb3dpbmcgdG8gcmVuZGVyIHRoZSBlbGVtZW50XG4gICAgICAgICAgdmFyIG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgJ18nKTtcblxuICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpKTtcbiAgICAgICAgICBodG1sID0gY29udGFpbmVyLmlubmVySFRNTFxuICAgICAgICAgICAgLnJlcGxhY2UoJz48JywgJz4nICsgdmFsdWUuaW5uZXJIVE1MICsgJzwnKTtcbiAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGEgbm9uLW5hdGl2ZSBET00gaW1wbGVtZW50YXRpb24sXG4gICAgICAgIC8vICAgY29udGludWUgd2l0aCB0aGUgbm9ybWFsIGZsb3c6XG4gICAgICAgIC8vICAgcHJpbnRpbmcgdGhlIGVsZW1lbnQgYXMgaWYgaXQgaXMgYW4gb2JqZWN0LlxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIHZpc2libGVLZXlzID0gZ2V0RW51bWVyYWJsZVByb3BlcnRpZXModmFsdWUpO1xuICB2YXIga2V5cyA9IGN0eC5zaG93SGlkZGVuID8gZ2V0UHJvcGVydGllcyh2YWx1ZSkgOiB2aXNpYmxlS2V5cztcblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIC8vIEluIElFLCBlcnJvcnMgaGF2ZSBhIHNpbmdsZSBgc3RhY2tgIHByb3BlcnR5LCBvciBpZiB0aGV5IGFyZSB2YW5pbGxhIGBFcnJvcmAsXG4gIC8vIGEgYHN0YWNrYCBwbHVzIGBkZXNjcmlwdGlvbmAgcHJvcGVydHk7IGlnbm9yZSB0aG9zZSBmb3IgY29uc2lzdGVuY3kuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCB8fCAoaXNFcnJvcih2YWx1ZSkgJiYgKFxuICAgICAgKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICdzdGFjaycpIHx8XG4gICAgICAoa2V5cy5sZW5ndGggPT09IDIgJiYga2V5c1swXSA9PT0gJ2Rlc2NyaXB0aW9uJyAmJiBrZXlzWzFdID09PSAnc3RhY2snKVxuICAgICApKSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0TmFtZSh2YWx1ZSk7XG4gICAgICB2YXIgbmFtZVN1ZmZpeCA9IG5hbWUgPyAnOiAnICsgbmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZVN1ZmZpeCArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG5hbWUgPSBnZXROYW1lKHZhbHVlKTtcbiAgICB2YXIgbmFtZVN1ZmZpeCA9IG5hbWUgPyAnOiAnICsgbmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuYW1lU3VmZml4ICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKHZhbHVlID09PSAwICYmICgxL3ZhbHVlKSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnLTAnLCAnbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgfVxuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0cjtcbiAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18pIHtcbiAgICBpZiAodmFsdWUuX19sb29rdXBHZXR0ZXJfXyhrZXkpKSB7XG4gICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlLl9fbG9va3VwU2V0dGVyX18oa2V5KSkge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodmlzaWJsZUtleXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZih2YWx1ZVtrZXldKSA8IDApIHtcbiAgICAgIGlmIChyZWN1cnNlVGltZXMgPT09IG51bGwpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZVtrZXldLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgdmFsdWVba2V5XSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcikgfHxcbiAgICAgICAgICh0eXBlb2YgYXIgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKGFyKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiB0eXBlb2YgcmUgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiB0eXBlb2YgZCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXSc7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pbnNwZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCJcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIlxuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwianNvbi1wb2ludGVyXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwianNvbi1wb2ludGVyXCJcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBjb25zdCBTVEFSVCA9IFwiU0VTU0lPTl9TVEFSVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0KHR4SGFzaCwgcHJvdmlkZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTVEFSVCxcbiAgICB0eEhhc2gsIHByb3ZpZGVyXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRUFEWSA9IFwiU0VTU0lPTl9SRUFEWVwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWR5KCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFQURZLFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgRVJST1IgPSBcIlNFU1NJT05fRVJST1JcIjtcbmV4cG9ydCBmdW5jdGlvbiBlcnJvcihlcnJvcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEVSUk9SLFxuICAgIGVycm9yXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBGSU5JU0ggPSBcIlNFU1NJT05fRklOSVNIXCI7XG5leHBvcnQgZnVuY3Rpb24gZmluaXNoKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEZJTklTSCxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFQ09SRF9DT05UUkFDVFMgPSBcIlJFQ09SRF9DT05UUkFDVFNcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWNvcmRDb250cmFjdHMoY29udGV4dHMsIHNvdXJjZXMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUNPUkRfQ09OVFJBQ1RTLFxuICAgIGNvbnRleHRzLCBzb3VyY2VzXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc2Vzc2lvbi9hY3Rpb25zL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmRhdGE6c2VsZWN0b3JzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuaW1wb3J0IGpzb25wb2ludGVyIGZyb20gXCJqc29uLXBvaW50ZXJcIjtcblxuaW1wb3J0IGFzdCBmcm9tIFwibGliL2FzdC9zZWxlY3RvcnNcIjtcbmltcG9ydCBldm0gZnJvbSBcImxpYi9ldm0vc2VsZWN0b3JzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcblxuaW1wb3J0IGRlY29kZSBmcm9tIFwiLi4vZGVjb2RlXCI7XG5pbXBvcnQgKiBhcyBkZWNvZGVVdGlscyBmcm9tIFwiLi4vZGVjb2RlL3V0aWxzXCI7XG5cbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJiaWdudW1iZXIuanNcIjtcblxuZnVuY3Rpb24gY3JlYXRlU3RhdGVTZWxlY3RvcnMoeyBzdGFjaywgbWVtb3J5LCBzdG9yYWdlIH0pIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiAuc3RhY2tcbiAgICAgKi9cbiAgICBzdGFjazogY3JlYXRlTGVhZihcbiAgICAgIFtzdGFja10sXG5cbiAgICAgICh3b3JkcykgPT4gKHdvcmRzIHx8IFtdKS5tYXAoXG4gICAgICAgICh3b3JkKSA9PiBkZWNvZGVVdGlscy50b0J5dGVzKGRlY29kZVV0aWxzLnRvQmlnTnVtYmVyKHdvcmQsIGRlY29kZVV0aWxzLldPUkRfU0laRSkpXG4gICAgICApXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIC5tZW1vcnlcbiAgICAgKi9cbiAgICBtZW1vcnk6IGNyZWF0ZUxlYWYoXG4gICAgICBbbWVtb3J5XSxcblxuICAgICAgKHdvcmRzKSA9PiBuZXcgVWludDhBcnJheShcbiAgICAgICAgKHdvcmRzLmpvaW4oXCJcIikubWF0Y2goLy57MSwyfS9nKSB8fCBbXSlcbiAgICAgICAgICAubWFwKCAoYnl0ZSkgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpIClcbiAgICAgIClcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogLnN0b3JhZ2VcbiAgICAgKi9cbiAgICBzdG9yYWdlOiBjcmVhdGVMZWFmKFxuICAgICAgW3N0b3JhZ2VdLFxuXG4gICAgICAobWFwcGluZykgPT4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sIC4uLk9iamVjdC5lbnRyaWVzKG1hcHBpbmcpLm1hcCggKFsgYWRkcmVzcywgd29yZCBdKSA9PlxuICAgICAgICAgICh7XG4gICAgICAgICAgICBbYDB4JHthZGRyZXNzfWBdOiBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgICAgKHdvcmQubWF0Y2goLy57MSwyfS9nKSB8fCBbXSlcbiAgICAgICAgICAgICAgICAubWFwKCAoYnl0ZSkgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuICB9O1xufVxuXG5jb25zdCBkYXRhID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgc3RhdGU6IChzdGF0ZSkgPT4gc3RhdGUuZGF0YSxcblxuICAvKipcbiAgICogZGF0YS52aWV3c1xuICAgKi9cbiAgdmlld3M6IHtcbiAgICBhc3Q6IGNyZWF0ZUxlYWYoXG4gICAgICBbYXN0LmN1cnJlbnRdLCAodHJlZSkgPT4gdHJlZVxuICAgICksXG5cbiAgICBhdExhc3RJbnN0cnVjdGlvbkZvclNvdXJjZVJhbmdlOiBjcmVhdGVMZWFmKFxuICAgICAgW3NvbGlkaXR5LmN1cnJlbnQuaXNTb3VyY2VSYW5nZUZpbmFsXSwgKGZpbmFsKSA9PiBmaW5hbFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLnZpZXdzLnNjb3Blc1xuICAgICAqL1xuICAgIHNjb3Blczoge1xuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEudmlld3Muc2NvcGVzLmlubGluZWRcbiAgICAgICAqL1xuICAgICAgaW5saW5lZDogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiL2luZm8vc2NvcGVzXCIsIHNvbGlkaXR5LmluZm8uc291cmNlc10sXG5cbiAgICAgICAgKHNjb3Blcywgc291cmNlcykgPT4gT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhzY29wZXMpLm1hcChcbiAgICAgICAgICAgIChbaWQsIGVudHJ5XSkgPT4gKHtcbiAgICAgICAgICAgICAgW2lkXToge1xuICAgICAgICAgICAgICAgIC4uLmVudHJ5LFxuXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbjoganNvbnBvaW50ZXIuZ2V0KFxuICAgICAgICAgICAgICAgICAgc291cmNlc1tlbnRyeS5zb3VyY2VJZF0uYXN0LCBlbnRyeS5wb2ludGVyXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLnZpZXdzLmRlY29kZXJcbiAgICAgKlxuICAgICAqIHNlbGVjdG9yIHJldHVybnMgKGFzdCBub2RlIGRlZmluaXRpb24sIGRhdGEgcmVmZXJlbmNlKSA9PiB2YWx1ZVxuICAgICAqL1xuICAgIGRlY29kZXI6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIvdmlld3Mvc2NvcGVzL2lubGluZWRcIiwgXCIvY3VycmVudC9zdGF0ZVwiXSxcblxuICAgICAgKHNjb3Blcywgc3RhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChkZWZpbml0aW9uLCByZWYpID0+IGRlY29kZShkZWZpbml0aW9uLCByZWYsIHN0YXRlLCBzY29wZXMpXG4gICAgICB9XG4gICAgKVxuICB9LFxuXG4gIC8qKlxuICAgKiBkYXRhLmluZm9cbiAgICovXG4gIGluZm86IHtcblxuICAgIC8qKlxuICAgICAqIGRhdGEuaW5mby5zY29wZXNcbiAgICAgKi9cbiAgICBzY29wZXM6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCAoc3RhdGUpID0+IHN0YXRlLmluZm8uc2NvcGVzLmJ5SWQpXG4gIH0sXG5cbiAgLyoqXG4gICAqIGRhdGEucHJvY1xuICAgKi9cbiAgcHJvYzoge1xuXG4gICAgLyoqXG4gICAgICogZGF0YS5wcm9jLmFzc2lnbm1lbnRzXG4gICAgICovXG4gICAgYXNzaWdubWVudHM6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCAoc3RhdGUpID0+IHN0YXRlLnByb2MuYXNzaWdubWVudHMuYnlJZClcbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5jdXJyZW50XG4gICAqL1xuICBjdXJyZW50OiB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBkYXRhLmN1cnJlbnQuc2NvcGVcbiAgICAgKi9cbiAgICBzY29wZToge1xuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5zY29wZS5pZFxuICAgICAgICovXG4gICAgICBpZDogY3JlYXRlTGVhZihcbiAgICAgICAgW2FzdC5jdXJyZW50Lm5vZGVdLCAobm9kZSkgPT4gbm9kZS5pZFxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLmN1cnJlbnQuc3RhdGVcbiAgICAgKi9cbiAgICBzdGF0ZTogY3JlYXRlU3RhdGVTZWxlY3RvcnMoZXZtLmN1cnJlbnQuc3RhdGUpLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzIChuYW1lc3BhY2UpXG4gICAgICovXG4gICAgaWRlbnRpZmllcnM6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMgKHNlbGVjdG9yKVxuICAgICAgICpcbiAgICAgICAqIHJldHVybnMgaWRlbnRpZmVycyBhbmQgY29ycmVzcG9uZGluZyBkZWZpbml0aW9uIG5vZGUgSURcbiAgICAgICAqL1xuICAgICAgXzogY3JlYXRlTGVhZihcbiAgICAgICAgW1xuICAgICAgICAgIFwiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkXCIsXG4gICAgICAgICAgXCIvY3VycmVudC9zY29wZVwiLFxuICAgICAgICBdLFxuXG4gICAgICAgIChzY29wZXMsIHNjb3BlKSA9PiB7XG4gICAgICAgICAgbGV0IGN1ciA9IHNjb3BlLmlkO1xuICAgICAgICAgIGxldCB2YXJpYWJsZXMgPSB7fTtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhcmlhYmxlcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgLi4uKHNjb3Blc1tjdXJdLnZhcmlhYmxlcyB8fCBbXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCAodikgPT4gdmFyaWFibGVzW3YubmFtZV0gPT0gdW5kZWZpbmVkIClcbiAgICAgICAgICAgICAgICAubWFwKCAodikgPT4gKHsgW3YubmFtZV06IHYuaWQgfSkgKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY3VyID0gc2NvcGVzW2N1cl0ucGFyZW50SWQ7XG4gICAgICAgICAgfSB3aGlsZSAoY3VyICE9IG51bGwpO1xuXG4gICAgICAgICAgcmV0dXJuIHZhcmlhYmxlcztcbiAgICAgICAgfVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMuZGVmaW5pdGlvbnNcbiAgICAgICAqXG4gICAgICAgKiBjdXJyZW50IHZhcmlhYmxlIGRlZmluaXRpb25zXG4gICAgICAgKi9cbiAgICAgIGRlZmluaXRpb25zOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXG4gICAgICAgICAgXCIvdmlld3Mvc2NvcGVzL2lubGluZWRcIixcbiAgICAgICAgICBcIi4vX1wiXG4gICAgICAgIF0sXG5cbiAgICAgICAgKHNjb3BlcywgaWRlbnRpZmllcnMpID0+IE9iamVjdC5hc3NpZ24oe30sXG4gICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMoaWRlbnRpZmllcnMpXG4gICAgICAgICAgICAubWFwKCAoW2lkZW50aWZpZXIsIGlkXSkgPT4ge1xuICAgICAgICAgICAgICBsZXQgeyBkZWZpbml0aW9uIH0gPSBzY29wZXNbaWRdO1xuXG4gICAgICAgICAgICAgIHJldHVybiB7IFtpZGVudGlmaWVyXTogZGVmaW5pdGlvbiB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMucmVmc1xuICAgICAgICpcbiAgICAgICAqIGN1cnJlbnQgdmFyaWFibGVzJyB2YWx1ZSByZWZzXG4gICAgICAgKi9cbiAgICAgIHJlZnM6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcbiAgICAgICAgICBcIi9wcm9jL2Fzc2lnbm1lbnRzXCIsXG4gICAgICAgICAgXCIuL19cIlxuICAgICAgICBdLFxuXG4gICAgICAgIChhc3NpZ25tZW50cywgaWRlbnRpZmllcnMpID0+IE9iamVjdC5hc3NpZ24oe30sXG4gICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMoaWRlbnRpZmllcnMpXG4gICAgICAgICAgICAubWFwKCAoW2lkZW50aWZpZXIsIGlkXSkgPT4ge1xuICAgICAgICAgICAgICBsZXQgeyByZWYgfSA9IChhc3NpZ25tZW50c1tpZF0gfHwge30pXG4gICAgICAgICAgICAgIGlmICghcmVmKSB7IHJldHVybiB1bmRlZmluZWQgfTtcblxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFtpZGVudGlmaWVyXTogcmVmXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApLFxuXG4gICAgICBkZWNvZGVkOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXG4gICAgICAgICAgXCIvdmlld3MvZGVjb2RlclwiLFxuICAgICAgICAgIFwiLi9kZWZpbml0aW9uc1wiLFxuICAgICAgICAgIFwiLi9yZWZzXCIsXG4gICAgICAgIF0sXG5cbiAgICAgICAgKGRlY29kZSwgZGVmaW5pdGlvbnMsIHJlZnMpID0+IE9iamVjdC5hc3NpZ24oe30sXG4gICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMocmVmcylcbiAgICAgICAgICAgIC5tYXAoIChbaWRlbnRpZmllciwgcmVmXSkgPT4gKHtcbiAgICAgICAgICAgICAgW2lkZW50aWZpZXJdOiBkZWNvZGUoZGVmaW5pdGlvbnNbaWRlbnRpZmllcl0sIHJlZilcbiAgICAgICAgICAgIH0pIClcbiAgICAgICAgKVxuICAgICAgKSxcblxuICAgICAgbmF0aXZlOiBjcmVhdGVMZWFmKFsnLi9kZWNvZGVkJ10sIGRlY29kZVV0aWxzLmNsZWFuQmlnTnVtYmVycylcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGRhdGEubmV4dFxuICAgKi9cbiAgbmV4dDoge1xuXG4gICAgLyoqXG4gICAgICogZGF0YS5uZXh0LnN0YXRlXG4gICAgICovXG4gICAgc3RhdGU6IGNyZWF0ZVN0YXRlU2VsZWN0b3JzKGV2bS5uZXh0LnN0YXRlKVxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZGF0YTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGF0YS9zZWxlY3RvcnMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldFwiXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGFzc2VydGlvbi1lcnJvclxuICogQ29weXJpZ2h0KGMpIDIwMTMgSmFrZSBMdWVyIDxqYWtlQHF1YWxpYW5jeS5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogb25lIG9iamVjdCB0byBhbm90aGVyIGV4Y2x1ZGluZyBhbnkgb3JpZ2luYWxseVxuICogbGlzdGVkLiBSZXR1cm5lZCBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBhIG5ldyBge31gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleGNsdWRlZCBwcm9wZXJ0aWVzIC4uLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gZXhjbHVkZSAoKSB7XG4gIHZhciBleGNsdWRlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBmdW5jdGlvbiBleGNsdWRlUHJvcHMgKHJlcywgb2JqKSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghfmV4Y2x1ZGVzLmluZGV4T2Yoa2V5KSkgcmVzW2tleV0gPSBvYmpba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBleHRlbmRFeGNsdWRlICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgLCBpID0gMFxuICAgICAgLCByZXMgPSB7fTtcblxuICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhjbHVkZVByb3BzKHJlcywgYXJnc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8qIVxuICogUHJpbWFyeSBFeHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqXG4gKiAjIyMgQXNzZXJ0aW9uRXJyb3JcbiAqXG4gKiBBbiBleHRlbnNpb24gb2YgdGhlIEphdmFTY3JpcHQgYEVycm9yYCBjb25zdHJ1Y3RvciBmb3JcbiAqIGFzc2VydGlvbiBhbmQgdmFsaWRhdGlvbiBzY2VuYXJpb3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgKG9wdGlvbmFsKVxuICogQHBhcmFtIHtjYWxsZWV9IHN0YXJ0IHN0YWNrIGZ1bmN0aW9uIChvcHRpb25hbClcbiAqL1xuXG5mdW5jdGlvbiBBc3NlcnRpb25FcnJvciAobWVzc2FnZSwgX3Byb3BzLCBzc2YpIHtcbiAgdmFyIGV4dGVuZCA9IGV4Y2x1ZGUoJ25hbWUnLCAnbWVzc2FnZScsICdzdGFjaycsICdjb25zdHJ1Y3RvcicsICd0b0pTT04nKVxuICAgICwgcHJvcHMgPSBleHRlbmQoX3Byb3BzIHx8IHt9KTtcblxuICAvLyBkZWZhdWx0IHZhbHVlc1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdVbnNwZWNpZmllZCBBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuc2hvd0RpZmYgPSBmYWxzZTtcblxuICAvLyBjb3B5IGZyb20gcHJvcGVydGllc1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB0aGlzW2tleV0gPSBwcm9wc1trZXldO1xuICB9XG5cbiAgLy8gY2FwdHVyZSBzdGFjayB0cmFjZVxuICBzc2YgPSBzc2YgfHwgQXNzZXJ0aW9uRXJyb3I7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHNzZik7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgdGhpcy5zdGFjayA9IGUuc3RhY2s7XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIEVycm9yLnByb3RvdHlwZVxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblxuLyohXG4gKiBTdGF0aWNhbGx5IHNldCBuYW1lXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuXG4vKiFcbiAqIEVuc3VyZSBjb3JyZWN0IGNvbnN0cnVjdG9yXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXNzZXJ0aW9uRXJyb3I7XG5cbi8qKlxuICogQWxsb3cgZXJyb3JzIHRvIGJlIGNvbnZlcnRlZCB0byBKU09OIGZvciBzdGF0aWMgdHJhbnNmZXIuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlIHN0YWNrIChkZWZhdWx0OiBgdHJ1ZWApXG4gKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB0aGF0IGNhbiBiZSBgSlNPTi5zdHJpbmdpZnlgXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChzdGFjaykge1xuICB2YXIgZXh0ZW5kID0gZXhjbHVkZSgnY29uc3RydWN0b3InLCAndG9KU09OJywgJ3N0YWNrJylcbiAgICAsIHByb3BzID0gZXh0ZW5kKHsgbmFtZTogdGhpcy5uYW1lIH0sIHRoaXMpO1xuXG4gIC8vIGluY2x1ZGUgc3RhY2sgaWYgZXhpc3RzIGFuZCBub3QgdHVybmVkIG9mZlxuICBpZiAoZmFsc2UgIT09IHN0YWNrICYmIHRoaXMuc3RhY2spIHtcbiAgICBwcm9wcy5zdGFjayA9IHRoaXMuc3RhY2s7XG4gIH1cblxuICByZXR1cm4gcHJvcHM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9hc3NlcnRpb24tZXJyb3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogQ2hhaSAtIGdldEFjdHVhbCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIGdldEFjdHVhbChvYmplY3QsIFthY3R1YWxdKVxuICpcbiAqIFJldHVybnMgdGhlIGBhY3R1YWxgIHZhbHVlIGZvciBhbiBBc3NlcnRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb24pXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCBhcmd1bWVudHNcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldEFjdHVhbFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgYXJncykge1xuICByZXR1cm4gYXJncy5sZW5ndGggPiA0ID8gYXJnc1s0XSA6IG9iai5fb2JqO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRBY3R1YWwuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogQ2hhaSAtIGdldE5hbWUgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyBnZXROYW1lKGZ1bmMpXG4gKlxuICogR2V0cyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uLCBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGEgZnVuY3Rpb24gKHVzdWFsbHkgYSBjb25zdHJ1Y3RvcilcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldE5hbWVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIGlmIChmdW5jLm5hbWUpIHJldHVybiBmdW5jLm5hbWU7XG5cbiAgdmFyIG1hdGNoID0gL15cXHM/ZnVuY3Rpb24gKFteKF0qKVxcKC8uZXhlYyhmdW5jKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdID8gbWF0Y2hbMV0gOiBcIlwiO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXROYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIENoYWkgLSBmbGFnIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRhbmNpZXNcbiAqL1xuXG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4vKipcbiAqICMjIyAub2JqRGlzcGxheSAob2JqZWN0KVxuICpcbiAqIERldGVybWluZXMgaWYgYW4gb2JqZWN0IG9yIGFuIGFycmF5IG1hdGNoZXNcbiAqIGNyaXRlcmlhIHRvIGJlIGluc3BlY3RlZCBpbi1saW5lIGZvciBlcnJvclxuICogbWVzc2FnZXMgb3Igc2hvdWxkIGJlIHRydW5jYXRlZC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBqYXZhc2NyaXB0IG9iamVjdCB0byBpbnNwZWN0XG4gKiBAbmFtZSBvYmpEaXNwbGF5XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc3RyID0gaW5zcGVjdChvYmopXG4gICAgLCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG5cbiAgaWYgKGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCAmJiBzdHIubGVuZ3RoID49IGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCkge1xuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICByZXR1cm4gIW9iai5uYW1lIHx8IG9iai5uYW1lID09PSAnJ1xuICAgICAgICA/ICdbRnVuY3Rpb25dJ1xuICAgICAgICA6ICdbRnVuY3Rpb246ICcgKyBvYmoubmFtZSArICddJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybiAnWyBBcnJheSgnICsgb2JqLmxlbmd0aCArICcpIF0nO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKVxuICAgICAgICAsIGtzdHIgPSBrZXlzLmxlbmd0aCA+IDJcbiAgICAgICAgICA/IGtleXMuc3BsaWNlKDAsIDIpLmpvaW4oJywgJykgKyAnLCAuLi4nXG4gICAgICAgICAgOiBrZXlzLmpvaW4oJywgJyk7XG4gICAgICByZXR1cm4gJ3sgT2JqZWN0ICgnICsga3N0ciArICcpIH0nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL29iakRpc3BsYXkuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogQ2hhaSAtIHRyYW5zZmVyRmxhZ3MgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIHRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBvYmplY3QsIGluY2x1ZGVBbGwgPSB0cnVlKVxuICpcbiAqIFRyYW5zZmVyIGFsbCB0aGUgZmxhZ3MgZm9yIGBhc3NlcnRpb25gIHRvIGBvYmplY3RgLiBJZlxuICogYGluY2x1ZGVBbGxgIGlzIHNldCB0byBgZmFsc2VgLCB0aGVuIHRoZSBiYXNlIENoYWlcbiAqIGFzc2VydGlvbiBmbGFncyAobmFtZWx5IGBvYmplY3RgLCBgc3NmaWAsIGFuZCBgbWVzc2FnZWApXG4gKiB3aWxsIG5vdCBiZSB0cmFuc2ZlcnJlZC5cbiAqXG4gKlxuICogICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgQXNzZXJ0aW9uKCk7XG4gKiAgICAgdXRpbHMudHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIG5ld0Fzc2VydGlvbik7XG4gKlxuICogICAgIHZhciBhbm90aGVyQXNzZXJpdG9uID0gbmV3IEFzc2VydGlvbihteU9iaik7XG4gKiAgICAgdXRpbHMudHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIGFub3RoZXJBc3NlcnRpb24sIGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Fzc2VydGlvbn0gYXNzZXJ0aW9uIHRoZSBhc3NlcnRpb24gdG8gdHJhbnNmZXIgdGhlIGZsYWdzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdGhlIG9iamVjdCB0byB0cmFuc2ZlciB0aGUgZmxhZ3MgdG87IHVzdWFsbHkgYSBuZXcgYXNzZXJ0aW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGVBbGxcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIHRyYW5zZmVyRmxhZ3NcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFzc2VydGlvbiwgb2JqZWN0LCBpbmNsdWRlQWxsKSB7XG4gIHZhciBmbGFncyA9IGFzc2VydGlvbi5fX2ZsYWdzIHx8IChhc3NlcnRpb24uX19mbGFncyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG4gIGlmICghb2JqZWN0Ll9fZmxhZ3MpIHtcbiAgICBvYmplY3QuX19mbGFncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBpbmNsdWRlQWxsID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMyA/IGluY2x1ZGVBbGwgOiB0cnVlO1xuXG4gIGZvciAodmFyIGZsYWcgaW4gZmxhZ3MpIHtcbiAgICBpZiAoaW5jbHVkZUFsbCB8fFxuICAgICAgICAoZmxhZyAhPT0gJ29iamVjdCcgJiYgZmxhZyAhPT0gJ3NzZmknICYmIGZsYWcgIT0gJ21lc3NhZ2UnKSkge1xuICAgICAgb2JqZWN0Ll9fZmxhZ3NbZmxhZ10gPSBmbGFnc1tmbGFnXTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvdHJhbnNmZXJGbGFncy5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBDaGFpIC0gZ2V0UGF0aEluZm8gdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBoYXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vaGFzUHJvcGVydHknKTtcblxuLyoqXG4gKiAjIyMgLmdldFBhdGhJbmZvKHBhdGgsIG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIHByb3BlcnR5IGluZm8gaW4gYW5cbiAqIG9iamVjdCBnaXZlbiBhIHN0cmluZyBwYXRoLlxuICpcbiAqIFRoZSBwYXRoIGluZm8gY29uc2lzdHMgb2YgYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAqIHBhcmVudCAtIFRoZSBwYXJlbnQgb2JqZWN0IG9mIHRoZSBwcm9wZXJ0eSByZWZlcmVuY2VkIGJ5IGBwYXRoYFxuICogKiBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZpbmFsIHByb3BlcnR5LCBhIG51bWJlciBpZiBpdCB3YXMgYW4gYXJyYXkgaW5kZXhlclxuICogKiB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHksIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKiAqIGV4aXN0cyAtIFdoZXRoZXIgdGhlIHByb3BlcnR5IGV4aXN0cyBvciBub3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gaW5mb1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0UGF0aEluZm9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQYXRoSW5mbyhwYXRoLCBvYmopIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aChwYXRoKSxcbiAgICAgIGxhc3QgPSBwYXJzZWRbcGFyc2VkLmxlbmd0aCAtIDFdO1xuXG4gIHZhciBpbmZvID0ge1xuICAgIHBhcmVudDogcGFyc2VkLmxlbmd0aCA+IDEgPyBfZ2V0UGF0aFZhbHVlKHBhcnNlZCwgb2JqLCBwYXJzZWQubGVuZ3RoIC0gMSkgOiBvYmosXG4gICAgbmFtZTogbGFzdC5wIHx8IGxhc3QuaSxcbiAgICB2YWx1ZTogX2dldFBhdGhWYWx1ZShwYXJzZWQsIG9iailcbiAgfTtcbiAgaW5mby5leGlzdHMgPSBoYXNQcm9wZXJ0eShpbmZvLm5hbWUsIGluZm8ucGFyZW50KTtcblxuICByZXR1cm4gaW5mbztcbn07XG5cblxuLyohXG4gKiAjIyBwYXJzZVBhdGgocGF0aClcbiAqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCB0byBwYXJzZSBzdHJpbmcgb2JqZWN0XG4gKiBwYXRocy4gVXNlIGluIGNvbmp1bmN0aW9uIHdpdGggYF9nZXRQYXRoVmFsdWVgLlxuICpcbiAqICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aCgnbXlvYmplY3QucHJvcGVydHkuc3VicHJvcCcpO1xuICpcbiAqICMjIyBQYXRoczpcbiAqXG4gKiAqIENhbiBiZSBhcyBuZWFyIGluZmluaXRlbHkgZGVlcCBhbmQgbmVzdGVkXG4gKiAqIEFycmF5cyBhcmUgYWxzbyB2YWxpZCB1c2luZyB0aGUgZm9ybWFsIGBteW9iamVjdC5kb2N1bWVudFszXS5wcm9wZXJ0eWAuXG4gKiAqIExpdGVyYWwgZG90cyBhbmQgYnJhY2tldHMgKG5vdCBkZWxpbWl0ZXIpIG11c3QgYmUgYmFja3NsYXNoLWVzY2FwZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBhcnNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIHZhciBzdHIgPSBwYXRoLnJlcGxhY2UoLyhbXlxcXFxdKVxcWy9nLCAnJDEuWycpXG4gICAgLCBwYXJ0cyA9IHN0ci5tYXRjaCgvKFxcXFxcXC58W14uXSs/KSsvZyk7XG4gIHJldHVybiBwYXJ0cy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJlID0gL15cXFsoXFxkKylcXF0kL1xuICAgICAgLCBtQXJyID0gcmUuZXhlYyh2YWx1ZSk7XG4gICAgaWYgKG1BcnIpIHJldHVybiB7IGk6IHBhcnNlRmxvYXQobUFyclsxXSkgfTtcbiAgICBlbHNlIHJldHVybiB7IHA6IHZhbHVlLnJlcGxhY2UoL1xcXFwoWy5cXFtcXF1dKS9nLCAnJDEnKSB9O1xuICB9KTtcbn1cblxuXG4vKiFcbiAqICMjIF9nZXRQYXRoVmFsdWUocGFyc2VkLCBvYmopXG4gKlxuICogSGVscGVyIGNvbXBhbmlvbiBmdW5jdGlvbiBmb3IgYC5wYXJzZVBhdGhgIHRoYXQgcmV0dXJuc1xuICogdGhlIHZhbHVlIGxvY2F0ZWQgYXQgdGhlIHBhcnNlZCBhZGRyZXNzLlxuICpcbiAqICAgICAgdmFyIHZhbHVlID0gZ2V0UGF0aFZhbHVlKHBhcnNlZCwgb2JqKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyc2VkIGRlZmluaXRpb24gZnJvbSBgcGFyc2VQYXRoYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gc2VhcmNoIGFnYWluc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBvYmplY3QgdG8gc2VhcmNoIGFnYWluc3RcbiAqIEByZXR1cm5zIHtPYmplY3R8VW5kZWZpbmVkfSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX2dldFBhdGhWYWx1ZSAocGFyc2VkLCBvYmosIGluZGV4KSB7XG4gIHZhciB0bXAgPSBvYmpcbiAgICAsIHJlcztcblxuICBpbmRleCA9IChpbmRleCA9PT0gdW5kZWZpbmVkID8gcGFyc2VkLmxlbmd0aCA6IGluZGV4KTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGluZGV4OyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJzZWRbaV07XG4gICAgaWYgKHRtcCkge1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgcGFydC5wKVxuICAgICAgICB0bXAgPSB0bXBbcGFydC5wXTtcbiAgICAgIGVsc2UgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgcGFydC5pKVxuICAgICAgICB0bXAgPSB0bXBbcGFydC5pXTtcbiAgICAgIGlmIChpID09IChsIC0gMSkpIHJlcyA9IHRtcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldFBhdGhJbmZvLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIENoYWkgLSBoYXNQcm9wZXJ0eSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpO1xuXG4vKipcbiAqICMjIyAuaGFzUHJvcGVydHkob2JqZWN0LCBuYW1lKVxuICpcbiAqIFRoaXMgYWxsb3dzIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhc1xuICogbmFtZWQgcHJvcGVydHkgb3IgbnVtZXJpYyBhcnJheSBpbmRleC5cbiAqXG4gKiBCYXNpY2FsbHkgZG9lcyB0aGUgc2FtZSB0aGluZyBhcyB0aGUgYGluYFxuICogb3BlcmF0b3IgYnV0IHdvcmtzIHByb3Blcmx5IHdpdGggbmF0aXZlc1xuICogYW5kIG51bGwvdW5kZWZpbmVkIHZhbHVlcy5cbiAqXG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgYXJyOiBbJ2EnLCAnYicsICdjJ11cbiAqICAgICAgICwgc3RyOiAnSGVsbG8nXG4gKiAgICAgfVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgd291bGQgYmUgdGhlIHJlc3VsdHMuXG4gKlxuICogICAgIGhhc1Byb3BlcnR5KCdzdHInLCBvYmopOyAgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KCdjb25zdHJ1Y3RvcicsIG9iaik7ICAvLyB0cnVlXG4gKiAgICAgaGFzUHJvcGVydHkoJ2JhcicsIG9iaik7ICAvLyBmYWxzZVxuICpcbiAqICAgICBoYXNQcm9wZXJ0eSgnbGVuZ3RoJywgb2JqLnN0cik7IC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eSgxLCBvYmouc3RyKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eSg1LCBvYmouc3RyKTsgIC8vIGZhbHNlXG4gKlxuICogICAgIGhhc1Byb3BlcnR5KCdsZW5ndGgnLCBvYmouYXJyKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eSgyLCBvYmouYXJyKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eSgzLCBvYmouYXJyKTsgIC8vIGZhbHNlXG4gKlxuICogQHBhcmFtIHtPYmp1ZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59IHdoZXRoZXIgaXQgZXhpc3RzXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXRQYXRoSW5mb1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgbGl0ZXJhbHMgPSB7XG4gICAgJ251bWJlcic6IE51bWJlclxuICAsICdzdHJpbmcnOiBTdHJpbmdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzUHJvcGVydHkobmFtZSwgb2JqKSB7XG4gIHZhciBvdCA9IHR5cGUob2JqKTtcblxuICAvLyBCYWQgT2JqZWN0LCBvYnZpb3VzbHkgbm8gcHJvcHMgYXQgYWxsXG4gIGlmKG90ID09PSAnbnVsbCcgfHwgb3QgPT09ICd1bmRlZmluZWQnKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBUaGUgYGluYCBvcGVyYXRvciBkb2VzIG5vdCB3b3JrIHdpdGggY2VydGFpbiBsaXRlcmFsc1xuICAvLyBib3ggdGhlc2UgYmVmb3JlIHRoZSBjaGVja1xuICBpZihsaXRlcmFsc1tvdF0gJiYgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgb2JqID0gbmV3IGxpdGVyYWxzW290XShvYmopO1xuXG4gIHJldHVybiBuYW1lIGluIG9iajtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvaGFzUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtZXhwZWN0XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHJ1ZmZsZS1leHBlY3RcIlxuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2ZcIlxuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmFzdDptYXBcIik7XG5cbmltcG9ydCBJbnRlcnZhbFRyZWUgZnJvbSBcIm5vZGUtaW50ZXJ2YWwtdHJlZVwiO1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmdlKG5vZGUpIHtcbiAgLy8gc3JjOiBcIjxzdGFydD46PGxlbmd0aD46PF8+XCJcbiAgLy8gcmV0dXJucyBbc3RhcnQsIGVuZF1cbiAgbGV0IFtzdGFydCwgbGVuZ3RoXSA9IG5vZGUuc3JjXG4gICAgLnNwbGl0KFwiOlwiKVxuICAgIC5zbGljZSgwLCAyKVxuICAgIC5tYXAoIChpKSA9PiBwYXJzZUludChpKSApO1xuXG4gIHJldHVybiBbc3RhcnQsIHN0YXJ0ICsgbGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2VOb2Rlcyhub2RlLCBwb2ludGVyID0gXCJcIikge1xuICBpZiAobm9kZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChcbiAgICAgIC4uLm5vZGUubWFwKCAoc3ViLCBpKSA9PiByYW5nZU5vZGVzKHN1YiwgYCR7cG9pbnRlcn0vJHtpfWApIClcbiAgICApO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgaWYgKG5vZGUuc3JjKSB7XG4gICAgICByZXN1bHRzLnB1c2goe3BvaW50ZXIsIHJhbmdlOiBnZXRSYW5nZShub2RlKX0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzLmNvbmNhdChcbiAgICAgIC4uLk9iamVjdC5rZXlzKG5vZGUpLm1hcChcbiAgICAgICAgKGtleSkgPT4gcmFuZ2VOb2Rlcyhub2RlW2tleV0sIGAke3BvaW50ZXJ9LyR7a2V5fWApXG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZFJhbmdlKG5vZGUsIHNvdXJjZVN0YXJ0LCBzb3VyY2VMZW5ndGgpIHtcbiAgbGV0IHJhbmdlcyA9IHJhbmdlTm9kZXMobm9kZSk7XG4gIGxldCB0cmVlID0gbmV3IEludGVydmFsVHJlZSgpO1xuXG4gIHJhbmdlcy5mb3JFYWNoKCAoe3JhbmdlLCBwb2ludGVyfSkgPT4ge1xuICAgIGxldCBbc3RhcnQsIGVuZF0gPSByYW5nZTtcblxuICAgIHRyZWUuaW5zZXJ0KHN0YXJ0LCBlbmQsIHtyYW5nZSwgcG9pbnRlcn0pO1xuICB9KTtcblxuICBsZXQgc291cmNlRW5kID0gc291cmNlU3RhcnQgKyBzb3VyY2VMZW5ndGg7XG5cbiAgbGV0IG92ZXJsYXBwaW5nID0gdHJlZS5zZWFyY2goc291cmNlU3RhcnQsIHNvdXJjZUVuZCk7XG5cbiAgLy8gZmluZCBub2RlcyB0aGF0IGZ1bGx5IGNvbnRhaW4gcmVxdWVzdGVkIHJhbmdlLFxuICAvLyByZXR1cm4gbG9uZ2VzdCBwb2ludGVyXG4gIHJldHVybiBvdmVybGFwcGluZ1xuICAgIC5maWx0ZXIoICh7cmFuZ2V9KSA9PiBzb3VyY2VTdGFydCA+PSByYW5nZVswXSAmJiBzb3VyY2VFbmQgPD0gcmFuZ2VbMV0gKVxuICAgIC5tYXAoICh7cG9pbnRlcn0pID0+IHBvaW50ZXIgKVxuICAgIC5yZWR1Y2UoIChhLCBiKSA9PiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGIsIFwiXCIgKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvYXN0L21hcC5qcyIsImV4cG9ydCBjb25zdCBCRUdJTl9TVEVQID0gXCJCRUdJTl9TVEVQXCI7XG5leHBvcnQgZnVuY3Rpb24gYmVnaW5TdGVwKHR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBCRUdJTl9TVEVQLFxuICAgIHN0ZXBUeXBlOiB0eXBlXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBBRFZBTkNFID0gXCJBRFZBTkNFXCI7XG5leHBvcnQgZnVuY3Rpb24gYWR2YW5jZSgpIHtcbiAgcmV0dXJuIHt0eXBlOiBBRFZBTkNFfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNURVBfTkVYVCA9IFwiU1RFUF9ORVhUXCI7XG5leHBvcnQgZnVuY3Rpb24gc3RlcE5leHQoKSB7XG4gIHJldHVybiB7dHlwZTogU1RFUF9ORVhUfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNURVBfT1ZFUiA9IFwiU1RFUF9PVkVSXCI7XG5leHBvcnQgZnVuY3Rpb24gc3RlcE92ZXIoKSB7XG4gIHJldHVybiB7dHlwZTogU1RFUF9PVkVSfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNURVBfSU5UTyA9IFwiU1RFUF9JTlRPXCI7XG5leHBvcnQgZnVuY3Rpb24gc3RlcEludG8oKSB7XG4gIHJldHVybiB7dHlwZTogU1RFUF9JTlRPfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNURVBfT1VUID0gXCJTVEVQX09VVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBPdXQoKSB7XG4gIHJldHVybiB7dHlwZTogU1RFUF9PVVR9O1xufVxuXG5leHBvcnQgY29uc3QgSU5URVJSVVBUID0gXCJJTlRFUlJVUFRcIjtcbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnJ1cHQgKCkge1xuICByZXR1cm4ge3R5cGU6IElOVEVSUlVQVH07XG59XG5cblxuZXhwb3J0IGNvbnN0IENPTlRJTlVFX1VOVElMID0gXCJDT05USU5VRV9VTlRJTFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRpbnVlVW50aWwoLi4uYnJlYWtwb2ludHMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBDT05USU5VRV9VTlRJTCxcbiAgICBicmVha3BvaW50c1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9jb250cm9sbGVyL2FjdGlvbnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZGF0YTpzYWdhc1wiKTtcblxuaW1wb3J0IHsgcHV0LCB0YWtlRXZlcnksIHNlbGVjdCB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcbmltcG9ydCBqc29ucG9pbnRlciBmcm9tIFwianNvbi1wb2ludGVyXCI7XG5cbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0IHsgVElDSyB9IGZyb20gXCJsaWIvdHJhY2UvYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuXG5pbXBvcnQgZGF0YSBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cbmltcG9ydCB7IFdPUkRfU0laRSB9IGZyb20gXCJsaWIvZGF0YS9kZWNvZGUvdXRpbHNcIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCJsaWIvZGF0YS9kZWNvZGUvdXRpbHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uICpzY29wZShub2RlSWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5zY29wZShub2RlSWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gKmRlY2xhcmUobm9kZSkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5kZWNsYXJlKG5vZGUpKTtcbn1cblxuZnVuY3Rpb24gKnRpY2tTYWdhKCkge1xuICBsZXQge1xuICAgIHRyZWUsXG4gICAgaWQ6IHRyZWVJZCxcbiAgICBub2RlLFxuICAgIHBvaW50ZXJcbiAgfSA9IHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLmFzdCk7XG5cbiAgbGV0IHNjb3BlcyA9IHlpZWxkIHNlbGVjdChkYXRhLmluZm8uc2NvcGVzKTtcbiAgbGV0IGRlZmluaXRpb25zID0geWllbGQgc2VsZWN0KGRhdGEudmlld3Muc2NvcGVzLmlubGluZWQpO1xuXG4gIGxldCBzdGFjayA9IHlpZWxkIHNlbGVjdChkYXRhLm5leHQuc3RhdGUuc3RhY2spO1xuICBpZiAoIXN0YWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHRvcCA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gIHZhciBwYXJhbWV0ZXJzLCByZXR1cm5QYXJhbWV0ZXJzLCBhc3NpZ25tZW50cywgc3RvcmFnZVZhcnM7XG5cbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG5cbiAgICBjYXNlIFwiRnVuY3Rpb25EZWZpbml0aW9uXCI6XG4gICAgICAvLyBzdGFjayBpcyBvbmx5IHJlYWR5IGZvciBpbnRlcnByZXRhdGlvbiBhZnRlciB0aGUgbGFzdCBzdGVwIG9mIGVhY2hcbiAgICAgIC8vIHNvdXJjZSByYW5nZVxuICAgICAgLy9cbiAgICAgIC8vIHRoZSBkYXRhIG1vZHVsZSBhbHdheXMgbG9va3MgYXQgdGhlIHJlc3VsdCBvZiBhIHBhcnRpY3VsYXIgb3Bjb2RlXG4gICAgICAvLyAoaS5lLiwgdGhlIGZvbGxvd2luZyB0cmFjZSBzdGVwJ3Mgc3RhY2svbWVtb3J5L3N0b3JhZ2UpLCBzbyB0aGlzXG4gICAgICAvLyBhc3NlcnRzIHRoYXQgdGhlIF9jdXJyZW50XyBvcGVyYXRpb24gaXMgdGhlIGZpbmFsIG9uZSBiZWZvcmVcbiAgICAgIC8vIHByb2NlZWRpbmdcbiAgICAgIGlmICghKHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLmF0TGFzdEluc3RydWN0aW9uRm9yU291cmNlUmFuZ2UpKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcGFyYW1ldGVycyA9IG5vZGUucGFyYW1ldGVycy5wYXJhbWV0ZXJzXG4gICAgICAgIC5tYXAoIChwLCBpKSA9PiBgJHtwb2ludGVyfS9wYXJhbWV0ZXJzL3BhcmFtZXRlcnMvJHtpfWAgKTtcblxuICAgICAgcmV0dXJuUGFyYW1ldGVycyA9IG5vZGUucmV0dXJuUGFyYW1ldGVycy5wYXJhbWV0ZXJzXG4gICAgICAgIC5tYXAoIChwLCBpKSA9PiBgJHtwb2ludGVyfS9yZXR1cm5QYXJhbWV0ZXJzL3BhcmFtZXRlcnMvJHtpfWAgKTtcblxuICAgICAgYXNzaWdubWVudHMgPSByZXR1cm5QYXJhbWV0ZXJzLmNvbmNhdChwYXJhbWV0ZXJzKS5yZXZlcnNlKClcbiAgICAgICAgLm1hcCggKHBvaW50ZXIpID0+IGpzb25wb2ludGVyLmdldCh0cmVlLCBwb2ludGVyKS5pZCApXG4gICAgICAgIC5tYXAoIChpZCwgaSkgPT4gKHsgW2lkXToge1wic3RhY2tcIjogdG9wIC0gaX0gfSkgKVxuICAgICAgICAucmVkdWNlKCAoYWNjLCBhc3NpZ25tZW50KSA9PiBPYmplY3QuYXNzaWduKGFjYywgYXNzaWdubWVudCksIHt9ICk7XG5cbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmFzc2lnbih0cmVlSWQsIGFzc2lnbm1lbnRzKSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJDb250cmFjdERlZmluaXRpb25cIjpcbiAgICAgIGxldCBzdG9yYWdlVmFycyA9IHNjb3Blc1tub2RlLmlkXS52YXJpYWJsZXMgfHwgW107XG4gICAgICBsZXQgc2xvdCA9IDA7XG4gICAgICBsZXQgaW5kZXggPSBXT1JEX1NJWkUgLSAxOyAgLy8gY2F1c2UgbG93ZXItb3JkZXJcbiAgICAgIGRlYnVnKFwic3RvcmFnZSB2YXJzICVvXCIsIHN0b3JhZ2VWYXJzKTtcblxuICAgICAgbGV0IGFsbG9jYXRpb24gPSB1dGlscy5hbGxvY2F0ZURlY2xhcmF0aW9ucyhzdG9yYWdlVmFycywgZGVmaW5pdGlvbnMpO1xuICAgICAgYXNzaWdubWVudHMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSwgLi4uT2JqZWN0LmVudHJpZXMoYWxsb2NhdGlvbi5jaGlsZHJlbilcbiAgICAgICAgICAubWFwKCAoW2lkLCBzdG9yYWdlXSkgPT4gKHsgW2lkXToge3N0b3JhZ2V9IH0pIClcbiAgICAgICk7XG4gICAgICBkZWJ1ZyhcImFzc2lnbm1lbnRzICVPXCIsIGFzc2lnbm1lbnRzKTtcblxuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuYXNzaWduKHRyZWVJZCwgYXNzaWdubWVudHMpKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjpcbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmFzc2lnbih0cmVlSWQsIHtcbiAgICAgICAgW2pzb25wb2ludGVyLmdldCh0cmVlLCBwb2ludGVyKS5pZF06IHtcInN0YWNrXCI6IHRvcH1cbiAgICAgIH0pKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EgKCkge1xuICB5aWVsZCB0YWtlRXZlcnkoVElDSywgZnVuY3Rpb24qICgpIHtcbiAgICB0cnkge1xuICAgICAgeWllbGQgKnRpY2tTYWdhKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcImRhdGFcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvc2FnYXMvaW5kZXguanMiLCJleHBvcnQgY29uc3QgU0NPUEUgPSBcIlNDT1BFXCI7XG5leHBvcnQgZnVuY3Rpb24gc2NvcGUoaWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNDT1BFLFxuICAgIGlkLCBwb2ludGVyLCBwYXJlbnRJZCwgc291cmNlSWRcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgREVDTEFSRSA9IFwiREVDTEFSRV9WQVJJQUJMRVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY2xhcmUobm9kZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IERFQ0xBUkUsXG4gICAgbm9kZVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBBU1NJR04gPSBcIkFTU0lHTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihjb250ZXh0LCBhc3NpZ25tZW50cykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFTU0lHTixcbiAgICBjb250ZXh0LCBhc3NpZ25tZW50c1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kYXRhL2FjdGlvbnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6dHJhY2U6c2FnYXNcIik7XG5cbmltcG9ydCB7IHRha2UsIHRha2VFdmVyeSwgcHV0LCBzZWxlY3QgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5pbXBvcnQgeyBwcmVmaXhOYW1lIH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuaW1wb3J0IHRyYWNlIGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuZnVuY3Rpb24gKndhaXRGb3JUcmFjZSgpIHtcbiAgbGV0IHtzdGVwc30gPSB5aWVsZCB0YWtlKGFjdGlvbnMuU0FWRV9TVEVQUyk7XG5cbiAgbGV0IGFkZHJlc3NlcyA9IFtcbiAgICAuLi5uZXcgU2V0KFxuICAgICAgc3RlcHNcbiAgICAgICAgLmZpbHRlciggKHtvcH0pID0+IG9wID09IFwiQ0FMTFwiIHx8IG9wID09IFwiREVMRUdBVEVDQUxMXCIgKVxuICAgICAgICAubWFwKCAoe3N0YWNrfSkgPT4gXCIweFwiICsgc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0uc3Vic3RyaW5nKDI0KSApXG4gICAgKVxuICBdO1xuXG4gIHlpZWxkIHB1dChhY3Rpb25zLnJlY2VpdmVBZGRyZXNzZXMoYWRkcmVzc2VzKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAqYWR2YW5jZSgpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMubmV4dCgpKTtcblxuICB5aWVsZCB0YWtlKGFjdGlvbnMuVE9DSyk7XG59XG5cbmZ1bmN0aW9uKiBuZXh0KCkge1xuICBsZXQgcmVtYWluaW5nID0geWllbGQgc2VsZWN0KHRyYWNlLnN0ZXBzUmVtYWluaW5nKTtcbiAgZGVidWcoXCJyZW1haW5pbmc6ICVvXCIsIHJlbWFpbmluZyk7XG4gIGxldCBzdGVwcyA9IHlpZWxkIHNlbGVjdCh0cmFjZS5zdGVwcyk7XG4gIGRlYnVnKFwidG90YWwgc3RlcHM6ICVvXCIsIHN0ZXBzLmxlbmd0aCk7XG5cbiAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBkZWJ1ZyhcInB1dHRpbmcgVElDS1wiKTtcbiAgICAvLyB1cGRhdGVzIHN0YXRlIGZvciBjdXJyZW50IHN0ZXBcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy50aWNrKCkpO1xuICAgIGRlYnVnKFwicHV0IFRJQ0tcIik7XG5cbiAgICByZW1haW5pbmctLTsgLy8gbG9jYWwgdXBkYXRlLCBqdXN0IGZvciBjb252ZW5pZW5jZVxuICB9XG5cbiAgaWYgKHJlbWFpbmluZykge1xuICAgIGRlYnVnKFwicHV0dGluZyBUT0NLXCIpO1xuICAgIC8vIHVwZGF0ZXMgc3RlcCB0byBuZXh0IHN0ZXAgaW4gdHJhY2VcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy50b2NrKCkpO1xuICAgIGRlYnVnKFwicHV0IFRPQ0tcIik7XG5cbiAgfSBlbHNlIHtcblxuICAgIHlpZWxkIHB1dChhY3Rpb25zLmVuZFRyYWNlKCkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogd2FpdCgpIHtcbiAgeWllbGQgdGFrZShhY3Rpb25zLkVORF9PRl9UUkFDRSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAqcHJvY2Vzc1RyYWNlKHRyYWNlKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnNhdmVTdGVwcyh0cmFjZSkpO1xuXG4gIGxldCB7YWRkcmVzc2VzfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5SRUNFSVZFX0FERFJFU1NFUyk7XG4gIGRlYnVnKFwicmVjZWl2ZWQgYWRkcmVzc2VzXCIpO1xuXG4gIHJldHVybiBhZGRyZXNzZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgLy8gd2FpdCBmb3IgdHJhY2UgdG8gYmUgZGVmaW5lZFxuICB5aWVsZCAqd2FpdEZvclRyYWNlKCk7XG5cbiAgeWllbGQgdGFrZUV2ZXJ5KGFjdGlvbnMuTkVYVCwgbmV4dCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWZpeE5hbWUoXCJ0cmFjZVwiLCBzYWdhKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvdHJhY2Uvc2FnYXMvaW5kZXguanMiLCJleHBvcnQgY29uc3QgQUREX1NPVVJDRSA9IFwiU09MSURJVFlfQUREX1NPVVJDRVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFNvdXJjZShzb3VyY2UsIHNvdXJjZVBhdGgsIGFzdCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFERF9TT1VSQ0UsXG4gICAgc291cmNlLCBzb3VyY2VQYXRoLCBhc3RcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEFERF9TT1VSQ0VNQVAgPSBcIlNPTElESVRZX0FERF9TT1VSQ0VNQVBcIjtcbmV4cG9ydCBmdW5jdGlvbiBhZGRTb3VyY2VNYXAoYmluYXJ5LCBzb3VyY2VNYXApIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBRERfU09VUkNFTUFQLFxuICAgIGJpbmFyeSwgc291cmNlTWFwXG4gIH07XG59XG5cblxuZXhwb3J0IGNvbnN0IEpVTVAgPSBcIkpVTVBcIjtcbmV4cG9ydCBmdW5jdGlvbiBqdW1wKGp1bXBEaXJlY3Rpb24pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBKVU1QLFxuICAgIGp1bXBEaXJlY3Rpb25cbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc29saWRpdHkvYWN0aW9ucy9pbmRleC5qcyIsImV4cG9ydCBjb25zdCBBRERfQ09OVEVYVCA9IFwiRVZNX0FERF9DT05URVhUXCI7XG5leHBvcnQgZnVuY3Rpb24gYWRkQ29udGV4dChjb250cmFjdE5hbWUsIGJpbmFyeSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFERF9DT05URVhULFxuICAgIGNvbnRyYWN0TmFtZSwgYmluYXJ5XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEFERF9JTlNUQU5DRSA9IFwiRVZNX0FERF9JTlNUQU5DRVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEluc3RhbmNlKGFkZHJlc3MsIGNvbnRleHQsIGJpbmFyeSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFERF9JTlNUQU5DRSxcbiAgICBhZGRyZXNzLCBjb250ZXh0LCBiaW5hcnlcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ0FMTCA9IFwiQ0FMTFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGwoYWRkcmVzcykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IENBTEwsXG4gICAgYWRkcmVzc1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgQ1JFQVRFID0gXCJDUkVBVEVcIjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoYmluYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQ1JFQVRFLFxuICAgIGJpbmFyeVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVUVVJOID0gXCJSRVRVUk5cIjtcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5DYWxsKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFVFVSTlxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2V2bS9hY3Rpb25zL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNlc3Npb246c2VsZWN0b3JzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNvbGlkaXR5IGZyb20gXCJsaWIvc29saWRpdHkvc2VsZWN0b3JzXCI7XG5cbmNvbnN0IHNlc3Npb24gPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuICAvKipcbiAgICogc2Vzc2lvbi5pbmZvXG4gICAqL1xuICBpbmZvOiB7XG5cbiAgICAvKipcbiAgICAgKiBzZXNzaW9uLmluZm8uYWZmZWN0ZWRJbnN0YW5jZXNcbiAgICAgKi9cbiAgICBhZmZlY3RlZEluc3RhbmNlczogY3JlYXRlTGVhZihcbiAgICAgIFtldm0uaW5mby5pbnN0YW5jZXMsIGV2bS5pbmZvLmNvbnRleHRzLCBzb2xpZGl0eS5pbmZvLnNvdXJjZXMsIHNvbGlkaXR5LmluZm8uc291cmNlTWFwc10sXG5cbiAgICAgIChpbnN0YW5jZXMsIGNvbnRleHRzLCBzb3VyY2VzLCBzb3VyY2VNYXBzKSA9PiBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpbnN0YW5jZXMpLm1hcChcbiAgICAgICAgICAoW2FkZHJlc3MsIHtjb250ZXh0fV0pID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbnRyYWN0TmFtZSwgYmluYXJ5IH0gPSBjb250ZXh0c1tjb250ZXh0XTtcbiAgICAgICAgICAgIGxldCB7IHNvdXJjZU1hcCB9ID0gc291cmNlTWFwc1tjb250ZXh0XTtcblxuICAgICAgICAgICAgbGV0IHsgc291cmNlIH0gPSBzb3VyY2VNYXAgP1xuICAgICAgICAgICAgICAvLyBsb29rIGZvciBzb3VyY2UgSUQgYmV0d2VlbiBzZWNvbmQgYW5kIHRoaXJkIGNvbG9ucyAoSEFDSylcbiAgICAgICAgICAgICAgc291cmNlc1tzb3VyY2VNYXAubWF0Y2goL15bXjpdKzpbXjpdKzooW146XSspOi8pWzFdXSA6XG4gICAgICAgICAgICAgIHt9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBbYWRkcmVzc106IHtcbiAgICAgICAgICAgICAgICBjb250cmFjdE5hbWUsIHNvdXJjZSwgYmluYXJ5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc2Vzc2lvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc2Vzc2lvbi9zZWxlY3RvcnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwidGVzdDpkYXRhOmRlY29kZVwiKTtcblxuaW1wb3J0IEdhbmFjaGUgZnJvbSBcImdhbmFjaGUtY2xpXCI7XG5pbXBvcnQgV2ViMyBmcm9tIFwid2ViM1wiO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcImNoYWlcIjtcblxuaW1wb3J0IHsgcHJlcGFyZUNvbnRyYWN0cyB9IGZyb20gXCJ0ZXN0L2hlbHBlcnNcIjtcblxuaW1wb3J0IERlYnVnZ2VyIGZyb20gXCJsaWIvZGVidWdnZXJcIjtcblxuaW1wb3J0IHsgY2xlYW5CaWdOdW1iZXJzIH0gZnJvbSBcImxpYi9kYXRhL2RlY29kZS91dGlsc1wiO1xuXG5pbXBvcnQgZGF0YSBmcm9tIFwibGliL2RhdGEvc2VsZWN0b3JzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiAqZ2VuZXJhdGVVaW50cygpIHtcbiAgbGV0IHggPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHlpZWxkIHg7XG4gICAgeCsrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnRyYWN0TmFtZSh0ZXN0TmFtZSkge1xuICByZXR1cm4gdGVzdE5hbWUucmVwbGFjZSgvIC9nLCBcIlwiKTtcbn1cblxuZnVuY3Rpb24gZmlsZU5hbWUodGVzdE5hbWUpIHtcbiAgcmV0dXJuIGAke2NvbnRyYWN0TmFtZSh0ZXN0TmFtZSl9LnNvbGA7XG59XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVUZXN0cyhmaXh0dXJlcykge1xuICBmb3IgKGxldCB7IG5hbWUsIHZhbHVlOiBleHBlY3RlZCB9IG9mIGZpeHR1cmVzKSB7XG4gICAgaXQoYGNvcnJlY3RseSBkZWNvZGVzICR7bmFtZX1gLFxuICAgICAgKCkgPT4geyBhc3NlcnQuZGVlcEVxdWFsKHRoaXMuZGVjb2RlKG5hbWUpLCBleHBlY3RlZCk7IH1cbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhc3RTdGF0ZW1lbnRMaW5lKHNvdXJjZSkge1xuICBjb25zdCBsaW5lcyA9IHNvdXJjZS5zcGxpdChcIlxcblwiKTtcbiAgZm9yIChsZXQgaSA9IGxpbmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpZiAobGluZS5pbmRleE9mKFwiO1wiKSAhPSAtMSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG59XG5cblxuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZURlYnVnZ2VyKHRlc3ROYW1lLCBzb3VyY2VzKSB7XG4gIGNvbnN0IHByb3ZpZGVyID0gR2FuYWNoZS5wcm92aWRlcih7c2VlZDogXCJkZWJ1Z2dlclwiLCBnYXNMaW1pdDogNzAwMDAwMH0pO1xuICBjb25zdCB3ZWIzID0gbmV3IFdlYjMocHJvdmlkZXIpO1xuXG4gIGxldCB7IGFic3RyYWN0aW9ucywgYXJ0aWZhY3RzOiBjb250cmFjdHMsIGZpbGVzIH0gPVxuICAgIGF3YWl0IHByZXBhcmVDb250cmFjdHMocHJvdmlkZXIsIHNvdXJjZXMpO1xuXG4gIGxldCBpbnN0YW5jZSA9IGF3YWl0IGFic3RyYWN0aW9uc1tjb250cmFjdE5hbWUodGVzdE5hbWUpXS5kZXBsb3llZCgpO1xuICBsZXQgcmVjZWlwdCA9IGF3YWl0IGluc3RhbmNlLnJ1bigpO1xuICBsZXQgdHhIYXNoID0gcmVjZWlwdC50eDtcblxuICBsZXQgYnVnZ2VyID0gYXdhaXQgRGVidWdnZXIuZm9yVHgodHhIYXNoLCB7IHByb3ZpZGVyLCBmaWxlcywgY29udHJhY3RzIH0pO1xuXG4gIGxldCBzZXNzaW9uID0gYnVnZ2VyLmNvbm5lY3QoKTtcblxuICBsZXQgYnJlYWtwb2ludCA9IHtcbiAgICBhZGRyZXNzOiBpbnN0YW5jZS5hZGRyZXNzLFxuICAgIGxpbmU6IGxhc3RTdGF0ZW1lbnRMaW5lKHNvdXJjZXNbZmlsZU5hbWUodGVzdE5hbWUpXSlcbiAgfTtcblxuICBzZXNzaW9uLmNvbnRpbnVlVW50aWwoYnJlYWtwb2ludCk7XG5cbiAgcmV0dXJuIHNlc3Npb247XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldERlY29kZShzZXNzaW9uKSB7XG4gIGNvbnN0IGRlZmluaXRpb25zID0gc2Vzc2lvbi52aWV3KGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5kZWZpbml0aW9ucyk7XG4gIGNvbnN0IHJlZnMgPSBzZXNzaW9uLnZpZXcoZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzLnJlZnMpO1xuXG4gIGNvbnN0IGRlY29kZSA9IHNlc3Npb24udmlldyhkYXRhLnZpZXdzLmRlY29kZXIpO1xuICByZXR1cm4gKG5hbWUpID0+IGNsZWFuQmlnTnVtYmVycyhcbiAgICBkZWNvZGUoZGVmaW5pdGlvbnNbbmFtZV0sIHJlZnNbbmFtZV0pXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmliZURlY29kaW5nKHRlc3ROYW1lLCBmaXh0dXJlcywgc2VsZWN0b3IsIGdlbmVyYXRlU291cmNlKSB7XG4gIGNvbnN0IHNvdXJjZXMgPSB7XG4gICAgW2ZpbGVOYW1lKHRlc3ROYW1lKV06IGdlbmVyYXRlU291cmNlKGNvbnRyYWN0TmFtZSh0ZXN0TmFtZSkpXG4gIH07XG5cbiAgZGVzY3JpYmUodGVzdE5hbWUsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGltZW91dCgzMDAwMCk7XG5cbiAgICBiZWZvcmUoXCJydW5zIGFuZCBvYnNlcnZlcyBkZWJ1Z2dlclwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgcHJlcGFyZURlYnVnZ2VyKHRlc3ROYW1lLCBzb3VyY2VzKTtcbiAgICAgIHRoaXMuZGVjb2RlID0gYXdhaXQgZ2V0RGVjb2RlKHNlc3Npb24pO1xuXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgZGVidWcoXCJzZWxlY3RvciAlT1wiLCBzZXNzaW9uLnZpZXcoc2VsZWN0b3IpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGdlbmVyYXRlVGVzdHMuYmluZCh0aGlzKShmaXh0dXJlcyk7XG4gIH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHRlc3QvZGF0YS9kZWNvZGUvaGVscGVycy5qcyIsIi8vIHJ1bnRpbWUgaGVscGVyXG5mdW5jdGlvbiBpbk1hbmlmZXN0KGlkKSB7IHJldHVybiBnbG9iYWwuX193ZWJwYWNrTWFuaWZlc3RfXy5pbmRleE9mKGlkKSA+PSAwO31cbmZ1bmN0aW9uIHJ1bihpZCkgeyBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTt9XG5cbi8vIG1vZHVsZXMgdG8gZXhlY3V0ZSBnb2VzIGhlcmVcbnZhciBpZHMgPSBbXG5yZXF1aXJlLnJlc29sdmUoXCIuLi8uLi8uLi90ZXN0L2FzdC5qc1wiKSxyZXF1aXJlLnJlc29sdmUoXCIuLi8uLi8uLi90ZXN0L2NvbnRleHQuanNcIikscmVxdWlyZS5yZXNvbHZlKFwiLi4vLi4vLi4vdGVzdC9kYXRhL2RlY29kZS9kZWNvZGluZy5qc1wiKSxyZXF1aXJlLnJlc29sdmUoXCIuLi8uLi8uLi90ZXN0L2RhdGEvZGVjb2RlL2hlbHBlcnMuanNcIikscmVxdWlyZS5yZXNvbHZlKFwiLi4vLi4vLi4vdGVzdC9kYXRhL2RlY29kZS91dGlscy5qc1wiKSxyZXF1aXJlLnJlc29sdmUoXCIuLi8uLi8uLi90ZXN0L2V2bS5qc1wiKSxyZXF1aXJlLnJlc29sdmUoXCIuLi8uLi8uLi90ZXN0L2hlbHBlcnMuanNcIikscmVxdWlyZS5yZXNvbHZlKFwiLi4vLi4vLi4vdGVzdC9zb2xpZGl0eS5qc1wiKVxuXTtcblxuaWRzLmZpbHRlcihpbk1hbmlmZXN0KS5mb3JFYWNoKHJ1bilcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb2NoYS13ZWJwYWNrL2xpYi9lbnRyeS5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcInRlc3Q6YXN0XCIpO1xuXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiY2hhaVwiO1xuXG5pbXBvcnQgR2FuYWNoZSBmcm9tIFwiZ2FuYWNoZS1jbGlcIjtcbmltcG9ydCBXZWIzIGZyb20gXCJ3ZWIzXCI7XG5cbmltcG9ydCB7IHByZXBhcmVDb250cmFjdHMgfSBmcm9tIFwiLi9oZWxwZXJzXCI7XG5pbXBvcnQgRGVidWdnZXIgZnJvbSBcImxpYi9kZWJ1Z2dlclwiO1xuXG5pbXBvcnQgYXN0IGZyb20gXCJsaWIvYXN0L3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNvbGlkaXR5IGZyb20gXCJsaWIvc29saWRpdHkvc2VsZWN0b3JzXCI7XG5cbmltcG9ydCB7IGdldFJhbmdlLCBmaW5kUmFuZ2UsIHJhbmdlTm9kZXMgfSBmcm9tIFwibGliL2FzdC9tYXBcIjtcblxuY29uc3QgX19WQVJJQUJMRVMgPSBgXG5wcmFnbWEgc29saWRpdHkgXjAuNC4xODtcblxuY29udHJhY3QgVmFyaWFibGVzIHtcbiAgZXZlbnQgUmVzdWx0KHVpbnQyNTYgcmVzdWx0KTtcblxuICB1aW50MjU2IHF1eDtcbiAgc3RyaW5nIHF1dXg7XG5cbiAgZnVuY3Rpb24gc3RhY2sodWludDI1NiBmb28pIHB1YmxpYyByZXR1cm5zICh1aW50MjU2KSB7XG4gICAgdWludDI1NiBiYXIgPSBmb28gKyAxO1xuICAgIHVpbnQyNTYgYmF6ID0gaW5uZXJTdGFjayhiYXIpO1xuXG4gICAgYmF6ICs9IDQ7XG5cbiAgICBxdXggPSBiYXo7XG5cbiAgICBSZXN1bHQoYmF6KTtcblxuICAgIHJldHVybiBiYXo7XG4gIH1cblxuICBmdW5jdGlvbiBpbm5lclN0YWNrKHVpbnQyNTYgYmF6KSBwdWJsaWMgcmV0dXJucyAodWludDI1Nikge1xuICAgIHVpbnQyNTYgYmFyID0gYmF6ICsgMjtcbiAgICByZXR1cm4gYmFyO1xuICB9XG59XG5gO1xuXG5cbmxldCBzb3VyY2VzID0ge1xuICBcIlZhcmlhYmxlcy5zb2xcIjogX19WQVJJQUJMRVNcbn1cblxuZGVzY3JpYmUoXCJBU1RcIiwgZnVuY3Rpb24oKSB7XG4gIHZhciBwcm92aWRlcjtcbiAgdmFyIHdlYjM7XG5cbiAgdmFyIGFic3RyYWN0aW9ucztcbiAgdmFyIGFydGlmYWN0cztcbiAgdmFyIGZpbGVzO1xuXG4gIGJlZm9yZShcIkNyZWF0ZSBQcm92aWRlclwiLCBhc3luYyBmdW5jdGlvbigpIHtcbiAgICBwcm92aWRlciA9IEdhbmFjaGUucHJvdmlkZXIoe3NlZWQ6IFwiZGVidWdnZXJcIiwgZ2FzTGltaXQ6IDcwMDAwMDB9KTtcbiAgICB3ZWIzID0gbmV3IFdlYjMocHJvdmlkZXIpO1xuICB9KTtcblxuICBiZWZvcmUoXCJQcmVwYXJlIGNvbnRyYWN0cyBhbmQgYXJ0aWZhY3RzXCIsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGltZW91dCgzMDAwMCk7XG5cbiAgICBsZXQgcHJlcGFyZWQgPSBhd2FpdCBwcmVwYXJlQ29udHJhY3RzKHByb3ZpZGVyLCBzb3VyY2VzKVxuICAgIGFic3RyYWN0aW9ucyA9IHByZXBhcmVkLmFic3RyYWN0aW9ucztcbiAgICBhcnRpZmFjdHMgPSBwcmVwYXJlZC5hcnRpZmFjdHM7XG4gICAgZmlsZXMgPSBwcmVwYXJlZC5maWxlcztcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJOb2RlIHBvaW50ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgaXQoXCJ0cmF2ZXJzZXNcIiwgYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRpbWVvdXQoMCk7XG4gICAgICBsZXQgaW5zdGFuY2UgPSBhd2FpdCBhYnN0cmFjdGlvbnMuVmFyaWFibGVzLmRlcGxveWVkKCk7XG4gICAgICBsZXQgcmVjZWlwdCA9IGF3YWl0IGluc3RhbmNlLnN0YWNrKDQpO1xuICAgICAgbGV0IHR4SGFzaCA9IHJlY2VpcHQudHg7XG5cbiAgICAgIGxldCBidWdnZXIgPSBhd2FpdCBEZWJ1Z2dlci5mb3JUeCh0eEhhc2gsIHtcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIGZpbGVzLFxuICAgICAgICBjb250cmFjdHM6IGFydGlmYWN0c1xuICAgICAgfSk7XG5cbiAgICAgIGxldCBzZXNzaW9uID0gYnVnZ2VyLmNvbm5lY3QoKTtcbiAgICAgIGRlYnVnKFwiYXN0OiAlT1wiLCBzZXNzaW9uLnZpZXcoYXN0LmN1cnJlbnQudHJlZSkpO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBsZW5ndGggfSA9IHNlc3Npb24udmlldyhzb2xpZGl0eS5jdXJyZW50LnNvdXJjZVJhbmdlKTtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgbGVuZ3RoO1xuXG4gICAgICAgIGxldCBub2RlID0gc2Vzc2lvbi52aWV3KGFzdC5jdXJyZW50Lm5vZGUpO1xuXG4gICAgICAgIGxldCBbIG5vZGVTdGFydCwgbm9kZUxlbmd0aCBdID0gZ2V0UmFuZ2Uobm9kZSk7XG4gICAgICAgIGxldCBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZUxlbmd0aDtcblxuICAgICAgICBsZXQgcG9pbnRlciA9IHNlc3Npb24udmlldyhhc3QuY3VycmVudC5wb2ludGVyKTtcblxuICAgICAgICBhc3NlcnQuaXNBdE1vc3QoXG4gICAgICAgICAgbm9kZVN0YXJ0LCBzdGFydCxcbiAgICAgICAgICBgTm9kZSAke3BvaW50ZXJ9IGF0IHNob3VsZCBub3QgYmVnaW4gYWZ0ZXIgaW5zdHJ1Y3Rpb24gc291cmNlIHJhbmdlYFxuICAgICAgICApO1xuICAgICAgICBhc3NlcnQuaXNBdExlYXN0KFxuICAgICAgICAgIG5vZGVFbmQsIGVuZCxcbiAgICAgICAgICBgTm9kZSAke3BvaW50ZXJ9IHNob3VsZCBub3QgZW5kIGFmdGVyIHNvdXJjZWBcbiAgICAgICAgKTtcblxuICAgICAgICBzZXNzaW9uLnN0ZXBOZXh0KCk7XG4gICAgICB9IHdoaWxlKCFzZXNzaW9uLmZpbmlzaGVkKTtcblxuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHRlc3QvYXN0LmpzIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIHVzZWQgPSBbXVxuICAsIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKiFcbiAqIENoYWkgdmVyc2lvblxuICovXG5cbmV4cG9ydHMudmVyc2lvbiA9ICczLjUuMCc7XG5cbi8qIVxuICogQXNzZXJ0aW9uIEVycm9yXG4gKi9cblxuZXhwb3J0cy5Bc3NlcnRpb25FcnJvciA9IHJlcXVpcmUoJ2Fzc2VydGlvbi1lcnJvcicpO1xuXG4vKiFcbiAqIFV0aWxzIGZvciBwbHVnaW5zIChub3QgZXhwb3J0ZWQpXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL2NoYWkvdXRpbHMnKTtcblxuLyoqXG4gKiAjIC51c2UoZnVuY3Rpb24pXG4gKlxuICogUHJvdmlkZXMgYSB3YXkgdG8gZXh0ZW5kIHRoZSBpbnRlcm5hbHMgb2YgQ2hhaVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAcmV0dXJucyB7dGhpc30gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudXNlID0gZnVuY3Rpb24gKGZuKSB7XG4gIGlmICghfnVzZWQuaW5kZXhPZihmbikpIHtcbiAgICBmbih0aGlzLCB1dGlsKTtcbiAgICB1c2VkLnB1c2goZm4pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIFV0aWxpdHkgRnVuY3Rpb25zXG4gKi9cblxuZXhwb3J0cy51dGlsID0gdXRpbDtcblxuLyohXG4gKiBDb25maWd1cmF0aW9uXG4gKi9cblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY2hhaS9jb25maWcnKTtcbmV4cG9ydHMuY29uZmlnID0gY29uZmlnO1xuXG4vKiFcbiAqIFByaW1hcnkgYEFzc2VydGlvbmAgcHJvdG90eXBlXG4gKi9cblxudmFyIGFzc2VydGlvbiA9IHJlcXVpcmUoJy4vY2hhaS9hc3NlcnRpb24nKTtcbmV4cG9ydHMudXNlKGFzc2VydGlvbik7XG5cbi8qIVxuICogQ29yZSBBc3NlcnRpb25zXG4gKi9cblxudmFyIGNvcmUgPSByZXF1aXJlKCcuL2NoYWkvY29yZS9hc3NlcnRpb25zJyk7XG5leHBvcnRzLnVzZShjb3JlKTtcblxuLyohXG4gKiBFeHBlY3QgaW50ZXJmYWNlXG4gKi9cblxudmFyIGV4cGVjdCA9IHJlcXVpcmUoJy4vY2hhaS9pbnRlcmZhY2UvZXhwZWN0Jyk7XG5leHBvcnRzLnVzZShleHBlY3QpO1xuXG4vKiFcbiAqIFNob3VsZCBpbnRlcmZhY2VcbiAqL1xuXG52YXIgc2hvdWxkID0gcmVxdWlyZSgnLi9jaGFpL2ludGVyZmFjZS9zaG91bGQnKTtcbmV4cG9ydHMudXNlKHNob3VsZCk7XG5cbi8qIVxuICogQXNzZXJ0IGludGVyZmFjZVxuICovXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCcuL2NoYWkvaW50ZXJmYWNlL2Fzc2VydCcpO1xuZXhwb3J0cy51c2UoYXNzZXJ0KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMSBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTWFpbiBleHBvcnRzXG4gKi9cblxudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKiFcbiAqIHRlc3QgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMudGVzdCA9IHJlcXVpcmUoJy4vdGVzdCcpO1xuXG4vKiFcbiAqIHR5cGUgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMudHlwZSA9IHJlcXVpcmUoJ3R5cGUtZGV0ZWN0Jyk7XG5cbi8qIVxuICogZXhwZWN0VHlwZXMgdXRpbGl0eVxuICovXG5leHBvcnRzLmV4cGVjdFR5cGVzID0gcmVxdWlyZSgnLi9leHBlY3RUeXBlcycpO1xuXG4vKiFcbiAqIG1lc3NhZ2UgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZ2V0TWVzc2FnZSA9IHJlcXVpcmUoJy4vZ2V0TWVzc2FnZScpO1xuXG4vKiFcbiAqIGFjdHVhbCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5nZXRBY3R1YWwgPSByZXF1aXJlKCcuL2dldEFjdHVhbCcpO1xuXG4vKiFcbiAqIEluc3BlY3QgdXRpbFxuICovXG5cbmV4cG9ydHMuaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpO1xuXG4vKiFcbiAqIE9iamVjdCBEaXNwbGF5IHV0aWxcbiAqL1xuXG5leHBvcnRzLm9iakRpc3BsYXkgPSByZXF1aXJlKCcuL29iakRpc3BsYXknKTtcblxuLyohXG4gKiBGbGFnIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcblxuLyohXG4gKiBGbGFnIHRyYW5zZmVycmluZyB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qIVxuICogRGVlcCBlcXVhbCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5lcWwgPSByZXF1aXJlKCdkZWVwLWVxbCcpO1xuXG4vKiFcbiAqIERlZXAgcGF0aCB2YWx1ZVxuICovXG5cbmV4cG9ydHMuZ2V0UGF0aFZhbHVlID0gcmVxdWlyZSgnLi9nZXRQYXRoVmFsdWUnKTtcblxuLyohXG4gKiBEZWVwIHBhdGggaW5mb1xuICovXG5cbmV4cG9ydHMuZ2V0UGF0aEluZm8gPSByZXF1aXJlKCcuL2dldFBhdGhJbmZvJyk7XG5cbi8qIVxuICogQ2hlY2sgaWYgYSBwcm9wZXJ0eSBleGlzdHNcbiAqL1xuXG5leHBvcnRzLmhhc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9oYXNQcm9wZXJ0eScpO1xuXG4vKiFcbiAqIEZ1bmN0aW9uIG5hbWVcbiAqL1xuXG5leHBvcnRzLmdldE5hbWUgPSByZXF1aXJlKCcuL2dldE5hbWUnKTtcblxuLyohXG4gKiBhZGQgUHJvcGVydHlcbiAqL1xuXG5leHBvcnRzLmFkZFByb3BlcnR5ID0gcmVxdWlyZSgnLi9hZGRQcm9wZXJ0eScpO1xuXG4vKiFcbiAqIGFkZCBNZXRob2RcbiAqL1xuXG5leHBvcnRzLmFkZE1ldGhvZCA9IHJlcXVpcmUoJy4vYWRkTWV0aG9kJyk7XG5cbi8qIVxuICogb3ZlcndyaXRlIFByb3BlcnR5XG4gKi9cblxuZXhwb3J0cy5vdmVyd3JpdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vb3ZlcndyaXRlUHJvcGVydHknKTtcblxuLyohXG4gKiBvdmVyd3JpdGUgTWV0aG9kXG4gKi9cblxuZXhwb3J0cy5vdmVyd3JpdGVNZXRob2QgPSByZXF1aXJlKCcuL292ZXJ3cml0ZU1ldGhvZCcpO1xuXG4vKiFcbiAqIEFkZCBhIGNoYWluYWJsZSBtZXRob2RcbiAqL1xuXG5leHBvcnRzLmFkZENoYWluYWJsZU1ldGhvZCA9IHJlcXVpcmUoJy4vYWRkQ2hhaW5hYmxlTWV0aG9kJyk7XG5cbi8qIVxuICogT3ZlcndyaXRlIGNoYWluYWJsZSBtZXRob2RcbiAqL1xuXG5leHBvcnRzLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCA9IHJlcXVpcmUoJy4vb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogQ2hhaSAtIHRlc3QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGFuY2llc1xuICovXG5cbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG5cbi8qKlxuICogIyB0ZXN0KG9iamVjdCwgZXhwcmVzc2lvbilcbiAqXG4gKiBUZXN0IGFuZCBvYmplY3QgZm9yIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAoY29uc3RydWN0ZWQgQXNzZXJ0aW9uKVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgYXJndW1lbnRzXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSB0ZXN0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBhcmdzKSB7XG4gIHZhciBuZWdhdGUgPSBmbGFnKG9iaiwgJ25lZ2F0ZScpXG4gICAgLCBleHByID0gYXJnc1swXTtcbiAgcmV0dXJuIG5lZ2F0ZSA/ICFleHByIDogZXhwcjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvdGVzdC5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiB0eXBlLWRldGVjdFxuICogQ29weXJpZ2h0KGMpIDIwMTMgamFrZSBsdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0c1xuICovXG5cbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBnZXRUeXBlO1xuXG4vKipcbiAqICMjIyB0eXBlT2YgKG9iailcbiAqXG4gKiBVc2Ugc2V2ZXJhbCBkaWZmZXJlbnQgdGVjaG5pcXVlcyB0byBkZXRlcm1pbmVcbiAqIHRoZSB0eXBlIG9mIG9iamVjdCBiZWluZyB0ZXN0ZWQuXG4gKlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICogQHJldHVybiB7U3RyaW5nfSBvYmplY3QgdHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xudmFyIG9iamVjdFR5cGVSZWdleHAgPSAvXlxcW29iamVjdCAoLiopXFxdJC87XG5cbmZ1bmN0aW9uIGdldFR5cGUob2JqKSB7XG4gIHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikubWF0Y2gob2JqZWN0VHlwZVJlZ2V4cClbMV0udG9Mb3dlckNhc2UoKTtcbiAgLy8gTGV0IFwibmV3IFN0cmluZygnJylcIiByZXR1cm4gJ29iamVjdCdcbiAgaWYgKHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiAncHJvbWlzZSc7XG4gIC8vIFBoYW50b21KUyBoYXMgdHlwZSBcIkRPTVdpbmRvd1wiIGZvciBudWxsXG4gIGlmIChvYmogPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIC8vIFBoYW50b21KUyBoYXMgdHlwZSBcIkRPTVdpbmRvd1wiIGZvciB1bmRlZmluZWRcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnRzLkxpYnJhcnkgPSBMaWJyYXJ5O1xuXG4vKipcbiAqICMjIyBMaWJyYXJ5XG4gKlxuICogQ3JlYXRlIGEgcmVwb3NpdG9yeSBmb3IgY3VzdG9tIHR5cGUgZGV0ZWN0aW9uLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGliID0gbmV3IHR5cGUuTGlicmFyeTtcbiAqIGBgYFxuICpcbiAqL1xuXG5mdW5jdGlvbiBMaWJyYXJ5KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGlicmFyeSkpIHJldHVybiBuZXcgTGlicmFyeSgpO1xuICB0aGlzLnRlc3RzID0ge307XG59XG5cbi8qKlxuICogIyMjIyAub2YgKG9iailcbiAqXG4gKiBFeHBvc2UgcmVwbGFjZW1lbnQgYHR5cGVvZmAgZGV0ZWN0aW9uIHRvIHRoZSBsaWJyYXJ5LlxuICpcbiAqIGBgYGpzXG4gKiBpZiAoJ3N0cmluZycgPT09IGxpYi5vZignaGVsbG8gd29ybGQnKSkge1xuICogICAvLyAuLi5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5MaWJyYXJ5LnByb3RvdHlwZS5vZiA9IGdldFR5cGU7XG5cbi8qKlxuICogIyMjIyAuZGVmaW5lICh0eXBlLCB0ZXN0KVxuICpcbiAqIEFkZCBhIHRlc3QgdG8gZm9yIHRoZSBgLnRlc3QoKWAgYXNzZXJ0aW9uLlxuICpcbiAqIENhbiBiZSBkZWZpbmVkIGFzIGEgcmVndWxhciBleHByZXNzaW9uOlxuICpcbiAqIGBgYGpzXG4gKiBsaWIuZGVmaW5lKCdpbnQnLCAvXlswLTldKyQvKTtcbiAqIGBgYFxuICpcbiAqIC4uLiBvciBhcyBhIGZ1bmN0aW9uOlxuICpcbiAqIGBgYGpzXG4gKiBsaWIuZGVmaW5lKCdibG4nLCBmdW5jdGlvbiAob2JqKSB7XG4gKiAgIGlmICgnYm9vbGVhbicgPT09IGxpYi5vZihvYmopKSByZXR1cm4gdHJ1ZTtcbiAqICAgdmFyIGJsbnMgPSBbICd5ZXMnLCAnbm8nLCAndHJ1ZScsICdmYWxzZScsIDEsIDAgXTtcbiAqICAgaWYgKCdzdHJpbmcnID09PSBsaWIub2Yob2JqKSkgb2JqID0gb2JqLnRvTG93ZXJDYXNlKCk7XG4gKiAgIHJldHVybiAhISB+Ymxucy5pbmRleE9mKG9iaik7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1JlZ0V4cHxGdW5jdGlvbn0gdGVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaWJyYXJ5LnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbih0eXBlLCB0ZXN0KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy50ZXN0c1t0eXBlXTtcbiAgdGhpcy50ZXN0c1t0eXBlXSA9IHRlc3Q7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiAjIyMjIC50ZXN0IChvYmosIHRlc3QpXG4gKlxuICogQXNzZXJ0IHRoYXQgYW4gb2JqZWN0IGlzIG9mIHR5cGUuIFdpbGwgZmlyc3RcbiAqIGNoZWNrIG5hdGl2ZXMsIGFuZCBpZiB0aGF0IGRvZXMgbm90IHBhc3MgaXQgd2lsbFxuICogdXNlIHRoZSB1c2VyIGRlZmluZWQgY3VzdG9tIHRlc3RzLlxuICpcbiAqIGBgYGpzXG4gKiBhc3NlcnQobGliLnRlc3QoJzEnLCAnaW50JykpO1xuICogYXNzZXJ0KGxpYi50ZXN0KCd5ZXMnLCAnYmxuJykpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbihvYmosIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IGdldFR5cGUob2JqKSkgcmV0dXJuIHRydWU7XG4gIHZhciB0ZXN0ID0gdGhpcy50ZXN0c1t0eXBlXTtcblxuICBpZiAodGVzdCAmJiAncmVnZXhwJyA9PT0gZ2V0VHlwZSh0ZXN0KSkge1xuICAgIHJldHVybiB0ZXN0LnRlc3Qob2JqKTtcbiAgfSBlbHNlIGlmICh0ZXN0ICYmICdmdW5jdGlvbicgPT09IGdldFR5cGUodGVzdCkpIHtcbiAgICByZXR1cm4gdGVzdChvYmopO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignVHlwZSB0ZXN0IFwiJyArIHR5cGUgKyAnXCIgbm90IGRlZmluZWQgb3IgaW52YWxpZC4nKTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvdHlwZS1kZXRlY3QvbGliL3R5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogQ2hhaSAtIGV4cGVjdFR5cGVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyBleHBlY3RUeXBlcyhvYmosIHR5cGVzKVxuICpcbiAqIEVuc3VyZXMgdGhhdCB0aGUgb2JqZWN0IGJlaW5nIHRlc3RlZCBhZ2FpbnN0IGlzIG9mIGEgdmFsaWQgdHlwZS5cbiAqXG4gKiAgICAgdXRpbHMuZXhwZWN0VHlwZXModGhpcywgWydhcnJheScsICdvYmplY3QnLCAnc3RyaW5nJ10pO1xuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iaiBjb25zdHJ1Y3RlZCBBc3NlcnRpb25cbiAqIEBwYXJhbSB7QXJyYXl9IHR5cGUgQSBsaXN0IG9mIGFsbG93ZWQgdHlwZXMgZm9yIHRoaXMgYXNzZXJ0aW9uXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBleHBlY3RUeXBlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgQXNzZXJ0aW9uRXJyb3IgPSByZXF1aXJlKCdhc3NlcnRpb24tZXJyb3InKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJ3R5cGUtZGV0ZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgdHlwZXMpIHtcbiAgdmFyIG9iaiA9IGZsYWcob2JqLCAnb2JqZWN0Jyk7XG4gIHR5cGVzID0gdHlwZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnRvTG93ZXJDYXNlKCk7IH0pO1xuICB0eXBlcy5zb3J0KCk7XG5cbiAgLy8gVHJhbnNmb3JtcyBbJ2xvcmVtJywgJ2lwc3VtJ10gaW50byAnYSBsaXJ1bSwgb3IgYW4gaXBzdW0nXG4gIHZhciBzdHIgPSB0eXBlcy5tYXAoZnVuY3Rpb24gKHQsIGluZGV4KSB7XG4gICAgdmFyIGFydCA9IH5bICdhJywgJ2UnLCAnaScsICdvJywgJ3UnIF0uaW5kZXhPZih0LmNoYXJBdCgwKSkgPyAnYW4nIDogJ2EnO1xuICAgIHZhciBvciA9IHR5cGVzLmxlbmd0aCA+IDEgJiYgaW5kZXggPT09IHR5cGVzLmxlbmd0aCAtIDEgPyAnb3IgJyA6ICcnO1xuICAgIHJldHVybiBvciArIGFydCArICcgJyArIHQ7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKCF0eXBlcy5zb21lKGZ1bmN0aW9uIChleHBlY3RlZCkgeyByZXR1cm4gdHlwZShvYmopID09PSBleHBlY3RlZDsgfSkpIHtcbiAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAnb2JqZWN0IHRlc3RlZCBtdXN0IGJlICcgKyBzdHIgKyAnLCBidXQgJyArIHR5cGUob2JqKSArICcgZ2l2ZW4nXG4gICAgKTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9leHBlY3RUeXBlcy5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBDaGFpIC0gbWVzc2FnZSBjb21wb3NpdGlvbiB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kYW5jaWVzXG4gKi9cblxudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKVxuICAsIGdldEFjdHVhbCA9IHJlcXVpcmUoJy4vZ2V0QWN0dWFsJylcbiAgLCBpbnNwZWN0ID0gcmVxdWlyZSgnLi9pbnNwZWN0JylcbiAgLCBvYmpEaXNwbGF5ID0gcmVxdWlyZSgnLi9vYmpEaXNwbGF5Jyk7XG5cbi8qKlxuICogIyMjIC5nZXRNZXNzYWdlKG9iamVjdCwgbWVzc2FnZSwgbmVnYXRlTWVzc2FnZSlcbiAqXG4gKiBDb25zdHJ1Y3QgdGhlIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gZmxhZ3NcbiAqIGFuZCB0ZW1wbGF0ZSB0YWdzLiBUZW1wbGF0ZSB0YWdzIHdpbGwgcmV0dXJuXG4gKiBhIHN0cmluZ2lmaWVkIGluc3BlY3Rpb24gb2YgdGhlIG9iamVjdCByZWZlcmVuY2VkLlxuICpcbiAqIE1lc3NhZ2UgdGVtcGxhdGUgdGFnczpcbiAqIC0gYCN7dGhpc31gIGN1cnJlbnQgYXNzZXJ0ZWQgb2JqZWN0XG4gKiAtIGAje2FjdH1gIGFjdHVhbCB2YWx1ZVxuICogLSBgI3tleHB9YCBleHBlY3RlZCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0TWVzc2FnZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGFyZ3MpIHtcbiAgdmFyIG5lZ2F0ZSA9IGZsYWcob2JqLCAnbmVnYXRlJylcbiAgICAsIHZhbCA9IGZsYWcob2JqLCAnb2JqZWN0JylcbiAgICAsIGV4cGVjdGVkID0gYXJnc1szXVxuICAgICwgYWN0dWFsID0gZ2V0QWN0dWFsKG9iaiwgYXJncylcbiAgICAsIG1zZyA9IG5lZ2F0ZSA/IGFyZ3NbMl0gOiBhcmdzWzFdXG4gICAgLCBmbGFnTXNnID0gZmxhZyhvYmosICdtZXNzYWdlJyk7XG5cbiAgaWYodHlwZW9mIG1zZyA9PT0gXCJmdW5jdGlvblwiKSBtc2cgPSBtc2coKTtcbiAgbXNnID0gbXNnIHx8ICcnO1xuICBtc2cgPSBtc2dcbiAgICAucmVwbGFjZSgvI1xce3RoaXNcXH0vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqRGlzcGxheSh2YWwpOyB9KVxuICAgIC5yZXBsYWNlKC8jXFx7YWN0XFx9L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9iakRpc3BsYXkoYWN0dWFsKTsgfSlcbiAgICAucmVwbGFjZSgvI1xce2V4cFxcfS9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBvYmpEaXNwbGF5KGV4cGVjdGVkKTsgfSk7XG5cbiAgcmV0dXJuIGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyArIG1zZyA6IG1zZztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0TWVzc2FnZS5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBDaGFpIC0gZ2V0UHJvcGVydGllcyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldFByb3BlcnRpZXMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LCBlbnVtZXJhYmxlIG9yIG5vdCxcbiAqIGluaGVyaXRlZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge0FycmF5fVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0UHJvcGVydGllc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFByb3BlcnRpZXMob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpO1xuXG4gIGZ1bmN0aW9uIGFkZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgaWYgKHJlc3VsdC5pbmRleE9mKHByb3BlcnR5KSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHByb3BlcnR5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgd2hpbGUgKHByb3RvICE9PSBudWxsKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLmZvckVhY2goYWRkUHJvcGVydHkpO1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldFByb3BlcnRpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogQ2hhaSAtIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsXG4gKiBpbmhlcml0ZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRFbnVtZXJhYmxlUHJvcGVydGllcy5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9lcWwnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvZGVlcC1lcWwvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogZGVlcC1lcWxcbiAqIENvcHlyaWdodChjKSAyMDEzIEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpO1xuXG4vKiFcbiAqIEJ1ZmZlci5pc0J1ZmZlciBicm93c2VyIHNoaW1cbiAqL1xuXG52YXIgQnVmZmVyO1xudHJ5IHsgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyOyB9XG5jYXRjaChleCkge1xuICBCdWZmZXIgPSB7fTtcbiAgQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfVxufVxuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwRXF1YWw7XG5cbi8qKlxuICogQXNzZXJ0IHN1cGVyLXN0cmljdCAoZWdhbCkgZXF1YWxpdHkgYmV0d2VlblxuICogdHdvIG9iamVjdHMgb2YgYW55IHR5cGUuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYVxuICogQHBhcmFtIHtNaXhlZH0gYlxuICogQHBhcmFtIHtBcnJheX0gbWVtb2lzZWQgKG9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gZXF1YWwgbWF0Y2hcbiAqL1xuXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYiwgbSkge1xuICBpZiAoc2FtZVZhbHVlKGEsIGIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoJ2RhdGUnID09PSB0eXBlKGEpKSB7XG4gICAgcmV0dXJuIGRhdGVFcXVhbChhLCBiKTtcbiAgfSBlbHNlIGlmICgncmVnZXhwJyA9PT0gdHlwZShhKSkge1xuICAgIHJldHVybiByZWdleHBFcXVhbChhLCBiKTtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYSkpIHtcbiAgICByZXR1cm4gYnVmZmVyRXF1YWwoYSwgYik7XG4gIH0gZWxzZSBpZiAoJ2FyZ3VtZW50cycgPT09IHR5cGUoYSkpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzRXF1YWwoYSwgYiwgbSk7XG4gIH0gZWxzZSBpZiAoIXR5cGVFcXVhbChhLCBiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmICgoJ29iamVjdCcgIT09IHR5cGUoYSkgJiYgJ29iamVjdCcgIT09IHR5cGUoYikpXG4gICYmICgnYXJyYXknICE9PSB0eXBlKGEpICYmICdhcnJheScgIT09IHR5cGUoYikpKSB7XG4gICAgcmV0dXJuIHNhbWVWYWx1ZShhLCBiKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqZWN0RXF1YWwoYSwgYiwgbSk7XG4gIH1cbn1cblxuLyohXG4gKiBTdHJpY3QgKGVnYWwpIGVxdWFsaXR5IHRlc3QuIEVuc3VyZXMgdGhhdCBOYU4gYWx3YXlzXG4gKiBlcXVhbHMgTmFOIGFuZCBgLTBgIGRvZXMgbm90IGVxdWFsIGArMGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYVxuICogQHBhcmFtIHtNaXhlZH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gZXF1YWwgbWF0Y2hcbiAqL1xuXG5mdW5jdGlvbiBzYW1lVmFsdWUoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xufVxuXG4vKiFcbiAqIENvbXBhcmUgdGhlIHR5cGVzIG9mIHR3byBnaXZlbiBvYmplY3RzIGFuZFxuICogcmV0dXJuIGlmIHRoZXkgYXJlIGVxdWFsLiBOb3RlIHRoYXQgYW4gQXJyYXlcbiAqIGhhcyBhIHR5cGUgb2YgYGFycmF5YCAobm90IGBvYmplY3RgKSBhbmQgYXJndW1lbnRzXG4gKiBoYXZlIGEgdHlwZSBvZiBgYXJndW1lbnRzYCAobm90IGBhcnJheWAvYG9iamVjdGApLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFcbiAqIEBwYXJhbSB7TWl4ZWR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIHR5cGVFcXVhbChhLCBiKSB7XG4gIHJldHVybiB0eXBlKGEpID09PSB0eXBlKGIpO1xufVxuXG4vKiFcbiAqIENvbXBhcmUgdHdvIERhdGUgb2JqZWN0cyBieSBhc3NlcnRpbmcgdGhhdFxuICogdGhlIHRpbWUgdmFsdWVzIGFyZSBlcXVhbCB1c2luZyBgc2F2ZVZhbHVlYC5cbiAqXG4gKiBAcGFyYW0ge0RhdGV9IGFcbiAqIEBwYXJhbSB7RGF0ZX0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gZGF0ZUVxdWFsKGEsIGIpIHtcbiAgaWYgKCdkYXRlJyAhPT0gdHlwZShiKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gc2FtZVZhbHVlKGEuZ2V0VGltZSgpLCBiLmdldFRpbWUoKSk7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0d28gcmVndWxhciBleHByZXNzaW9ucyBieSBjb252ZXJ0aW5nIHRoZW1cbiAqIHRvIHN0cmluZyBhbmQgY2hlY2tpbmcgZm9yIGBzYW1lVmFsdWVgLlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfSBhXG4gKiBAcGFyYW0ge1JlZ0V4cH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gcmVnZXhwRXF1YWwoYSwgYikge1xuICBpZiAoJ3JlZ2V4cCcgIT09IHR5cGUoYikpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHNhbWVWYWx1ZShhLnRvU3RyaW5nKCksIGIudG9TdHJpbmcoKSk7XG59XG5cbi8qIVxuICogQXNzZXJ0IGRlZXAgZXF1YWxpdHkgb2YgdHdvIGBhcmd1bWVudHNgIG9iamVjdHMuXG4gKiBVbmZvcnR1bmF0ZWx5LCB0aGVzZSBtdXN0IGJlIHNsaWNlZCB0byBhcnJheXNcbiAqIHByaW9yIHRvIHRlc3QgdG8gZW5zdXJlIG5vIGJhZCBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gYVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGJcbiAqIEBwYXJhbSB7QXJyYXl9IG1lbW9pemUgKG9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gYXJndW1lbnRzRXF1YWwoYSwgYiwgbSkge1xuICBpZiAoJ2FyZ3VtZW50cycgIT09IHR5cGUoYikpIHJldHVybiBmYWxzZTtcbiAgYSA9IFtdLnNsaWNlLmNhbGwoYSk7XG4gIGIgPSBbXS5zbGljZS5jYWxsKGIpO1xuICByZXR1cm4gZGVlcEVxdWFsKGEsIGIsIG0pO1xufVxuXG4vKiFcbiAqIEdldCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEByZXR1cm4ge0FycmF5fSBwcm9wZXJ0eSBuYW1lc1xuICovXG5cbmZ1bmN0aW9uIGVudW1lcmFibGUoYSkge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBhKSByZXMucHVzaChrZXkpO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKiFcbiAqIFNpbXBsZSBlcXVhbGl0eSBmb3IgZmxhdCBpdGVyYWJsZSBvYmplY3RzXG4gKiBzdWNoIGFzIEFycmF5cyBvciBOb2RlLmpzIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtJdGVyYWJsZX0gYVxuICogQHBhcmFtIHtJdGVyYWJsZX0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gaXRlcmFibGVFcXVhbChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gIGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbWF0Y2ggPSB0cnVlO1xuXG4gIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG4vKiFcbiAqIEV4dGVuc2lvbiB0byBgaXRlcmFibGVFcXVhbGAgc3BlY2lmaWNhbGx5XG4gKiBmb3IgTm9kZS5qcyBCdWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBidWZmZXJFcXVhbChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpdGVyYWJsZUVxdWFsKGEsIGIpO1xufVxuXG4vKiFcbiAqIEJsb2NrIGZvciBgb2JqZWN0RXF1YWxgIGVuc3VyaW5nIG5vbi1leGlzdGluZ1xuICogdmFsdWVzIGRvbid0IGdldCBpbi5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsdWUoYSkge1xuICByZXR1cm4gYSAhPT0gbnVsbCAmJiBhICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qIVxuICogUmVjdXJzaXZlbHkgY2hlY2sgdGhlIGVxdWFsaXR5IG9mIHR3byBvYmplY3RzLlxuICogT25jZSBiYXNpYyBzYW1lbmVzcyBoYXMgYmVlbiBlc3RhYmxpc2hlZCBpdCB3aWxsXG4gKiBkZWZlciB0byBgZGVlcEVxdWFsYCBmb3IgZWFjaCBlbnVtZXJhYmxlIGtleVxuICogaW4gdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBvYmplY3RFcXVhbChhLCBiLCBtKSB7XG4gIGlmICghaXNWYWx1ZShhKSB8fCAhaXNWYWx1ZShiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaTtcbiAgaWYgKG0pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKChtW2ldWzBdID09PSBhICYmIG1baV1bMV0gPT09IGIpXG4gICAgICB8fCAgKG1baV1bMF0gPT09IGIgJiYgbVtpXVsxXSA9PT0gYSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG0gPSBbXTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIGthID0gZW51bWVyYWJsZShhKTtcbiAgICB2YXIga2IgPSBlbnVtZXJhYmxlKGIpO1xuICB9IGNhdGNoIChleCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuXG4gIGlmICghaXRlcmFibGVFcXVhbChrYSwga2IpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbS5wdXNoKFsgYSwgYiBdKTtcblxuICB2YXIga2V5O1xuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9kZWVwLWVxbC9saWIvZXFsLmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3R5cGUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvZGVlcC1lcWwvbm9kZV9tb2R1bGVzL3R5cGUtZGV0ZWN0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIHR5cGUtZGV0ZWN0XG4gKiBDb3B5cmlnaHQoYykgMjAxMyBqYWtlIGx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogUHJpbWFyeSBFeHBvcnRzXG4gKi9cblxudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGdldFR5cGU7XG5cbi8qIVxuICogRGV0ZWN0YWJsZSBqYXZhc2NyaXB0IG5hdGl2ZXNcbiAqL1xuXG52YXIgbmF0aXZlcyA9IHtcbiAgICAnW29iamVjdCBBcnJheV0nOiAnYXJyYXknXG4gICwgJ1tvYmplY3QgUmVnRXhwXSc6ICdyZWdleHAnXG4gICwgJ1tvYmplY3QgRnVuY3Rpb25dJzogJ2Z1bmN0aW9uJ1xuICAsICdbb2JqZWN0IEFyZ3VtZW50c10nOiAnYXJndW1lbnRzJ1xuICAsICdbb2JqZWN0IERhdGVdJzogJ2RhdGUnXG59O1xuXG4vKipcbiAqICMjIyB0eXBlT2YgKG9iailcbiAqXG4gKiBVc2Ugc2V2ZXJhbCBkaWZmZXJlbnQgdGVjaG5pcXVlcyB0byBkZXRlcm1pbmVcbiAqIHRoZSB0eXBlIG9mIG9iamVjdCBiZWluZyB0ZXN0ZWQuXG4gKlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICogQHJldHVybiB7U3RyaW5nfSBvYmplY3QgdHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBnZXRUeXBlIChvYmopIHtcbiAgdmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICBpZiAobmF0aXZlc1tzdHJdKSByZXR1cm4gbmF0aXZlc1tzdHJdO1xuICBpZiAob2JqID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJztcbiAgaWYgKG9iaiA9PT0gT2JqZWN0KG9iaikpIHJldHVybiAnb2JqZWN0JztcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59XG5cbmV4cG9ydHMuTGlicmFyeSA9IExpYnJhcnk7XG5cbi8qKlxuICogIyMjIExpYnJhcnlcbiAqXG4gKiBDcmVhdGUgYSByZXBvc2l0b3J5IGZvciBjdXN0b20gdHlwZSBkZXRlY3Rpb24uXG4gKlxuICogYGBganNcbiAqIHZhciBsaWIgPSBuZXcgdHlwZS5MaWJyYXJ5O1xuICogYGBgXG4gKlxuICovXG5cbmZ1bmN0aW9uIExpYnJhcnkgKCkge1xuICB0aGlzLnRlc3RzID0ge307XG59XG5cbi8qKlxuICogIyMjIyAub2YgKG9iailcbiAqXG4gKiBFeHBvc2UgcmVwbGFjZW1lbnQgYHR5cGVvZmAgZGV0ZWN0aW9uIHRvIHRoZSBsaWJyYXJ5LlxuICpcbiAqIGBgYGpzXG4gKiBpZiAoJ3N0cmluZycgPT09IGxpYi5vZignaGVsbG8gd29ybGQnKSkge1xuICogICAvLyAuLi5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5MaWJyYXJ5LnByb3RvdHlwZS5vZiA9IGdldFR5cGU7XG5cbi8qKlxuICogIyMjIyAuZGVmaW5lICh0eXBlLCB0ZXN0KVxuICpcbiAqIEFkZCBhIHRlc3QgdG8gZm9yIHRoZSBgLnRlc3QoKWAgYXNzZXJ0aW9uLlxuICpcbiAqIENhbiBiZSBkZWZpbmVkIGFzIGEgcmVndWxhciBleHByZXNzaW9uOlxuICpcbiAqIGBgYGpzXG4gKiBsaWIuZGVmaW5lKCdpbnQnLCAvXlswLTldKyQvKTtcbiAqIGBgYFxuICpcbiAqIC4uLiBvciBhcyBhIGZ1bmN0aW9uOlxuICpcbiAqIGBgYGpzXG4gKiBsaWIuZGVmaW5lKCdibG4nLCBmdW5jdGlvbiAob2JqKSB7XG4gKiAgIGlmICgnYm9vbGVhbicgPT09IGxpYi5vZihvYmopKSByZXR1cm4gdHJ1ZTtcbiAqICAgdmFyIGJsbnMgPSBbICd5ZXMnLCAnbm8nLCAndHJ1ZScsICdmYWxzZScsIDEsIDAgXTtcbiAqICAgaWYgKCdzdHJpbmcnID09PSBsaWIub2Yob2JqKSkgb2JqID0gb2JqLnRvTG93ZXJDYXNlKCk7XG4gKiAgIHJldHVybiAhISB+Ymxucy5pbmRleE9mKG9iaik7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1JlZ0V4cHxGdW5jdGlvbn0gdGVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaWJyYXJ5LnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbiAodHlwZSwgdGVzdCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMudGVzdHNbdHlwZV07XG4gIHRoaXMudGVzdHNbdHlwZV0gPSB0ZXN0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogIyMjIyAudGVzdCAob2JqLCB0ZXN0KVxuICpcbiAqIEFzc2VydCB0aGF0IGFuIG9iamVjdCBpcyBvZiB0eXBlLiBXaWxsIGZpcnN0XG4gKiBjaGVjayBuYXRpdmVzLCBhbmQgaWYgdGhhdCBkb2VzIG5vdCBwYXNzIGl0IHdpbGxcbiAqIHVzZSB0aGUgdXNlciBkZWZpbmVkIGN1c3RvbSB0ZXN0cy5cbiAqXG4gKiBgYGBqc1xuICogYXNzZXJ0KGxpYi50ZXN0KCcxJywgJ2ludCcpKTtcbiAqIGFzc2VydChsaWIudGVzdCgneWVzJywgJ2JsbicpKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaWJyYXJ5LnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gKG9iaiwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gZ2V0VHlwZShvYmopKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIHRlc3QgPSB0aGlzLnRlc3RzW3R5cGVdO1xuXG4gIGlmICh0ZXN0ICYmICdyZWdleHAnID09PSBnZXRUeXBlKHRlc3QpKSB7XG4gICAgcmV0dXJuIHRlc3QudGVzdChvYmopO1xuICB9IGVsc2UgaWYgKHRlc3QgJiYgJ2Z1bmN0aW9uJyA9PT0gZ2V0VHlwZSh0ZXN0KSkge1xuICAgIHJldHVybiB0ZXN0KG9iaik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdUeXBlIHRlc3QgXCInICsgdHlwZSArICdcIiBub3QgZGVmaW5lZCBvciBpbnZhbGlkLicpO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9kZWVwLWVxbC9ub2RlX21vZHVsZXMvdHlwZS1kZXRlY3QvbGliL3R5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJ1ZmZlclwiXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIENoYWkgLSBnZXRQYXRoVmFsdWUgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2xvZ2ljYWxwYXJhZG94L2ZpbHRyXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgZ2V0UGF0aEluZm8gPSByZXF1aXJlKCcuL2dldFBhdGhJbmZvJyk7XG5cbi8qKlxuICogIyMjIC5nZXRQYXRoVmFsdWUocGF0aCwgb2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgdmFsdWVzIGluIGFuXG4gKiBvYmplY3QgZ2l2ZW4gYSBzdHJpbmcgcGF0aC5cbiAqXG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgcHJvcDE6IHtcbiAqICAgICAgICAgICAgIGFycjogWydhJywgJ2InLCAnYyddXG4gKiAgICAgICAgICAgLCBzdHI6ICdIZWxsbydcbiAqICAgICAgICAgfVxuICogICAgICAgLCBwcm9wMjoge1xuICogICAgICAgICAgICAgYXJyOiBbIHsgbmVzdGVkOiAnVW5pdmVyc2UnIH0gXVxuICogICAgICAgICAgICwgc3RyOiAnSGVsbG8gYWdhaW4hJ1xuICogICAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgd291bGQgYmUgdGhlIHJlc3VsdHMuXG4gKlxuICogICAgIGdldFBhdGhWYWx1ZSgncHJvcDEuc3RyJywgb2JqKTsgLy8gSGVsbG9cbiAqICAgICBnZXRQYXRoVmFsdWUoJ3Byb3AxLmF0dFsyXScsIG9iaik7IC8vIGJcbiAqICAgICBnZXRQYXRoVmFsdWUoJ3Byb3AyLmFyclswXS5uZXN0ZWQnLCBvYmopOyAvLyBVbml2ZXJzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSB2YWx1ZSBvciBgdW5kZWZpbmVkYFxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0UGF0aFZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHBhdGgsIG9iaikge1xuICB2YXIgaW5mbyA9IGdldFBhdGhJbmZvKHBhdGgsIG9iaik7XG4gIHJldHVybiBpbmZvLnZhbHVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRQYXRoVmFsdWUuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogQ2hhaSAtIGFkZFByb3BlcnR5IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG4vKipcbiAqICMjIyBhZGRQcm9wZXJ0eSAoY3R4LCBuYW1lLCBnZXR0ZXIpXG4gKlxuICogQWRkcyBhIHByb3BlcnR5IHRvIHRoZSBwcm90b3R5cGUgb2YgYW4gb2JqZWN0LlxuICpcbiAqICAgICB1dGlscy5hZGRQcm9wZXJ0eShjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdmb28nLCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqKS50by5iZS5pbnN0YW5jZW9mKEZvbyk7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5iZS5mb287XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIHByb3BlcnR5IGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBwcm9wZXJ0eSB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlciBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBhZGRQcm9wZXJ0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIGdldHRlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiBhZGRQcm9wZXJ0eSgpIHtcbiAgICAgICAgdmFyIG9sZF9zc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgICAgICBpZiAob2xkX3NzZmkgJiYgY29uZmlnLmluY2x1ZGVTdGFjayA9PT0gZmFsc2UpXG4gICAgICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIGFkZFByb3BlcnR5KTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2FkZFByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIENoYWkgLSBhZGRNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuLyoqXG4gKiAjIyMgLmFkZE1ldGhvZCAoY3R4LCBuYW1lLCBtZXRob2QpXG4gKlxuICogQWRkcyBhIG1ldGhvZCB0byB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmVxdWFsKHN0cik7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvbygnYmFyJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIG1ldGhvZCBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGFkZE1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBtZXRob2QpIHtcbiAgY3R4W25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvbGRfc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBpZiAob2xkX3NzZmkgJiYgY29uZmlnLmluY2x1ZGVTdGFjayA9PT0gZmFsc2UpXG4gICAgICBmbGFnKHRoaXMsICdzc2ZpJywgY3R4W25hbWVdKTtcbiAgICB2YXIgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkTWV0aG9kLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVQcm9wZXJ0eSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgb3ZlcndyaXRlUHJvcGVydHkgKGN0eCwgbmFtZSwgZm4pXG4gKlxuICogT3ZlcndpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgcHJvcGVydHkgZ2V0dGVyIGFuZCBwcm92aWRlc1xuICogYWNjZXNzIHRvIHByZXZpb3VzIHZhbHVlLiBNdXN0IHJldHVybiBmdW5jdGlvbiB0byB1c2UgYXMgZ2V0dGVyLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVQcm9wZXJ0eShjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdvaycsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEZvbykge1xuICogICAgICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmoubmFtZSkudG8uZXF1YWwoJ2JhcicpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlUHJvcGVydHkoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uYmUub2s7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHByb3BlcnR5IHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGdldHRlciBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBvdmVyd3JpdGVQcm9wZXJ0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIGdldHRlcikge1xuICB2YXIgX2dldCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3R4LCBuYW1lKVxuICAgICwgX3N1cGVyID0gZnVuY3Rpb24gKCkge307XG5cbiAgaWYgKF9nZXQgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIF9nZXQuZ2V0KVxuICAgIF9zdXBlciA9IF9nZXQuZ2V0XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgbmFtZSxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0dGVyKF9zdXBlcikuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb3ZlcndyaXRlUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZU1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgb3ZlcndyaXRlTWV0aG9kIChjdHgsIG5hbWUsIGZuKVxuICpcbiAqIE92ZXJ3aXRlcyBhbiBhbHJlYWR5IGV4aXN0aW5nIG1ldGhvZCBhbmQgcHJvdmlkZXNcbiAqIGFjY2VzcyB0byBwcmV2aW91cyBmdW5jdGlvbi4gTXVzdCByZXR1cm4gZnVuY3Rpb25cbiAqIHRvIGJlIHVzZWQgZm9yIG5hbWUuXG4gKlxuICogICAgIHV0aWxzLm92ZXJ3cml0ZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdlcXVhbCcsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gKiAgICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEZvbykge1xuICogICAgICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmoudmFsdWUpLnRvLmVxdWFsKHN0cik7XG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5lcXVhbCgnYmFyJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgbWV0aG9kIGlzIHRvIGJlIG92ZXJ3cml0dGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgdG8gb3ZlcndyaXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgb3ZlcndyaXRlTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGN0eCwgbmFtZSwgbWV0aG9kKSB7XG4gIHZhciBfbWV0aG9kID0gY3R4W25hbWVdXG4gICAgLCBfc3VwZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG4gIGlmIChfbWV0aG9kICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBfbWV0aG9kKVxuICAgIF9zdXBlciA9IF9tZXRob2Q7XG5cbiAgY3R4W25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QoX3N1cGVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb3ZlcndyaXRlTWV0aG9kLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIENoYWkgLSBhZGRDaGFpbmluZ01ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIHRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbi8qIVxuICogTW9kdWxlIHZhcmlhYmxlc1xuICovXG5cbi8vIENoZWNrIHdoZXRoZXIgYF9fcHJvdG9fX2AgaXMgc3VwcG9ydGVkXG52YXIgaGFzUHJvdG9TdXBwb3J0ID0gJ19fcHJvdG9fXycgaW4gT2JqZWN0O1xuXG4vLyBXaXRob3V0IGBfX3Byb3RvX19gIHN1cHBvcnQsIHRoaXMgbW9kdWxlIHdpbGwgbmVlZCB0byBhZGQgcHJvcGVydGllcyB0byBhIGZ1bmN0aW9uLlxuLy8gSG93ZXZlciwgc29tZSBGdW5jdGlvbi5wcm90b3R5cGUgbWV0aG9kcyBjYW5ub3QgYmUgb3ZlcndyaXR0ZW4sXG4vLyBhbmQgdGhlcmUgc2VlbXMgbm8gZWFzeSBjcm9zcy1wbGF0Zm9ybSB3YXkgdG8gZGV0ZWN0IHRoZW0gKEBzZWUgY2hhaWpzL2NoYWkvaXNzdWVzLzY5KS5cbnZhciBleGNsdWRlTmFtZXMgPSAvXig/Omxlbmd0aHxuYW1lfGFyZ3VtZW50c3xjYWxsZXIpJC87XG5cbi8vIENhY2hlIGBGdW5jdGlvbmAgcHJvcGVydGllc1xudmFyIGNhbGwgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwsXG4gICAgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8qKlxuICogIyMjIGFkZENoYWluYWJsZU1ldGhvZCAoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpXG4gKlxuICogQWRkcyBhIG1ldGhvZCB0byBhbiBvYmplY3QsIHN1Y2ggdGhhdCB0aGUgbWV0aG9kIGNhbiBhbHNvIGJlIGNoYWluZWQuXG4gKlxuICogICAgIHV0aWxzLmFkZENoYWluYWJsZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdmb28nLCBmdW5jdGlvbiAoc3RyKSB7XG4gKiAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqKS50by5iZS5lcXVhbChzdHIpO1xuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdmb28nLCBmbiwgY2hhaW5pbmdCZWhhdmlvcik7XG4gKlxuICogVGhlIHJlc3VsdCBjYW4gdGhlbiBiZSB1c2VkIGFzIGJvdGggYSBtZXRob2QgYXNzZXJ0aW9uLCBleGVjdXRpbmcgYm90aCBgbWV0aG9kYCBhbmRcbiAqIGBjaGFpbmluZ0JlaGF2aW9yYCwgb3IgYXMgYSBsYW5ndWFnZSBjaGFpbiwgd2hpY2ggb25seSBleGVjdXRlcyBgY2hhaW5pbmdCZWhhdmlvcmAuXG4gKlxuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvbygnYmFyJyk7XG4gKiAgICAgZXhwZWN0KGZvb1N0cikudG8uYmUuZm9vLmVxdWFsKCdmb28nKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB0byB3aGljaCB0aGUgbWV0aG9kIGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgYG5hbWVgLCB3aGVuIGNhbGxlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hhaW5pbmdCZWhhdmlvciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWRcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGFkZENoYWluYWJsZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcikge1xuICBpZiAodHlwZW9mIGNoYWluaW5nQmVoYXZpb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGFpbmluZ0JlaGF2aW9yID0gZnVuY3Rpb24gKCkgeyB9O1xuICB9XG5cbiAgdmFyIGNoYWluYWJsZUJlaGF2aW9yID0ge1xuICAgICAgbWV0aG9kOiBtZXRob2RcbiAgICAsIGNoYWluaW5nQmVoYXZpb3I6IGNoYWluaW5nQmVoYXZpb3JcbiAgfTtcblxuICAvLyBzYXZlIHRoZSBtZXRob2RzIHNvIHdlIGNhbiBvdmVyd3JpdGUgdGhlbSBsYXRlciwgaWYgd2UgbmVlZCB0by5cbiAgaWYgKCFjdHguX19tZXRob2RzKSB7XG4gICAgY3R4Ll9fbWV0aG9kcyA9IHt9O1xuICB9XG4gIGN0eC5fX21ldGhvZHNbbmFtZV0gPSBjaGFpbmFibGVCZWhhdmlvcjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3IuY2FsbCh0aGlzKTtcblxuICAgICAgICB2YXIgYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KCkge1xuICAgICAgICAgIHZhciBvbGRfc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICAgICAgICBpZiAob2xkX3NzZmkgJiYgY29uZmlnLmluY2x1ZGVTdGFjayA9PT0gZmFsc2UpXG4gICAgICAgICAgICBmbGFnKHRoaXMsICdzc2ZpJywgYXNzZXJ0KTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVc2UgYF9fcHJvdG9fX2AgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChoYXNQcm90b1N1cHBvcnQpIHtcbiAgICAgICAgICAvLyBJbmhlcml0IGFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIG9iamVjdCBieSByZXBsYWNpbmcgdGhlIGBGdW5jdGlvbmAgcHJvdG90eXBlXG4gICAgICAgICAgdmFyIHByb3RvdHlwZSA9IGFzc2VydC5fX3Byb3RvX18gPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGBjYWxsYCBhbmQgYGFwcGx5YCBtZXRob2RzIGZyb20gYEZ1bmN0aW9uYFxuICAgICAgICAgIHByb3RvdHlwZS5jYWxsID0gY2FsbDtcbiAgICAgICAgICBwcm90b3R5cGUuYXBwbHkgPSBhcHBseTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHJlZGVmaW5lIGFsbCBwcm9wZXJ0aWVzIChzbG93ISlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGFzc2VydGVyTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjdHgpO1xuICAgICAgICAgIGFzc2VydGVyTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoYXNzZXJ0ZXJOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWV4Y2x1ZGVOYW1lcy50ZXN0KGFzc2VydGVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgdmFyIHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdHgsIGFzc2VydGVyTmFtZSk7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhc3NlcnQsIGFzc2VydGVyTmFtZSwgcGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNmZXJGbGFncyh0aGlzLCBhc3NlcnQpO1xuICAgICAgICByZXR1cm4gYXNzZXJ0O1xuICAgICAgfVxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9hZGRDaGFpbmFibGVNZXRob2QuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kIChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcilcbiAqXG4gKiBPdmVyd2l0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBjaGFpbmFibGUgbWV0aG9kXG4gKiBhbmQgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBwcmV2aW91cyBmdW5jdGlvbiBvclxuICogcHJvcGVydHkuICBNdXN0IHJldHVybiBmdW5jdGlvbnMgdG8gYmUgdXNlZCBmb3JcbiAqIG5hbWUuXG4gKlxuICogICAgIHV0aWxzLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdsZW5ndGgnLFxuICogICAgICAgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgfVxuICogICAgICwgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgfVxuICogICAgICk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoJ2ZvbycsIGZuLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmhhdmUubGVuZ3RoKDMpO1xuICogICAgIGV4cGVjdChteUZvbykudG8uaGF2ZS5sZW5ndGguYWJvdmUoMyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgbWV0aG9kIC8gcHJvcGVydHkgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCAvIHByb3BlcnR5IHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoYWluaW5nQmVoYXZpb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgcHJvcGVydHlcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcikge1xuICB2YXIgY2hhaW5hYmxlQmVoYXZpb3IgPSBjdHguX19tZXRob2RzW25hbWVdO1xuXG4gIHZhciBfY2hhaW5pbmdCZWhhdmlvciA9IGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3I7XG4gIGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNoYWluaW5nQmVoYXZpb3IoX2NoYWluaW5nQmVoYXZpb3IpLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgfTtcblxuICB2YXIgX21ldGhvZCA9IGNoYWluYWJsZUJlaGF2aW9yLm1ldGhvZDtcbiAgY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QoX21ldGhvZCkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogY2hhaVxuICogaHR0cDovL2NoYWlqcy5jb21cbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2NoYWksIHV0aWwpIHtcbiAgLyohXG4gICAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gICAqL1xuXG4gIHZhciBBc3NlcnRpb25FcnJvciA9IF9jaGFpLkFzc2VydGlvbkVycm9yXG4gICAgLCBmbGFnID0gdXRpbC5mbGFnO1xuXG4gIC8qIVxuICAgKiBNb2R1bGUgZXhwb3J0LlxuICAgKi9cblxuICBfY2hhaS5Bc3NlcnRpb24gPSBBc3NlcnRpb247XG5cbiAgLyohXG4gICAqIEFzc2VydGlvbiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBDcmVhdGVzIG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBBc3NlcnRpb24gKG9iaiwgbXNnLCBzdGFjaykge1xuICAgIGZsYWcodGhpcywgJ3NzZmknLCBzdGFjayB8fCBhcmd1bWVudHMuY2FsbGVlKTtcbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBvYmopO1xuICAgIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzc2VydGlvbiwgJ2luY2x1ZGVTdGFjaycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uaW5jbHVkZVN0YWNrIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5pbmNsdWRlU3RhY2sgaW5zdGVhZC4nKTtcbiAgICAgIHJldHVybiBjb25maWcuaW5jbHVkZVN0YWNrO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uaW5jbHVkZVN0YWNrIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5pbmNsdWRlU3RhY2sgaW5zdGVhZC4nKTtcbiAgICAgIGNvbmZpZy5pbmNsdWRlU3RhY2sgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3NlcnRpb24sICdzaG93RGlmZicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uc2hvd0RpZmYgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLnNob3dEaWZmIGluc3RlYWQuJyk7XG4gICAgICByZXR1cm4gY29uZmlnLnNob3dEaWZmO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uc2hvd0RpZmYgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLnNob3dEaWZmIGluc3RlYWQuJyk7XG4gICAgICBjb25maWcuc2hvd0RpZmYgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwuYWRkUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5hZGRNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gICAgdXRpbC5hZGRDaGFpbmFibGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLm92ZXJ3cml0ZVByb3BlcnR5KHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwub3ZlcndyaXRlTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcikge1xuICAgIHV0aWwub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuYXNzZXJ0KGV4cHJlc3Npb24sIG1lc3NhZ2UsIG5lZ2F0ZU1lc3NhZ2UsIGV4cGVjdGVkLCBhY3R1YWwsIHNob3dEaWZmKVxuICAgKlxuICAgKiBFeGVjdXRlcyBhbiBleHByZXNzaW9uIGFuZCBjaGVjayBleHBlY3RhdGlvbnMuIFRocm93cyBBc3NlcnRpb25FcnJvciBmb3IgcmVwb3J0aW5nIGlmIHRlc3QgZG9lc24ndCBwYXNzLlxuICAgKlxuICAgKiBAbmFtZSBhc3NlcnRcbiAgICogQHBhcmFtIHtQaGlsb3NvcGhpY2FsfSBleHByZXNzaW9uIHRvIGJlIHRlc3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gbWVzc2FnZSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgbWVzc2FnZSB0byBkaXNwbGF5IGlmIGV4cHJlc3Npb24gZmFpbHNcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IG5lZ2F0ZWRNZXNzYWdlIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBuZWdhdGVkTWVzc2FnZSB0byBkaXNwbGF5IGlmIG5lZ2F0ZWQgZXhwcmVzc2lvbiBmYWlsc1xuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZCB2YWx1ZSAocmVtZW1iZXIgdG8gY2hlY2sgZm9yIG5lZ2F0aW9uKVxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWwgKG9wdGlvbmFsKSB3aWxsIGRlZmF1bHQgdG8gYHRoaXMub2JqYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3dEaWZmIChvcHRpb25hbCkgd2hlbiBzZXQgdG8gYHRydWVgLCBhc3NlcnQgd2lsbCBkaXNwbGF5IGEgZGlmZiBpbiBhZGRpdGlvbiB0byB0aGUgbWVzc2FnZSBpZiBleHByZXNzaW9uIGZhaWxzXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBBc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCA9IGZ1bmN0aW9uIChleHByLCBtc2csIG5lZ2F0ZU1zZywgZXhwZWN0ZWQsIF9hY3R1YWwsIHNob3dEaWZmKSB7XG4gICAgdmFyIG9rID0gdXRpbC50ZXN0KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHRydWUgIT09IHNob3dEaWZmKSBzaG93RGlmZiA9IGZhbHNlO1xuICAgIGlmICh0cnVlICE9PSBjb25maWcuc2hvd0RpZmYpIHNob3dEaWZmID0gZmFsc2U7XG5cbiAgICBpZiAoIW9rKSB7XG4gICAgICB2YXIgbXNnID0gdXRpbC5nZXRNZXNzYWdlKHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgLCBhY3R1YWwgPSB1dGlsLmdldEFjdHVhbCh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1zZywge1xuICAgICAgICAgIGFjdHVhbDogYWN0dWFsXG4gICAgICAgICwgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAgICwgc2hvd0RpZmY6IHNob3dEaWZmXG4gICAgICB9LCAoY29uZmlnLmluY2x1ZGVTdGFjaykgPyB0aGlzLmFzc2VydCA6IGZsYWcodGhpcywgJ3NzZmknKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qIVxuICAgKiAjIyMgLl9vYmpcbiAgICpcbiAgICogUXVpY2sgcmVmZXJlbmNlIHRvIHN0b3JlZCBgYWN0dWFsYCB2YWx1ZSBmb3IgcGx1Z2luIGRldmVsb3BlcnMuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ19vYmonLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICAgIH1cbiAgICAsIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCB2YWwpO1xuICAgICAgfVxuICB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvYXNzZXJ0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGNoYWlcbiAqIGh0dHA6Ly9jaGFpanMuY29tXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgXykge1xuICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb25cbiAgICAsIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgICwgZmxhZyA9IF8uZmxhZztcblxuICAvKipcbiAgICogIyMjIExhbmd1YWdlIENoYWluc1xuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGFyZSBwcm92aWRlZCBhcyBjaGFpbmFibGUgZ2V0dGVycyB0b1xuICAgKiBpbXByb3ZlIHRoZSByZWFkYWJpbGl0eSBvZiB5b3VyIGFzc2VydGlvbnMuIFRoZXlcbiAgICogZG8gbm90IHByb3ZpZGUgdGVzdGluZyBjYXBhYmlsaXRpZXMgdW5sZXNzIHRoZXlcbiAgICogaGF2ZSBiZWVuIG92ZXJ3cml0dGVuIGJ5IGEgcGx1Z2luLlxuICAgKlxuICAgKiAqKkNoYWlucyoqXG4gICAqXG4gICAqIC0gdG9cbiAgICogLSBiZVxuICAgKiAtIGJlZW5cbiAgICogLSBpc1xuICAgKiAtIHRoYXRcbiAgICogLSB3aGljaFxuICAgKiAtIGFuZFxuICAgKiAtIGhhc1xuICAgKiAtIGhhdmVcbiAgICogLSB3aXRoXG4gICAqIC0gYXRcbiAgICogLSBvZlxuICAgKiAtIHNhbWVcbiAgICpcbiAgICogQG5hbWUgbGFuZ3VhZ2UgY2hhaW5zXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIFsgJ3RvJywgJ2JlJywgJ2JlZW4nXG4gICwgJ2lzJywgJ2FuZCcsICdoYXMnLCAnaGF2ZSdcbiAgLCAnd2l0aCcsICd0aGF0JywgJ3doaWNoJywgJ2F0J1xuICAsICdvZicsICdzYW1lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KGNoYWluLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAubm90XG4gICAqXG4gICAqIE5lZ2F0ZXMgYW55IG9mIGFzc2VydGlvbnMgZm9sbG93aW5nIGluIHRoZSBjaGFpbi5cbiAgICpcbiAgICogICAgIGV4cGVjdChmb28pLnRvLm5vdC5lcXVhbCgnYmFyJyk7XG4gICAqICAgICBleHBlY3QoZ29vZEZuKS50by5ub3QudGhyb3coRXJyb3IpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmF6JyB9KS50by5oYXZlLnByb3BlcnR5KCdmb28nKVxuICAgKiAgICAgICAuYW5kLm5vdC5lcXVhbCgnYmFyJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ25vdCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICduZWdhdGUnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFxuICAgKlxuICAgKiBTZXRzIHRoZSBgZGVlcGAgZmxhZywgbGF0ZXIgdXNlZCBieSB0aGUgYGVxdWFsYCBhbmRcbiAgICogYHByb3BlcnR5YCBhc3NlcnRpb25zLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZvbykudG8uZGVlcC5lcXVhbCh7IGJhcjogJ2JheicgfSk7XG4gICAqICAgICBleHBlY3QoeyBmb286IHsgYmFyOiB7IGJhejogJ3F1dXgnIH0gfSB9KVxuICAgKiAgICAgICAudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCdmb28uYmFyLmJheicsICdxdXV4Jyk7XG4gICAqXG4gICAqIGAuZGVlcC5wcm9wZXJ0eWAgc3BlY2lhbCBjaGFyYWN0ZXJzIGNhbiBiZSBlc2NhcGVkXG4gICAqIGJ5IGFkZGluZyB0d28gc2xhc2hlcyBiZWZvcmUgdGhlIGAuYCBvciBgW11gLlxuICAgKlxuICAgKiAgICAgdmFyIGRlZXBDc3MgPSB7ICcubGluayc6IHsgJ1t0YXJnZXRdJzogNDIgfX07XG4gICAqICAgICBleHBlY3QoZGVlcENzcykudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCdcXFxcLmxpbmsuXFxcXFt0YXJnZXRcXFxcXScsIDQyKTtcbiAgICpcbiAgICogQG5hbWUgZGVlcFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2RlZXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnZGVlcCcsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hbnlcbiAgICpcbiAgICogU2V0cyB0aGUgYGFueWAgZmxhZywgKG9wcG9zaXRlIG9mIHRoZSBgYWxsYCBmbGFnKVxuICAgKiBsYXRlciB1c2VkIGluIHRoZSBga2V5c2AgYXNzZXJ0aW9uLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZvbykudG8uaGF2ZS5hbnkua2V5cygnYmFyJywgJ2JheicpO1xuICAgKlxuICAgKiBAbmFtZSBhbnlcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdhbnknLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnYW55JywgdHJ1ZSk7XG4gICAgZmxhZyh0aGlzLCAnYWxsJywgZmFsc2UpXG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqICMjIyAuYWxsXG4gICAqXG4gICAqIFNldHMgdGhlIGBhbGxgIGZsYWcgKG9wcG9zaXRlIG9mIHRoZSBgYW55YCBmbGFnKVxuICAgKiBsYXRlciB1c2VkIGJ5IHRoZSBga2V5c2AgYXNzZXJ0aW9uLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZvbykudG8uaGF2ZS5hbGwua2V5cygnYmFyJywgJ2JheicpO1xuICAgKlxuICAgKiBAbmFtZSBhbGxcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdhbGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnYWxsJywgdHJ1ZSk7XG4gICAgZmxhZyh0aGlzLCAnYW55JywgZmFsc2UpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hKHR5cGUpXG4gICAqXG4gICAqIFRoZSBgYWAgYW5kIGBhbmAgYXNzZXJ0aW9ucyBhcmUgYWxpYXNlcyB0aGF0IGNhbiBiZVxuICAgKiB1c2VkIGVpdGhlciBhcyBsYW5ndWFnZSBjaGFpbnMgb3IgdG8gYXNzZXJ0IGEgdmFsdWUnc1xuICAgKiB0eXBlLlxuICAgKlxuICAgKiAgICAgLy8gdHlwZW9mXG4gICAqICAgICBleHBlY3QoJ3Rlc3QnKS50by5iZS5hKCdzdHJpbmcnKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogJ2JhcicgfSkudG8uYmUuYW4oJ29iamVjdCcpO1xuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLmEoJ251bGwnKTtcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLmFuKCd1bmRlZmluZWQnKTtcbiAgICogICAgIGV4cGVjdChuZXcgRXJyb3IpLnRvLmJlLmFuKCdlcnJvcicpO1xuICAgKiAgICAgZXhwZWN0KG5ldyBQcm9taXNlKS50by5iZS5hKCdwcm9taXNlJyk7XG4gICAqICAgICBleHBlY3QobmV3IEZsb2F0MzJBcnJheSgpKS50by5iZS5hKCdmbG9hdDMyYXJyYXknKTtcbiAgICogICAgIGV4cGVjdChTeW1ib2woKSkudG8uYmUuYSgnc3ltYm9sJyk7XG4gICAqXG4gICAqICAgICAvLyBlczYgb3ZlcnJpZGVzXG4gICAqICAgICBleHBlY3Qoe1tTeW1ib2wudG9TdHJpbmdUYWddOigpPT4nZm9vJ30pLnRvLmJlLmEoJ2ZvbycpO1xuICAgKlxuICAgKiAgICAgLy8gbGFuZ3VhZ2UgY2hhaW5cbiAgICogICAgIGV4cGVjdChmb28pLnRvLmJlLmFuLmluc3RhbmNlb2YoRm9vKTtcbiAgICpcbiAgICogQG5hbWUgYVxuICAgKiBAYWxpYXMgYW5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhbiAodHlwZSwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgYXJ0aWNsZSA9IH5bICdhJywgJ2UnLCAnaScsICdvJywgJ3UnIF0uaW5kZXhPZih0eXBlLmNoYXJBdCgwKSkgPyAnYW4gJyA6ICdhICc7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdHlwZSA9PT0gXy50eXBlKG9iailcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgJyArIGFydGljbGUgKyB0eXBlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSAnICsgYXJ0aWNsZSArIHR5cGVcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnYW4nLCBhbik7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2EnLCBhbik7XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZSh2YWx1ZSlcbiAgICpcbiAgICogVGhlIGBpbmNsdWRlYCBhbmQgYGNvbnRhaW5gIGFzc2VydGlvbnMgY2FuIGJlIHVzZWQgYXMgZWl0aGVyIHByb3BlcnR5XG4gICAqIGJhc2VkIGxhbmd1YWdlIGNoYWlucyBvciBhcyBtZXRob2RzIHRvIGFzc2VydCB0aGUgaW5jbHVzaW9uIG9mIGFuIG9iamVjdFxuICAgKiBpbiBhbiBhcnJheSBvciBhIHN1YnN0cmluZyBpbiBhIHN0cmluZy4gV2hlbiB1c2VkIGFzIGxhbmd1YWdlIGNoYWlucyxcbiAgICogdGhleSB0b2dnbGUgdGhlIGBjb250YWluc2AgZmxhZyBmb3IgdGhlIGBrZXlzYCBhc3NlcnRpb24uXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsMiwzXSkudG8uaW5jbHVkZSgyKTtcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uY29udGFpbignZm9vJyk7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXInLCBoZWxsbzogJ3VuaXZlcnNlJyB9KS50by5pbmNsdWRlLmtleXMoJ2ZvbycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlXG4gICAqIEBhbGlhcyBjb250YWluXG4gICAqIEBhbGlhcyBpbmNsdWRlc1xuICAgKiBAYWxpYXMgY29udGFpbnNcbiAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfE51bWJlcn0gb2JqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IgKCkge1xuICAgIGZsYWcodGhpcywgJ2NvbnRhaW5zJywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmNsdWRlICh2YWwsIG1zZykge1xuICAgIF8uZXhwZWN0VHlwZXModGhpcywgWydhcnJheScsICdvYmplY3QnLCAnc3RyaW5nJ10pO1xuXG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHZhciBleHBlY3RlZCA9IGZhbHNlO1xuXG4gICAgaWYgKF8udHlwZShvYmopID09PSAnYXJyYXknICYmIF8udHlwZSh2YWwpID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKF8uZXFsKG9ialtpXSwgdmFsKSkge1xuICAgICAgICAgIGV4cGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXy50eXBlKHZhbCkgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoIWZsYWcodGhpcywgJ25lZ2F0ZScpKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gdmFsKSBuZXcgQXNzZXJ0aW9uKG9iaikucHJvcGVydHkoaywgdmFsW2tdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHN1YnNldCA9IHt9O1xuICAgICAgZm9yICh2YXIgayBpbiB2YWwpIHN1YnNldFtrXSA9IG9ialtrXTtcbiAgICAgIGV4cGVjdGVkID0gXy5lcWwoc3Vic2V0LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBlY3RlZCA9IChvYmogIT0gdW5kZWZpbmVkKSAmJiB+b2JqLmluZGV4T2YodmFsKTtcbiAgICB9XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGV4cGVjdGVkXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGluY2x1ZGUgJyArIF8uaW5zcGVjdCh2YWwpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBpbmNsdWRlICcgKyBfLmluc3BlY3QodmFsKSk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdpbmNsdWRlJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdjb250YWluJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdjb250YWlucycsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnaW5jbHVkZXMnLCBpbmNsdWRlLCBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvcik7XG5cbiAgLyoqXG4gICAqICMjIyAub2tcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgdHJ1dGh5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdldmVyeXRoaW5nJykudG8uYmUub2s7XG4gICAqICAgICBleHBlY3QoMSkudG8uYmUub2s7XG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLm5vdC5iZS5vaztcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLm5vdC5iZS5vaztcbiAgICogICAgIGV4cGVjdChudWxsKS50by5ub3QuYmUub2s7XG4gICAqXG4gICAqIEBuYW1lIG9rXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnb2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydXRoeSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZmFsc3knKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAudHJ1ZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBgdHJ1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QodHJ1ZSkudG8uYmUudHJ1ZTtcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUudHJ1ZTtcbiAgICpcbiAgICogQG5hbWUgdHJ1ZVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ3RydWUnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHRydWUgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydWUnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHNlJ1xuICAgICAgLCB0aGlzLm5lZ2F0ZSA/IGZhbHNlIDogdHJ1ZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmZhbHNlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGBmYWxzZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLmJlLmZhbHNlO1xuICAgKiAgICAgZXhwZWN0KDApLnRvLm5vdC5iZS5mYWxzZTtcbiAgICpcbiAgICogQG5hbWUgZmFsc2VcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdmYWxzZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZmFsc2UgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnVlJ1xuICAgICAgLCB0aGlzLm5lZ2F0ZSA/IHRydWUgOiBmYWxzZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm51bGxcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYG51bGxgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLm51bGw7XG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5ub3QuYmUubnVsbDtcbiAgICpcbiAgICogQG5hbWUgbnVsbFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ251bGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG51bGwgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIG51bGwnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBudWxsJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnVuZGVmaW5lZFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLnVuZGVmaW5lZDtcbiAgICogICAgIGV4cGVjdChudWxsKS50by5ub3QuYmUudW5kZWZpbmVkO1xuICAgKlxuICAgKiBAbmFtZSB1bmRlZmluZWRcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCd1bmRlZmluZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHVuZGVmaW5lZCA9PT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdW5kZWZpbmVkJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgdW5kZWZpbmVkJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLk5hTlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBgTmFOYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uYmUuTmFOO1xuICAgKiAgICAgZXhwZWN0KDQpLm5vdC50by5iZS5OYU47XG4gICAqXG4gICAqIEBuYW1lIE5hTlxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ05hTicsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgaXNOYU4oZmxhZyh0aGlzLCAnb2JqZWN0JykpXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgTmFOJ1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBOYU4nXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXhpc3RcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbmVpdGhlciBgbnVsbGAgbm9yIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgdmFyIGZvbyA9ICdoaSdcbiAgICogICAgICAgLCBiYXIgPSBudWxsXG4gICAqICAgICAgICwgYmF6O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGZvbykudG8uZXhpc3Q7XG4gICAqICAgICBleHBlY3QoYmFyKS50by5ub3QuZXhpc3Q7XG4gICAqICAgICBleHBlY3QoYmF6KS50by5ub3QuZXhpc3Q7XG4gICAqXG4gICAqIEBuYW1lIGV4aXN0XG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZXhpc3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG51bGwgIT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXhpc3QnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBleGlzdCdcbiAgICApO1xuICB9KTtcblxuXG4gIC8qKlxuICAgKiAjIyMgLmVtcHR5XG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3MgbGVuZ3RoIGlzIGAwYC4gRm9yIGFycmF5cyBhbmQgc3RyaW5ncywgaXQgY2hlY2tzXG4gICAqIHRoZSBgbGVuZ3RoYCBwcm9wZXJ0eS4gRm9yIG9iamVjdHMsIGl0IGdldHMgdGhlIGNvdW50IG9mXG4gICAqIGVudW1lcmFibGUga2V5cy5cbiAgICpcbiAgICogICAgIGV4cGVjdChbXSkudG8uYmUuZW1wdHk7XG4gICAqICAgICBleHBlY3QoJycpLnRvLmJlLmVtcHR5O1xuICAgKiAgICAgZXhwZWN0KHt9KS50by5iZS5lbXB0eTtcbiAgICpcbiAgICogQG5hbWUgZW1wdHlcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdlbXB0eScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZXhwZWN0ZWQgPSBvYmo7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopIHx8ICdzdHJpbmcnID09PSB0eXBlb2Ygb2JqZWN0KSB7XG4gICAgICBleHBlY3RlZCA9IG9iai5sZW5ndGg7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgZXhwZWN0ZWQgPSBPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgIWV4cGVjdGVkXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGVtcHR5J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgZW1wdHknXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuYXJndW1lbnRzXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGFuIGFyZ3VtZW50cyBvYmplY3QuXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiB0ZXN0ICgpIHtcbiAgICogICAgICAgZXhwZWN0KGFyZ3VtZW50cykudG8uYmUuYXJndW1lbnRzO1xuICAgKiAgICAgfVxuICAgKlxuICAgKiBAbmFtZSBhcmd1bWVudHNcbiAgICogQGFsaWFzIEFyZ3VtZW50c1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBjaGVja0FyZ3VtZW50cyAoKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgJ1tvYmplY3QgQXJndW1lbnRzXScgPT09IHR5cGVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXJndW1lbnRzIGJ1dCBnb3QgJyArIHR5cGVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFyZ3VtZW50cydcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdhcmd1bWVudHMnLCBjaGVja0FyZ3VtZW50cyk7XG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnQXJndW1lbnRzJywgY2hlY2tBcmd1bWVudHMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmVxdWFsKHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBzdHJpY3RseSBlcXVhbCAoYD09PWApIHRvIGB2YWx1ZWAuXG4gICAqIEFsdGVybmF0ZWx5LCBpZiB0aGUgYGRlZXBgIGZsYWcgaXMgc2V0LCBhc3NlcnRzIHRoYXRcbiAgICogdGhlIHRhcmdldCBpcyBkZWVwbHkgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnaGVsbG8nKS50by5lcXVhbCgnaGVsbG8nKTtcbiAgICogICAgIGV4cGVjdCg0MikudG8uZXF1YWwoNDIpO1xuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5lcXVhbCh0cnVlKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogJ2JhcicgfSkudG8ubm90LmVxdWFsKHsgZm9vOiAnYmFyJyB9KTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogJ2JhcicgfSkudG8uZGVlcC5lcXVhbCh7IGZvbzogJ2JhcicgfSk7XG4gICAqXG4gICAqIEBuYW1lIGVxdWFsXG4gICAqIEBhbGlhcyBlcXVhbHNcbiAgICogQGFsaWFzIGVxXG4gICAqIEBhbGlhcyBkZWVwLmVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0RXF1YWwgKHZhbCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIGlmIChmbGFnKHRoaXMsICdkZWVwJykpIHtcbiAgICAgIHJldHVybiB0aGlzLmVxbCh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICB2YWwgPT09IG9ialxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGVxdWFsICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3tleHB9J1xuICAgICAgICAsIHZhbFxuICAgICAgICAsIHRoaXMuX29ialxuICAgICAgICAsIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXF1YWwnLCBhc3NlcnRFcXVhbCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxdWFscycsIGFzc2VydEVxdWFsKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXEnLCBhc3NlcnRFcXVhbCk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXFsKHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBkZWVwbHkgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7IGZvbzogJ2JhcicgfSkudG8uZXFsKHsgZm9vOiAnYmFyJyB9KTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uZXFsKFsgMSwgMiwgMyBdKTtcbiAgICpcbiAgICogQG5hbWUgZXFsXG4gICAqIEBhbGlhcyBlcWxzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0RXFsKG9iaiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIF8uZXFsKG9iaiwgZmxhZyh0aGlzLCAnb2JqZWN0JykpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGRlZXBseSBlcXVhbCAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBkZWVwbHkgZXF1YWwgI3tleHB9J1xuICAgICAgLCBvYmpcbiAgICAgICwgdGhpcy5fb2JqXG4gICAgICAsIHRydWVcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXFsJywgYXNzZXJ0RXFsKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXFscycsIGFzc2VydEVxbCk7XG5cbiAgLyoqXG4gICAqICMjIyAuYWJvdmUodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGdyZWF0ZXIgdGhhbiBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEwKS50by5iZS5hYm92ZSg1KTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIG1pbmltdW0gbGVuZ3RoLiBUaGUgYmVuZWZpdCBiZWluZyBhXG4gICAqIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSB0aGFuIGlmIHRoZSBsZW5ndGhcbiAgICogd2FzIHN1cHBsaWVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5hYm92ZSgyKTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGguYWJvdmUoMik7XG4gICAqXG4gICAqIEBuYW1lIGFib3ZlXG4gICAqIEBhbGlhcyBndFxuICAgKiBAYWxpYXMgZ3JlYXRlclRoYW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0QWJvdmUgKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBpZiAoZmxhZyh0aGlzLCAnZG9MZW5ndGgnKSkge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGxlbiA+IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIGFib3ZlICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhIGxlbmd0aCBhYm92ZSAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGxlblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqID4gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFib3ZlICcgKyBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbW9zdCAnICsgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdhYm92ZScsIGFzc2VydEFib3ZlKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3QnLCBhc3NlcnRBYm92ZSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2dyZWF0ZXJUaGFuJywgYXNzZXJ0QWJvdmUpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmxlYXN0KHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxMCkudG8uYmUuYXQubGVhc3QoMTApO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGxlbmd0aGAgdG9cbiAgICogYXNzZXJ0IGEgbWluaW11bSBsZW5ndGguIFRoZSBiZW5lZml0IGJlaW5nIGFcbiAgICogbW9yZSBpbmZvcm1hdGl2ZSBlcnJvciBtZXNzYWdlIHRoYW4gaWYgdGhlIGxlbmd0aFxuICAgKiB3YXMgc3VwcGxpZWQgZGlyZWN0bHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLm9mLmF0LmxlYXN0KDIpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5vZi5hdC5sZWFzdCgzKTtcbiAgICpcbiAgICogQG5hbWUgbGVhc3RcbiAgICogQGFsaWFzIGd0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRMZWFzdCAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuID49IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIGF0IGxlYXN0ICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIGJlbG93ICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICAgICwgbGVuXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPj0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IGxlYXN0ICcgKyBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYmVsb3cgJyArIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbGVhc3QnLCBhc3NlcnRMZWFzdCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2d0ZScsIGFzc2VydExlYXN0KTtcblxuICAvKipcbiAgICogIyMjIC5iZWxvdyh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbGVzcyB0aGFuIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoNSkudG8uYmUuYmVsb3coMTApO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGxlbmd0aGAgdG9cbiAgICogYXNzZXJ0IGEgbWF4aW11bSBsZW5ndGguIFRoZSBiZW5lZml0IGJlaW5nIGFcbiAgICogbW9yZSBpbmZvcm1hdGl2ZSBlcnJvciBtZXNzYWdlIHRoYW4gaWYgdGhlIGxlbmd0aFxuICAgKiB3YXMgc3VwcGxpZWQgZGlyZWN0bHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLmJlbG93KDQpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5iZWxvdyg0KTtcbiAgICpcbiAgICogQG5hbWUgYmVsb3dcbiAgICogQGFsaWFzIGx0XG4gICAqIEBhbGlhcyBsZXNzVGhhblxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRCZWxvdyAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuIDwgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYmVsb3cgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgbGVuZ3RoIGJlbG93ICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICAgICwgbGVuXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPCBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYmVsb3cgJyArIG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBsZWFzdCAnICsgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdiZWxvdycsIGFzc2VydEJlbG93KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbHQnLCBhc3NlcnRCZWxvdyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2xlc3NUaGFuJywgYXNzZXJ0QmVsb3cpO1xuXG4gIC8qKlxuICAgKiAjIyMgLm1vc3QodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDUpLnRvLmJlLmF0Lm1vc3QoNSk7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgbGVuZ3RoYCB0b1xuICAgKiBhc3NlcnQgYSBtYXhpbXVtIGxlbmd0aC4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGgub2YuYXQubW9zdCg0KTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGgub2YuYXQubW9zdCgzKTtcbiAgICpcbiAgICogQG5hbWUgbW9zdFxuICAgKiBAYWxpYXMgbHRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydE1vc3QgKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBpZiAoZmxhZyh0aGlzLCAnZG9MZW5ndGgnKSkge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGxlbiA8PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBhdCBtb3N0ICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIGFib3ZlICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICAgICwgbGVuXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPD0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IG1vc3QgJyArIG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhYm92ZSAnICsgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtb3N0JywgYXNzZXJ0TW9zdCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2x0ZScsIGFzc2VydE1vc3QpO1xuXG4gIC8qKlxuICAgKiAjIyMgLndpdGhpbihzdGFydCwgZmluaXNoKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyB3aXRoaW4gYSByYW5nZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCg3KS50by5iZS53aXRoaW4oNSwxMCk7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgbGVuZ3RoYCB0b1xuICAgKiBhc3NlcnQgYSBsZW5ndGggcmFuZ2UuIFRoZSBiZW5lZml0IGJlaW5nIGFcbiAgICogbW9yZSBpbmZvcm1hdGl2ZSBlcnJvciBtZXNzYWdlIHRoYW4gaWYgdGhlIGxlbmd0aFxuICAgKiB3YXMgc3VwcGxpZWQgZGlyZWN0bHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLndpdGhpbigyLDQpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC53aXRoaW4oMiw0KTtcbiAgICpcbiAgICogQG5hbWUgd2l0aGluXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBsb3dlcmJvdW5kIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZmluaXNoIHVwcGVyYm91bmQgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnd2l0aGluJywgZnVuY3Rpb24gKHN0YXJ0LCBmaW5pc2gsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCByYW5nZSA9IHN0YXJ0ICsgJy4uJyArIGZpbmlzaDtcbiAgICBpZiAoZmxhZyh0aGlzLCAnZG9MZW5ndGgnKSkge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGxlbiA+PSBzdGFydCAmJiBsZW4gPD0gZmluaXNoXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCB3aXRoaW4gJyArIHJhbmdlXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggd2l0aGluICcgKyByYW5nZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqID49IHN0YXJ0ICYmIG9iaiA8PSBmaW5pc2hcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB3aXRoaW4gJyArIHJhbmdlXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5pbnN0YW5jZW9mKGNvbnN0cnVjdG9yKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhbiBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgLlxuICAgKlxuICAgKiAgICAgdmFyIFRlYSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMubmFtZSA9IG5hbWU7IH1cbiAgICogICAgICAgLCBDaGFpID0gbmV3IFRlYSgnY2hhaScpO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KENoYWkpLnRvLmJlLmFuLmluc3RhbmNlb2YoVGVhKTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uYmUuaW5zdGFuY2VvZihBcnJheSk7XG4gICAqXG4gICAqIEBuYW1lIGluc3RhbmNlb2ZcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYWxpYXMgaW5zdGFuY2VPZlxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRJbnN0YW5jZU9mIChjb25zdHJ1Y3RvciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG5hbWUgPSBfLmdldE5hbWUoY29uc3RydWN0b3IpO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnKSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFuIGluc3RhbmNlIG9mICcgKyBuYW1lXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBhbiBpbnN0YW5jZSBvZiAnICsgbmFtZVxuICAgICk7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaW5zdGFuY2VvZicsIGFzc2VydEluc3RhbmNlT2YpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbnN0YW5jZU9mJywgYXNzZXJ0SW5zdGFuY2VPZik7XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHkobmFtZSwgW3ZhbHVlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaGFzIGEgcHJvcGVydHkgYG5hbWVgLCBvcHRpb25hbGx5IGFzc2VydGluZyB0aGF0XG4gICAqIHRoZSB2YWx1ZSBvZiB0aGF0IHByb3BlcnR5IGlzIHN0cmljdGx5IGVxdWFsIHRvICBgdmFsdWVgLlxuICAgKiBJZiB0aGUgYGRlZXBgIGZsYWcgaXMgc2V0LCB5b3UgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBkZWVwXG4gICAqIHJlZmVyZW5jZXMgaW50byBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAqXG4gICAqICAgICAvLyBzaW1wbGUgcmVmZXJlbmNpbmdcbiAgICogICAgIHZhciBvYmogPSB7IGZvbzogJ2JhcicgfTtcbiAgICogICAgIGV4cGVjdChvYmopLnRvLmhhdmUucHJvcGVydHkoJ2ZvbycpO1xuICAgKiAgICAgZXhwZWN0KG9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZm9vJywgJ2JhcicpO1xuICAgKlxuICAgKiAgICAgLy8gZGVlcCByZWZlcmVuY2luZ1xuICAgKiAgICAgdmFyIGRlZXBPYmogPSB7XG4gICAqICAgICAgICAgZ3JlZW46IHsgdGVhOiAnbWF0Y2hhJyB9XG4gICAqICAgICAgICwgdGVhczogWyAnY2hhaScsICdtYXRjaGEnLCB7IHRlYTogJ2tvbmFjaGEnIH0gXVxuICAgKiAgICAgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChkZWVwT2JqKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ2dyZWVuLnRlYScsICdtYXRjaGEnKTtcbiAgICogICAgIGV4cGVjdChkZWVwT2JqKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ3RlYXNbMV0nLCAnbWF0Y2hhJyk7XG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCd0ZWFzWzJdLnRlYScsICdrb25hY2hhJyk7XG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyB1c2UgYW4gYXJyYXkgYXMgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIGEgYGRlZXAucHJvcGVydHlgXG4gICAqIGFzc2VydGlvbiwgb3IgdHJhdmVyc2UgbmVzdGVkIGFycmF5cy5cbiAgICpcbiAgICogICAgIHZhciBhcnIgPSBbXG4gICAqICAgICAgICAgWyAnY2hhaScsICdtYXRjaGEnLCAna29uYWNoYScgXVxuICAgKiAgICAgICAsIFsgeyB0ZWE6ICdjaGFpJyB9XG4gICAqICAgICAgICAgLCB7IHRlYTogJ21hdGNoYScgfVxuICAgKiAgICAgICAgICwgeyB0ZWE6ICdrb25hY2hhJyB9IF1cbiAgICogICAgIF07XG4gICAqXG4gICAqICAgICBleHBlY3QoYXJyKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ1swXVsxXScsICdtYXRjaGEnKTtcbiAgICogICAgIGV4cGVjdChhcnIpLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgnWzFdWzJdLnRlYScsICdrb25hY2hhJyk7XG4gICAqXG4gICAqIEZ1cnRoZXJtb3JlLCBgcHJvcGVydHlgIGNoYW5nZXMgdGhlIHN1YmplY3Qgb2YgdGhlIGFzc2VydGlvblxuICAgKiB0byBiZSB0aGUgdmFsdWUgb2YgdGhhdCBwcm9wZXJ0eSBmcm9tIHRoZSBvcmlnaW5hbCBvYmplY3QuIFRoaXNcbiAgICogcGVybWl0cyBmb3IgZnVydGhlciBjaGFpbmFibGUgYXNzZXJ0aW9ucyBvbiB0aGF0IHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZm9vJylcbiAgICogICAgICAgLnRoYXQuaXMuYSgnc3RyaW5nJyk7XG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZ3JlZW4nKVxuICAgKiAgICAgICAudGhhdC5pcy5hbignb2JqZWN0JylcbiAgICogICAgICAgLnRoYXQuZGVlcC5lcXVhbHMoeyB0ZWE6ICdtYXRjaGEnIH0pO1xuICAgKiAgICAgZXhwZWN0KGRlZXBPYmopLnRvLmhhdmUucHJvcGVydHkoJ3RlYXMnKVxuICAgKiAgICAgICAudGhhdC5pcy5hbignYXJyYXknKVxuICAgKiAgICAgICAud2l0aC5kZWVwLnByb3BlcnR5KCdbMl0nKVxuICAgKiAgICAgICAgIC50aGF0LmRlZXAuZXF1YWxzKHsgdGVhOiAna29uYWNoYScgfSk7XG4gICAqXG4gICAqIE5vdGUgdGhhdCBkb3RzIGFuZCBicmFja2V0IGluIGBuYW1lYCBtdXN0IGJlIGJhY2tzbGFzaC1lc2NhcGVkIHdoZW5cbiAgICogdGhlIGBkZWVwYCBmbGFnIGlzIHNldCwgd2hpbGUgdGhleSBtdXN0IE5PVCBiZSBlc2NhcGVkIHdoZW4gdGhlIGBkZWVwYFxuICAgKiBmbGFnIGlzIG5vdCBzZXQuXG4gICAqXG4gICAqICAgICAvLyBzaW1wbGUgcmVmZXJlbmNpbmdcbiAgICogICAgIHZhciBjc3MgPSB7ICcubGlua1t0YXJnZXRdJzogNDIgfTtcbiAgICogICAgIGV4cGVjdChjc3MpLnRvLmhhdmUucHJvcGVydHkoJy5saW5rW3RhcmdldF0nLCA0Mik7XG4gICAqXG4gICAqICAgICAvLyBkZWVwIHJlZmVyZW5jaW5nXG4gICAqICAgICB2YXIgZGVlcENzcyA9IHsgJy5saW5rJzogeyAnW3RhcmdldF0nOiA0MiB9fTtcbiAgICogICAgIGV4cGVjdChkZWVwQ3NzKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ1xcXFwubGluay5cXFxcW3RhcmdldFxcXFxdJywgNDIpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVxuICAgKiBAYWxpYXMgZGVlcC5wcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQHJldHVybnMgdmFsdWUgb2YgcHJvcGVydHkgZm9yIGNoYWluaW5nXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Byb3BlcnR5JywgZnVuY3Rpb24gKG5hbWUsIHZhbCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG5cbiAgICB2YXIgaXNEZWVwID0gISFmbGFnKHRoaXMsICdkZWVwJylcbiAgICAgICwgZGVzY3JpcHRvciA9IGlzRGVlcCA/ICdkZWVwIHByb3BlcnR5ICcgOiAncHJvcGVydHkgJ1xuICAgICAgLCBuZWdhdGUgPSBmbGFnKHRoaXMsICduZWdhdGUnKVxuICAgICAgLCBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBwYXRoSW5mbyA9IGlzRGVlcCA/IF8uZ2V0UGF0aEluZm8obmFtZSwgb2JqKSA6IG51bGxcbiAgICAgICwgaGFzUHJvcGVydHkgPSBpc0RlZXBcbiAgICAgICAgPyBwYXRoSW5mby5leGlzdHNcbiAgICAgICAgOiBfLmhhc1Byb3BlcnR5KG5hbWUsIG9iailcbiAgICAgICwgdmFsdWUgPSBpc0RlZXBcbiAgICAgICAgPyBwYXRoSW5mby52YWx1ZVxuICAgICAgICA6IG9ialtuYW1lXTtcblxuICAgIGlmIChuZWdhdGUgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmICh1bmRlZmluZWQgPT09IHZhbHVlKSB7XG4gICAgICAgIG1zZyA9IChtc2cgIT0gbnVsbCkgPyBtc2cgKyAnOiAnIDogJyc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cgKyBfLmluc3BlY3Qob2JqKSArICcgaGFzIG5vICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaGFzUHJvcGVydHlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICB2YWwgPT09IHZhbHVlXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpICsgJyBvZiAje2V4cH0sIGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9mICN7YWN0fSdcbiAgICAgICAgLCB2YWxcbiAgICAgICAgLCB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCB2YWx1ZSk7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqICMjIyAub3duUHJvcGVydHkobmFtZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaGFzIGFuIG93biBwcm9wZXJ0eSBgbmFtZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ3Rlc3QnKS50by5oYXZlLm93blByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICpcbiAgICogQG5hbWUgb3duUHJvcGVydHlcbiAgICogQGFsaWFzIGhhdmVPd25Qcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydE93blByb3BlcnR5IChuYW1lLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIG93biBwcm9wZXJ0eSAnICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIG93biBwcm9wZXJ0eSAnICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ293blByb3BlcnR5JywgYXNzZXJ0T3duUHJvcGVydHkpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdoYXZlT3duUHJvcGVydHknLCBhc3NlcnRPd25Qcm9wZXJ0eSk7XG5cbiAgLyoqXG4gICAqICMjIyAub3duUHJvcGVydHlEZXNjcmlwdG9yKG5hbWVbLCBkZXNjcmlwdG9yWywgbWVzc2FnZV1dKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgYW4gb3duIHByb3BlcnR5IGRlc2NyaXB0b3IgYG5hbWVgLCB0aGF0IG9wdGlvbmFsbHkgbWF0Y2hlcyBgZGVzY3JpcHRvcmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ3Rlc3QnKS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignbGVuZ3RoJyk7XG4gICAqICAgICBleHBlY3QoJ3Rlc3QnKS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignbGVuZ3RoJywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCB2YWx1ZTogNCB9KTtcbiAgICogICAgIGV4cGVjdCgndGVzdCcpLm5vdC50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignbGVuZ3RoJywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCB2YWx1ZTogMyB9KTtcbiAgICogICAgIGV4cGVjdCgndGVzdCcpLm93blByb3BlcnR5RGVzY3JpcHRvcignbGVuZ3RoJykudG8uaGF2ZS5wcm9wZXJ0eSgnZW51bWVyYWJsZScsIGZhbHNlKTtcbiAgICogICAgIGV4cGVjdCgndGVzdCcpLm93blByb3BlcnR5RGVzY3JpcHRvcignbGVuZ3RoJykudG8uaGF2ZS5rZXlzKCd2YWx1ZScpO1xuICAgKlxuICAgKiBAbmFtZSBvd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICogQGFsaWFzIGhhdmVPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0b3IgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydE93blByb3BlcnR5RGVzY3JpcHRvciAobmFtZSwgZGVzY3JpcHRvciwgbXNnKSB7XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgbXNnID0gZGVzY3JpcHRvcjtcbiAgICAgIGRlc2NyaXB0b3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdmFyIGFjdHVhbERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdChvYmopLCBuYW1lKTtcbiAgICBpZiAoYWN0dWFsRGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBfLmVxbChkZXNjcmlwdG9yLCBhY3R1YWxEZXNjcmlwdG9yKVxuICAgICAgICAsICdleHBlY3RlZCB0aGUgb3duIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yICcgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9uICN7dGhpc30gdG8gbWF0Y2ggJyArIF8uaW5zcGVjdChkZXNjcmlwdG9yKSArICcsIGdvdCAnICsgXy5pbnNwZWN0KGFjdHVhbERlc2NyaXB0b3IpXG4gICAgICAgICwgJ2V4cGVjdGVkIHRoZSBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKSArICcgb24gI3t0aGlzfSB0byBub3QgbWF0Y2ggJyArIF8uaW5zcGVjdChkZXNjcmlwdG9yKVxuICAgICAgICAsIGRlc2NyaXB0b3JcbiAgICAgICAgLCBhY3R1YWxEZXNjcmlwdG9yXG4gICAgICAgICwgdHJ1ZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgYWN0dWFsRGVzY3JpcHRvclxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYW4gb3duIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yICcgKyBfLmluc3BlY3QobmFtZSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhbiBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKVxuICAgICAgKTtcbiAgICB9XG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgYWN0dWFsRGVzY3JpcHRvcik7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdvd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBhc3NlcnRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdoYXZlT3duUHJvcGVydHlEZXNjcmlwdG9yJywgYXNzZXJ0T3duUHJvcGVydHlEZXNjcmlwdG9yKTtcblxuICAvKipcbiAgICogIyMjIC5sZW5ndGhcbiAgICpcbiAgICogU2V0cyB0aGUgYGRvTGVuZ3RoYCBmbGFnIGxhdGVyIHVzZWQgYXMgYSBjaGFpbiBwcmVjdXJzb3IgdG8gYSB2YWx1ZVxuICAgKiBjb21wYXJpc29uIGZvciB0aGUgYGxlbmd0aGAgcHJvcGVydHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDIpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5hYm92ZSgyKTtcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGguYmVsb3coNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLmJlbG93KDQpO1xuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC53aXRoaW4oMiw0KTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGgud2l0aGluKDIsNCk7XG4gICAqXG4gICAqICpEZXByZWNhdGlvbiBub3RpY2U6KiBVc2luZyBgbGVuZ3RoYCBhcyBhbiBhc3NlcnRpb24gd2lsbCBiZSBkZXByZWNhdGVkXG4gICAqIGluIHZlcnNpb24gMi40LjAgYW5kIHJlbW92ZWQgaW4gMy4wLjAuIENvZGUgdXNpbmcgdGhlIG9sZCBzdHlsZSBvZlxuICAgKiBhc3NlcnRpbmcgZm9yIGBsZW5ndGhgIHByb3BlcnR5IHZhbHVlIHVzaW5nIGBsZW5ndGgodmFsdWUpYCBzaG91bGQgYmVcbiAgICogc3dpdGNoZWQgdG8gdXNlIGBsZW5ndGhPZih2YWx1ZSlgIGluc3RlYWQuXG4gICAqXG4gICAqIEBuYW1lIGxlbmd0aFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICAvKipcbiAgICogIyMjIC5sZW5ndGhPZih2YWx1ZVssIG1lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgIHByb3BlcnR5IGhhc1xuICAgKiB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigzKTtcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uaGF2ZS5sZW5ndGhPZig2KTtcbiAgICpcbiAgICogQG5hbWUgbGVuZ3RoT2ZcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydExlbmd0aENoYWluICgpIHtcbiAgICBmbGFnKHRoaXMsICdkb0xlbmd0aCcsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0TGVuZ3RoIChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbGVuID09IG5cbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBvZiAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgbGVuZ3RoIG9mICN7YWN0fSdcbiAgICAgICwgblxuICAgICAgLCBsZW5cbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnbGVuZ3RoJywgYXNzZXJ0TGVuZ3RoLCBhc3NlcnRMZW5ndGhDaGFpbik7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2xlbmd0aE9mJywgYXNzZXJ0TGVuZ3RoKTtcblxuICAvKipcbiAgICogIyMjIC5tYXRjaChyZWdleHApXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IG1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLm1hdGNoKC9eZm9vLyk7XG4gICAqXG4gICAqIEBuYW1lIG1hdGNoXG4gICAqIEBhbGlhcyBtYXRjaGVzXG4gICAqIEBwYXJhbSB7UmVnRXhwfSBSZWd1bGFyRXhwcmVzc2lvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBmdW5jdGlvbiBhc3NlcnRNYXRjaChyZSwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICByZS5leGVjKG9iailcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbWF0Y2ggJyArIHJlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBtYXRjaCAnICsgcmVcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbWF0Y2gnLCBhc3NlcnRNYXRjaCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21hdGNoZXMnLCBhc3NlcnRNYXRjaCk7XG5cbiAgLyoqXG4gICAqICMjIyAuc3RyaW5nKHN0cmluZylcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSBzdHJpbmcgdGFyZ2V0IGNvbnRhaW5zIGFub3RoZXIgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5oYXZlLnN0cmluZygnYmFyJyk7XG4gICAqXG4gICAqIEBuYW1lIHN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc3RyaW5nJywgZnVuY3Rpb24gKHN0ciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLmlzLmEoJ3N0cmluZycpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIH5vYmouaW5kZXhPZihzdHIpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGNvbnRhaW4gJyArIF8uaW5zcGVjdChzdHIpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBjb250YWluICcgKyBfLmluc3BlY3Qoc3RyKVxuICAgICk7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqICMjIyAua2V5cyhrZXkxLCBba2V5Ml0sIFsuLi5dKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBjb250YWlucyBhbnkgb3IgYWxsIG9mIHRoZSBwYXNzZWQtaW4ga2V5cy5cbiAgICogVXNlIGluIGNvbWJpbmF0aW9uIHdpdGggYGFueWAsIGBhbGxgLCBgY29udGFpbnNgLCBvciBgaGF2ZWAgd2lsbCBhZmZlY3RcbiAgICogd2hhdCB3aWxsIHBhc3MuXG4gICAqXG4gICAqIFdoZW4gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBhbnlgLCBhdCBsZWFzdCBvbmUga2V5IHRoYXQgaXMgcGFzc2VkXG4gICAqIGluIG11c3QgZXhpc3QgaW4gdGhlIHRhcmdldCBvYmplY3QuIFRoaXMgaXMgcmVnYXJkbGVzcyB3aGV0aGVyIG9yIG5vdFxuICAgKiB0aGUgYGhhdmVgIG9yIGBjb250YWluYCBxdWFsaWZpZXJzIGFyZSB1c2VkLiBOb3RlLCBlaXRoZXIgYGFueWAgb3IgYGFsbGBcbiAgICogc2hvdWxkIGJlIHVzZWQgaW4gdGhlIGFzc2VydGlvbi4gSWYgbmVpdGhlciBhcmUgdXNlZCwgdGhlIGFzc2VydGlvbiBpc1xuICAgKiBkZWZhdWx0ZWQgdG8gYGFsbGAuXG4gICAqXG4gICAqIFdoZW4gYm90aCBgYWxsYCBhbmQgYGNvbnRhaW5gIGFyZSB1c2VkLCB0aGUgdGFyZ2V0IG9iamVjdCBtdXN0IGhhdmUgYXRcbiAgICogbGVhc3QgYWxsIG9mIHRoZSBwYXNzZWQtaW4ga2V5cyBidXQgbWF5IGhhdmUgbW9yZSBrZXlzIG5vdCBsaXN0ZWQuXG4gICAqXG4gICAqIFdoZW4gYm90aCBgYWxsYCBhbmQgYGhhdmVgIGFyZSB1c2VkLCB0aGUgdGFyZ2V0IG9iamVjdCBtdXN0IGJvdGggY29udGFpblxuICAgKiBhbGwgb2YgdGhlIHBhc3NlZC1pbiBrZXlzIEFORCB0aGUgbnVtYmVyIG9mIGtleXMgaW4gdGhlIHRhcmdldCBvYmplY3QgbXVzdFxuICAgKiBtYXRjaCB0aGUgbnVtYmVyIG9mIGtleXMgcGFzc2VkIGluIChpbiBvdGhlciB3b3JkcywgYSB0YXJnZXQgb2JqZWN0IG11c3RcbiAgICogaGF2ZSBhbGwgYW5kIG9ubHkgYWxsIG9mIHRoZSBwYXNzZWQtaW4ga2V5cykuXG4gICAqXG4gICAqICAgICBleHBlY3QoeyBmb286IDEsIGJhcjogMiB9KS50by5oYXZlLmFueS5rZXlzKCdmb28nLCAnYmF6Jyk7XG4gICAqICAgICBleHBlY3QoeyBmb286IDEsIGJhcjogMiB9KS50by5oYXZlLmFueS5rZXlzKCdmb28nKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyIH0pLnRvLmNvbnRhaW4uYW55LmtleXMoJ2JhcicsICdiYXonKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyIH0pLnRvLmNvbnRhaW4uYW55LmtleXMoWydmb28nXSk7XG4gICAqICAgICBleHBlY3QoeyBmb286IDEsIGJhcjogMiB9KS50by5jb250YWluLmFueS5rZXlzKHsnZm9vJzogNn0pO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAxLCBiYXI6IDIgfSkudG8uaGF2ZS5hbGwua2V5cyhbJ2JhcicsICdmb28nXSk7XG4gICAqICAgICBleHBlY3QoeyBmb286IDEsIGJhcjogMiB9KS50by5oYXZlLmFsbC5rZXlzKHsnYmFyJzogNiwgJ2Zvbyc6IDd9KTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyLCBiYXo6IDMgfSkudG8uY29udGFpbi5hbGwua2V5cyhbJ2JhcicsICdmb28nXSk7XG4gICAqICAgICBleHBlY3QoeyBmb286IDEsIGJhcjogMiwgYmF6OiAzIH0pLnRvLmNvbnRhaW4uYWxsLmtleXMoeydiYXInOiA2fSk7XG4gICAqXG4gICAqXG4gICAqIEBuYW1lIGtleXNcbiAgICogQGFsaWFzIGtleVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ3xBcnJheXxPYmplY3R9IGtleXNcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0S2V5cyAoa2V5cykge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBzdHJcbiAgICAgICwgb2sgPSB0cnVlXG4gICAgICAsIG1peGVkQXJnc01zZyA9ICdrZXlzIG11c3QgYmUgZ2l2ZW4gc2luZ2xlIGFyZ3VtZW50IG9mIEFycmF5fE9iamVjdHxTdHJpbmcsIG9yIG11bHRpcGxlIFN0cmluZyBhcmd1bWVudHMnO1xuXG4gICAgc3dpdGNoIChfLnR5cGUoa2V5cykpIHtcbiAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHRocm93IChuZXcgRXJyb3IobWl4ZWRBcmdzTXNnKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHRocm93IChuZXcgRXJyb3IobWl4ZWRBcmdzTXNnKSk7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhrZXlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBrZXlzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBpZiAoIWtleXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ2tleXMgcmVxdWlyZWQnKTtcblxuICAgIHZhciBhY3R1YWwgPSBPYmplY3Qua2V5cyhvYmopXG4gICAgICAsIGV4cGVjdGVkID0ga2V5c1xuICAgICAgLCBsZW4gPSBrZXlzLmxlbmd0aFxuICAgICAgLCBhbnkgPSBmbGFnKHRoaXMsICdhbnknKVxuICAgICAgLCBhbGwgPSBmbGFnKHRoaXMsICdhbGwnKTtcblxuICAgIGlmICghYW55ICYmICFhbGwpIHtcbiAgICAgIGFsbCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gSGFzIGFueVxuICAgIGlmIChhbnkpIHtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBleHBlY3RlZC5maWx0ZXIoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB+YWN0dWFsLmluZGV4T2Yoa2V5KTtcbiAgICAgIH0pO1xuICAgICAgb2sgPSBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICAvLyBIYXMgYWxsXG4gICAgaWYgKGFsbCkge1xuICAgICAgb2sgPSBrZXlzLmV2ZXJ5KGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIHJldHVybiB+YWN0dWFsLmluZGV4T2Yoa2V5KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFmbGFnKHRoaXMsICduZWdhdGUnKSAmJiAhZmxhZyh0aGlzLCAnY29udGFpbnMnKSkge1xuICAgICAgICBvayA9IG9rICYmIGtleXMubGVuZ3RoID09IGFjdHVhbC5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gS2V5IHN0cmluZ1xuICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICBrZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgcmV0dXJuIF8uaW5zcGVjdChrZXkpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbGFzdCA9IGtleXMucG9wKCk7XG4gICAgICBpZiAoYWxsKSB7XG4gICAgICAgIHN0ciA9IGtleXMuam9pbignLCAnKSArICcsIGFuZCAnICsgbGFzdDtcbiAgICAgIH1cbiAgICAgIGlmIChhbnkpIHtcbiAgICAgICAgc3RyID0ga2V5cy5qb2luKCcsICcpICsgJywgb3IgJyArIGxhc3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IF8uaW5zcGVjdChrZXlzWzBdKTtcbiAgICB9XG5cbiAgICAvLyBGb3JtXG4gICAgc3RyID0gKGxlbiA+IDEgPyAna2V5cyAnIDogJ2tleSAnKSArIHN0cjtcblxuICAgIC8vIEhhdmUgLyBpbmNsdWRlXG4gICAgc3RyID0gKGZsYWcodGhpcywgJ2NvbnRhaW5zJykgPyAnY29udGFpbiAnIDogJ2hhdmUgJykgKyBzdHI7XG5cbiAgICAvLyBBc3NlcnRpb25cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgb2tcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gJyArIHN0clxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgJyArIHN0clxuICAgICAgLCBleHBlY3RlZC5zbGljZSgwKS5zb3J0KClcbiAgICAgICwgYWN0dWFsLnNvcnQoKVxuICAgICAgLCB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2tleXMnLCBhc3NlcnRLZXlzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgna2V5JywgYXNzZXJ0S2V5cyk7XG5cbiAgLyoqXG4gICAqICMjIyAudGhyb3coY29uc3RydWN0b3IpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgZnVuY3Rpb24gdGFyZ2V0IHdpbGwgdGhyb3cgYSBzcGVjaWZpYyBlcnJvciwgb3Igc3BlY2lmaWMgdHlwZSBvZiBlcnJvclxuICAgKiAoYXMgZGV0ZXJtaW5lZCB1c2luZyBgaW5zdGFuY2VvZmApLCBvcHRpb25hbGx5IHdpdGggYSBSZWdFeHAgb3Igc3RyaW5nIGluY2x1c2lvbiB0ZXN0XG4gICAqIGZvciB0aGUgZXJyb3IncyBtZXNzYWdlLlxuICAgKlxuICAgKiAgICAgdmFyIGVyciA9IG5ldyBSZWZlcmVuY2VFcnJvcignVGhpcyBpcyBhIGJhZCBmdW5jdGlvbi4nKTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KFJlZmVyZW5jZUVycm9yKTtcbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coRXJyb3IpO1xuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdygvYmFkIGZ1bmN0aW9uLyk7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLm5vdC50aHJvdygnZ29vZCBmdW5jdGlvbicpO1xuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdyhSZWZlcmVuY2VFcnJvciwgL2JhZCBmdW5jdGlvbi8pO1xuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdyhlcnIpO1xuICAgKlxuICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHdoZW4gYSB0aHJvdyBleHBlY3RhdGlvbiBpcyBuZWdhdGVkLCBpdCB3aWxsIGNoZWNrIGVhY2hcbiAgICogcGFyYW1ldGVyIGluZGVwZW5kZW50bHksIHN0YXJ0aW5nIHdpdGggZXJyb3IgY29uc3RydWN0b3IgdHlwZS4gVGhlIGFwcHJvcHJpYXRlIHdheVxuICAgKiB0byBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhIHR5cGUgb2YgZXJyb3IgYnV0IGZvciBhIG1lc3NhZ2UgdGhhdCBkb2VzIG5vdCBtYXRjaFxuICAgKiBpcyB0byB1c2UgYGFuZGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KFJlZmVyZW5jZUVycm9yKVxuICAgKiAgICAgICAgLmFuZC5ub3QudGhyb3coL2dvb2QgZnVuY3Rpb24vKTtcbiAgICpcbiAgICogQG5hbWUgdGhyb3dcbiAgICogQGFsaWFzIHRocm93c1xuICAgKiBAYWxpYXMgVGhyb3dcbiAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV4cGVjdGVkIGVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEByZXR1cm5zIGVycm9yIGZvciBjaGFpbmluZyAobnVsbCBpZiBubyBlcnJvcilcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0VGhyb3dzIChjb25zdHJ1Y3RvciwgZXJyTXNnLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIHZhciB0aHJvd24gPSBmYWxzZVxuICAgICAgLCBkZXNpcmVkRXJyb3IgPSBudWxsXG4gICAgICAsIG5hbWUgPSBudWxsXG4gICAgICAsIHRocm93bkVycm9yID0gbnVsbDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBlcnJNc2cgPSBudWxsO1xuICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yIGluc3RhbmNlb2YgUmVnRXhwIHx8ICdzdHJpbmcnID09PSB0eXBlb2YgY29uc3RydWN0b3IpKSB7XG4gICAgICBlcnJNc2cgPSBjb25zdHJ1Y3RvcjtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGRlc2lyZWRFcnJvciA9IGNvbnN0cnVjdG9yO1xuICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgZXJyTXNnID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbmFtZSA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZS5uYW1lO1xuICAgICAgaWYgKCFuYW1lIHx8IChuYW1lID09PSAnRXJyb3InICYmIGNvbnN0cnVjdG9yICE9PSBFcnJvcikpIHtcbiAgICAgICAgbmFtZSA9IGNvbnN0cnVjdG9yLm5hbWUgfHwgKG5ldyBjb25zdHJ1Y3RvcigpKS5uYW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIG9iaigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZmlyc3QsIGNoZWNrIGRlc2lyZWQgZXJyb3JcbiAgICAgIGlmIChkZXNpcmVkRXJyb3IpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICBlcnIgPT09IGRlc2lyZWRFcnJvclxuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgI3tleHB9IGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyAje2V4cH0nXG4gICAgICAgICAgLCAoZGVzaXJlZEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBkZXNpcmVkRXJyb3IudG9TdHJpbmcoKSA6IGRlc2lyZWRFcnJvcilcbiAgICAgICAgICAsIChlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci50b1N0cmluZygpIDogZXJyKVxuICAgICAgICApO1xuXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGVycik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBuZXh0LCBjaGVjayBjb25zdHJ1Y3RvclxuICAgICAgaWYgKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgZXJyIGluc3RhbmNlb2YgY29uc3RydWN0b3JcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93ICN7ZXhwfSBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgdGhyb3cgI3tleHB9IGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgICAsIG5hbWVcbiAgICAgICAgICAsIChlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci50b1N0cmluZygpIDogZXJyKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghZXJyTXNnKSB7XG4gICAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgZXJyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBuZXh0LCBjaGVjayBtZXNzYWdlXG4gICAgICB2YXIgbWVzc2FnZSA9ICdlcnJvcicgPT09IF8udHlwZShlcnIpICYmIFwibWVzc2FnZVwiIGluIGVyclxuICAgICAgICA/IGVyci5tZXNzYWdlXG4gICAgICAgIDogJycgKyBlcnI7XG5cbiAgICAgIGlmICgobWVzc2FnZSAhPSBudWxsKSAmJiBlcnJNc2cgJiYgZXJyTXNnIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgZXJyTXNnLmV4ZWMobWVzc2FnZSlcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yIG1hdGNoaW5nICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yIG5vdCBtYXRjaGluZyAje2V4cH0nXG4gICAgICAgICAgLCBlcnJNc2dcbiAgICAgICAgICAsIG1lc3NhZ2VcbiAgICAgICAgKTtcblxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAoKG1lc3NhZ2UgIT0gbnVsbCkgJiYgZXJyTXNnICYmICdzdHJpbmcnID09PSB0eXBlb2YgZXJyTXNnKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgfm1lc3NhZ2UuaW5kZXhPZihlcnJNc2cpXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyBlcnJvciBpbmNsdWRpbmcgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3Igbm90IGluY2x1ZGluZyAje2FjdH0nXG4gICAgICAgICAgLCBlcnJNc2dcbiAgICAgICAgICAsIG1lc3NhZ2VcbiAgICAgICAgKTtcblxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93biA9IHRydWU7XG4gICAgICAgIHRocm93bkVycm9yID0gZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhY3R1YWxseUdvdCA9ICcnXG4gICAgICAsIGV4cGVjdGVkVGhyb3duID0gbmFtZSAhPT0gbnVsbFxuICAgICAgICA/IG5hbWVcbiAgICAgICAgOiBkZXNpcmVkRXJyb3JcbiAgICAgICAgICA/ICcje2V4cH0nIC8vXy5pbnNwZWN0KGRlc2lyZWRFcnJvcilcbiAgICAgICAgICA6ICdhbiBlcnJvcic7XG5cbiAgICBpZiAodGhyb3duKSB7XG4gICAgICBhY3R1YWxseUdvdCA9ICcgYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0aHJvd24gPT09IHRydWVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgJyArIGV4cGVjdGVkVGhyb3duICsgYWN0dWFsbHlHb3RcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICcgKyBleHBlY3RlZFRocm93biArIGFjdHVhbGx5R290XG4gICAgICAsIChkZXNpcmVkRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGRlc2lyZWRFcnJvci50b1N0cmluZygpIDogZGVzaXJlZEVycm9yKVxuICAgICAgLCAodGhyb3duRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHRocm93bkVycm9yLnRvU3RyaW5nKCkgOiB0aHJvd25FcnJvcilcbiAgICApO1xuXG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgdGhyb3duRXJyb3IpO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Rocm93JywgYXNzZXJ0VGhyb3dzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGhyb3dzJywgYXNzZXJ0VGhyb3dzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnVGhyb3cnLCBhc3NlcnRUaHJvd3MpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnJlc3BvbmRUbyhtZXRob2QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgb2JqZWN0IG9yIGNsYXNzIHRhcmdldCB3aWxsIHJlc3BvbmQgdG8gYSBtZXRob2QuXG4gICAqXG4gICAqICAgICBLbGFzcy5wcm90b3R5cGUuYmFyID0gZnVuY3Rpb24oKXt9O1xuICAgKiAgICAgZXhwZWN0KEtsYXNzKS50by5yZXNwb25kVG8oJ2JhcicpO1xuICAgKiAgICAgZXhwZWN0KG9iaikudG8ucmVzcG9uZFRvKCdiYXInKTtcbiAgICpcbiAgICogVG8gY2hlY2sgaWYgYSBjb25zdHJ1Y3RvciB3aWxsIHJlc3BvbmQgdG8gYSBzdGF0aWMgZnVuY3Rpb24sXG4gICAqIHNldCB0aGUgYGl0c2VsZmAgZmxhZy5cbiAgICpcbiAgICogICAgIEtsYXNzLmJheiA9IGZ1bmN0aW9uKCl7fTtcbiAgICogICAgIGV4cGVjdChLbGFzcykuaXRzZWxmLnRvLnJlc3BvbmRUbygnYmF6Jyk7XG4gICAqXG4gICAqIEBuYW1lIHJlc3BvbmRUb1xuICAgKiBAYWxpYXMgcmVzcG9uZHNUb1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gcmVzcG9uZFRvIChtZXRob2QsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBpdHNlbGYgPSBmbGFnKHRoaXMsICdpdHNlbGYnKVxuICAgICAgLCBjb250ZXh0ID0gKCdmdW5jdGlvbicgPT09IF8udHlwZShvYmopICYmICFpdHNlbGYpXG4gICAgICAgID8gb2JqLnByb3RvdHlwZVttZXRob2RdXG4gICAgICAgIDogb2JqW21ldGhvZF07XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGNvbnRleHRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gcmVzcG9uZCB0byAnICsgXy5pbnNwZWN0KG1ldGhvZClcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHJlc3BvbmQgdG8gJyArIF8uaW5zcGVjdChtZXRob2QpXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Jlc3BvbmRUbycsIHJlc3BvbmRUbyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Jlc3BvbmRzVG8nLCByZXNwb25kVG8pO1xuXG4gIC8qKlxuICAgKiAjIyMgLml0c2VsZlxuICAgKlxuICAgKiBTZXRzIHRoZSBgaXRzZWxmYCBmbGFnLCBsYXRlciB1c2VkIGJ5IHRoZSBgcmVzcG9uZFRvYCBhc3NlcnRpb24uXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBGb28oKSB7fVxuICAgKiAgICAgRm9vLmJhciA9IGZ1bmN0aW9uKCkge31cbiAgICogICAgIEZvby5wcm90b3R5cGUuYmF6ID0gZnVuY3Rpb24oKSB7fVxuICAgKlxuICAgKiAgICAgZXhwZWN0KEZvbykuaXRzZWxmLnRvLnJlc3BvbmRUbygnYmFyJyk7XG4gICAqICAgICBleHBlY3QoRm9vKS5pdHNlbGYubm90LnRvLnJlc3BvbmRUbygnYmF6Jyk7XG4gICAqXG4gICAqIEBuYW1lIGl0c2VsZlxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2l0c2VsZicsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdpdHNlbGYnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuc2F0aXNmeShtZXRob2QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IHBhc3NlcyBhIGdpdmVuIHRydXRoIHRlc3QuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uc2F0aXNmeShmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSA+IDA7IH0pO1xuICAgKlxuICAgKiBAbmFtZSBzYXRpc2Z5XG4gICAqIEBhbGlhcyBzYXRpc2ZpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWF0Y2hlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHNhdGlzZnkgKG1hdGNoZXIsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB2YXIgcmVzdWx0ID0gbWF0Y2hlcihvYmopO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICByZXN1bHRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gc2F0aXNmeSAnICsgXy5vYmpEaXNwbGF5KG1hdGNoZXIpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBzYXRpc2Z5JyArIF8ub2JqRGlzcGxheShtYXRjaGVyKVxuICAgICAgLCB0aGlzLm5lZ2F0ZSA/IGZhbHNlIDogdHJ1ZVxuICAgICAgLCByZXN1bHRcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc2F0aXNmeScsIHNhdGlzZnkpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdzYXRpc2ZpZXMnLCBzYXRpc2Z5KTtcblxuICAvKipcbiAgICogIyMjIC5jbG9zZVRvKGV4cGVjdGVkLCBkZWx0YSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgYGV4cGVjdGVkYCwgdG8gd2l0aGluIGEgKy8tIGBkZWx0YWAgcmFuZ2UuXG4gICAqXG4gICAqICAgICBleHBlY3QoMS41KS50by5iZS5jbG9zZVRvKDEsIDAuNSk7XG4gICAqXG4gICAqIEBuYW1lIGNsb3NlVG9cbiAgICogQGFsaWFzIGFwcHJveGltYXRlbHlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsb3NlVG8oZXhwZWN0ZWQsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG5cbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS5pcy5hKCdudW1iZXInKTtcbiAgICBpZiAoXy50eXBlKGV4cGVjdGVkKSAhPT0gJ251bWJlcicgfHwgXy50eXBlKGRlbHRhKSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIGFyZ3VtZW50cyB0byBjbG9zZVRvIG9yIGFwcHJveGltYXRlbHkgbXVzdCBiZSBudW1iZXJzJyk7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIE1hdGguYWJzKG9iaiAtIGV4cGVjdGVkKSA8PSBkZWx0YVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBjbG9zZSB0byAnICsgZXhwZWN0ZWQgKyAnICsvLSAnICsgZGVsdGFcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIGNsb3NlIHRvICcgKyBleHBlY3RlZCArICcgKy8tICcgKyBkZWx0YVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdjbG9zZVRvJywgY2xvc2VUbyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2FwcHJveGltYXRlbHknLCBjbG9zZVRvKTtcblxuICBmdW5jdGlvbiBpc1N1YnNldE9mKHN1YnNldCwgc3VwZXJzZXQsIGNtcCkge1xuICAgIHJldHVybiBzdWJzZXQuZXZlcnkoZnVuY3Rpb24oZWxlbSkge1xuICAgICAgaWYgKCFjbXApIHJldHVybiBzdXBlcnNldC5pbmRleE9mKGVsZW0pICE9PSAtMTtcblxuICAgICAgcmV0dXJuIHN1cGVyc2V0LnNvbWUoZnVuY3Rpb24oZWxlbTIpIHtcbiAgICAgICAgcmV0dXJuIGNtcChlbGVtLCBlbGVtMik7XG4gICAgICB9KTtcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubWVtYmVycyhzZXQpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgc3VwZXJzZXQgb2YgYHNldGAsXG4gICAqIG9yIHRoYXQgdGhlIHRhcmdldCBhbmQgYHNldGAgaGF2ZSB0aGUgc2FtZSBzdHJpY3RseS1lcXVhbCAoPT09KSBtZW1iZXJzLlxuICAgKiBBbHRlcm5hdGVseSwgaWYgdGhlIGBkZWVwYCBmbGFnIGlzIHNldCwgc2V0IG1lbWJlcnMgYXJlIGNvbXBhcmVkIGZvciBkZWVwXG4gICAqIGVxdWFsaXR5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZS5tZW1iZXJzKFszLCAyXSk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5ub3QuaW5jbHVkZS5tZW1iZXJzKFszLCAyLCA4XSk7XG4gICAqXG4gICAqICAgICBleHBlY3QoWzQsIDJdKS50by5oYXZlLm1lbWJlcnMoWzIsIDRdKTtcbiAgICogICAgIGV4cGVjdChbNSwgMl0pLnRvLm5vdC5oYXZlLm1lbWJlcnMoWzUsIDIsIDFdKTtcbiAgICpcbiAgICogICAgIGV4cGVjdChbeyBpZDogMSB9XSkudG8uZGVlcC5pbmNsdWRlLm1lbWJlcnMoW3sgaWQ6IDEgfV0pO1xuICAgKlxuICAgKiBAbmFtZSBtZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21lbWJlcnMnLCBmdW5jdGlvbiAoc3Vic2V0LCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG5cbiAgICBuZXcgQXNzZXJ0aW9uKG9iaikudG8uYmUuYW4oJ2FycmF5Jyk7XG4gICAgbmV3IEFzc2VydGlvbihzdWJzZXQpLnRvLmJlLmFuKCdhcnJheScpO1xuXG4gICAgdmFyIGNtcCA9IGZsYWcodGhpcywgJ2RlZXAnKSA/IF8uZXFsIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGZsYWcodGhpcywgJ2NvbnRhaW5zJykpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzc2VydChcbiAgICAgICAgICBpc1N1YnNldE9mKHN1YnNldCwgb2JqLCBjbXApXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYSBzdXBlcnNldCBvZiAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGEgc3VwZXJzZXQgb2YgI3thY3R9J1xuICAgICAgICAsIG9ialxuICAgICAgICAsIHN1YnNldFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgaXNTdWJzZXRPZihvYmosIHN1YnNldCwgY21wKSAmJiBpc1N1YnNldE9mKHN1YnNldCwgb2JqLCBjbXApXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGFzICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGFzICN7YWN0fSdcbiAgICAgICAgLCBvYmpcbiAgICAgICAgLCBzdWJzZXRcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5vbmVPZihsaXN0KVxuICAgKlxuICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGFwcGVhcnMgc29tZXdoZXJlIGluIHRoZSB0b3AgbGV2ZWwgb2YgYXJyYXkgYGxpc3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdhJykudG8uYmUub25lT2YoWydhJywgJ2InLCAnYyddKTtcbiAgICogICAgIGV4cGVjdCg5KS50by5ub3QuYmUub25lT2YoWyd6J10pO1xuICAgKiAgICAgZXhwZWN0KFszXSkudG8ubm90LmJlLm9uZU9mKFsxLCAyLCBbM11dKTtcbiAgICpcbiAgICogICAgIHZhciB0aHJlZSA9IFszXTtcbiAgICogICAgIC8vIGZvciBvYmplY3QtdHlwZXMsIGNvbnRlbnRzIGFyZSBub3QgY29tcGFyZWRcbiAgICogICAgIGV4cGVjdCh0aHJlZSkudG8ubm90LmJlLm9uZU9mKFsxLCAyLCBbM11dKTtcbiAgICogICAgIC8vIGNvbXBhcmluZyByZWZlcmVuY2VzIHdvcmtzXG4gICAqICAgICBleHBlY3QodGhyZWUpLnRvLmJlLm9uZU9mKFsxLCAyLCB0aHJlZV0pO1xuICAgKlxuICAgKiBAbmFtZSBvbmVPZlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBsaXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gb25lT2YgKGxpc3QsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBleHBlY3RlZCA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIG5ldyBBc3NlcnRpb24obGlzdCkudG8uYmUuYW4oJ2FycmF5Jyk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbGlzdC5pbmRleE9mKGV4cGVjdGVkKSA+IC0xXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIG9uZSBvZiAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBvbmUgb2YgI3tleHB9J1xuICAgICAgLCBsaXN0XG4gICAgICAsIGV4cGVjdGVkXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ29uZU9mJywgb25lT2YpO1xuXG5cbiAgLyoqXG4gICAqICMjIyAuY2hhbmdlKGZ1bmN0aW9uKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBjaGFuZ2VzIGFuIG9iamVjdCBwcm9wZXJ0eVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgKz0gMyB9O1xuICAgKiAgICAgdmFyIG5vQ2hhbmdlRm4gPSBmdW5jdGlvbigpIHsgcmV0dXJuICdmb28nICsgJ2Jhcic7IH1cbiAgICogICAgIGV4cGVjdChmbikudG8uY2hhbmdlKG9iaiwgJ3ZhbCcpO1xuICAgKiAgICAgZXhwZWN0KG5vQ2hhbmdlRm4pLnRvLm5vdC5jaGFuZ2Uob2JqLCAndmFsJylcbiAgICpcbiAgICogQG5hbWUgY2hhbmdlXG4gICAqIEBhbGlhcyBjaGFuZ2VzXG4gICAqIEBhbGlhcyBDaGFuZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydENoYW5nZXMgKG9iamVjdCwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIGZuID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgbmV3IEFzc2VydGlvbihvYmplY3QsIG1zZykudG8uaGF2ZS5wcm9wZXJ0eShwcm9wKTtcbiAgICBuZXcgQXNzZXJ0aW9uKGZuKS5pcy5hKCdmdW5jdGlvbicpO1xuXG4gICAgdmFyIGluaXRpYWwgPSBvYmplY3RbcHJvcF07XG4gICAgZm4oKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgaW5pdGlhbCAhPT0gb2JqZWN0W3Byb3BdXG4gICAgICAsICdleHBlY3RlZCAuJyArIHByb3AgKyAnIHRvIGNoYW5nZSdcbiAgICAgICwgJ2V4cGVjdGVkIC4nICsgcHJvcCArICcgdG8gbm90IGNoYW5nZSdcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnY2hhbmdlJywgYXNzZXJ0Q2hhbmdlcyk7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2NoYW5nZXMnLCBhc3NlcnRDaGFuZ2VzKTtcblxuICAvKipcbiAgICogIyMjIC5pbmNyZWFzZShmdW5jdGlvbilcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gaW5jcmVhc2VzIGFuIG9iamVjdCBwcm9wZXJ0eVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSAxNSB9O1xuICAgKiAgICAgZXhwZWN0KGZuKS50by5pbmNyZWFzZShvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jcmVhc2VcbiAgICogQGFsaWFzIGluY3JlYXNlc1xuICAgKiBAYWxpYXMgSW5jcmVhc2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEluY3JlYXNlcyAob2JqZWN0LCBwcm9wLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgZm4gPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iamVjdCwgbXNnKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICAgIG5ldyBBc3NlcnRpb24oZm4pLmlzLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICB2YXIgaW5pdGlhbCA9IG9iamVjdFtwcm9wXTtcbiAgICBmbigpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBvYmplY3RbcHJvcF0gLSBpbml0aWFsID4gMFxuICAgICAgLCAnZXhwZWN0ZWQgLicgKyBwcm9wICsgJyB0byBpbmNyZWFzZSdcbiAgICAgICwgJ2V4cGVjdGVkIC4nICsgcHJvcCArICcgdG8gbm90IGluY3JlYXNlJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdpbmNyZWFzZScsIGFzc2VydEluY3JlYXNlcyk7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2luY3JlYXNlcycsIGFzc2VydEluY3JlYXNlcyk7XG5cbiAgLyoqXG4gICAqICMjIyAuZGVjcmVhc2UoZnVuY3Rpb24pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRlY3JlYXNlcyBhbiBvYmplY3QgcHJvcGVydHlcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gNSB9O1xuICAgKiAgICAgZXhwZWN0KGZuKS50by5kZWNyZWFzZShvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgZGVjcmVhc2VcbiAgICogQGFsaWFzIGRlY3JlYXNlc1xuICAgKiBAYWxpYXMgRGVjcmVhc2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydERlY3JlYXNlcyAob2JqZWN0LCBwcm9wLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgZm4gPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iamVjdCwgbXNnKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICAgIG5ldyBBc3NlcnRpb24oZm4pLmlzLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICB2YXIgaW5pdGlhbCA9IG9iamVjdFtwcm9wXTtcbiAgICBmbigpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBvYmplY3RbcHJvcF0gLSBpbml0aWFsIDwgMFxuICAgICAgLCAnZXhwZWN0ZWQgLicgKyBwcm9wICsgJyB0byBkZWNyZWFzZSdcbiAgICAgICwgJ2V4cGVjdGVkIC4nICsgcHJvcCArICcgdG8gbm90IGRlY3JlYXNlJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdkZWNyZWFzZScsIGFzc2VydERlY3JlYXNlcyk7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2RlY3JlYXNlcycsIGFzc2VydERlY3JlYXNlcyk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXh0ZW5zaWJsZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBleHRlbnNpYmxlIChjYW4gaGF2ZSBuZXcgcHJvcGVydGllcyBhZGRlZCB0b1xuICAgKiBpdCkuXG4gICAqXG4gICAqICAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAqICAgICB2YXIgc2VhbGVkT2JqZWN0ID0gT2JqZWN0LnNlYWwoe30pO1xuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHt9KS50by5iZS5leHRlbnNpYmxlO1xuICAgKiAgICAgZXhwZWN0KG5vbkV4dGVuc2libGVPYmplY3QpLnRvLm5vdC5iZS5leHRlbnNpYmxlO1xuICAgKiAgICAgZXhwZWN0KHNlYWxlZE9iamVjdCkudG8ubm90LmJlLmV4dGVuc2libGU7XG4gICAqICAgICBleHBlY3QoZnJvemVuT2JqZWN0KS50by5ub3QuYmUuZXh0ZW5zaWJsZTtcbiAgICpcbiAgICogQG5hbWUgZXh0ZW5zaWJsZVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2V4dGVuc2libGUnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG5cbiAgICAvLyBJbiBFUzUsIGlmIHRoZSBhcmd1bWVudCB0byB0aGlzIG1ldGhvZCBpcyBub3QgYW4gb2JqZWN0IChhIHByaW1pdGl2ZSksIHRoZW4gaXQgd2lsbCBjYXVzZSBhIFR5cGVFcnJvci5cbiAgICAvLyBJbiBFUzYsIGEgbm9uLW9iamVjdCBhcmd1bWVudCB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2FzIGEgbm9uLWV4dGVuc2libGUgb3JkaW5hcnkgb2JqZWN0LCBzaW1wbHkgcmV0dXJuIGZhbHNlLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc0V4dGVuc2libGVcbiAgICAvLyBUaGUgZm9sbG93aW5nIHByb3ZpZGVzIEVTNiBiZWhhdmlvciB3aGVuIGEgVHlwZUVycm9yIGlzIHRocm93biB1bmRlciBFUzUuXG5cbiAgICB2YXIgaXNFeHRlbnNpYmxlO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUob2JqKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIGlzRXh0ZW5zaWJsZSA9IGZhbHNlO1xuICAgICAgZWxzZSB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpc0V4dGVuc2libGVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZXh0ZW5zaWJsZSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGV4dGVuc2libGUnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuc2VhbGVkXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHNlYWxlZCAoY2Fubm90IGhhdmUgbmV3IHByb3BlcnRpZXMgYWRkZWQgdG8gaXRcbiAgICogYW5kIGl0cyBleGlzdGluZyBwcm9wZXJ0aWVzIGNhbm5vdCBiZSByZW1vdmVkKS5cbiAgICpcbiAgICogICAgIHZhciBzZWFsZWRPYmplY3QgPSBPYmplY3Quc2VhbCh7fSk7XG4gICAqICAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAqXG4gICAqICAgICBleHBlY3Qoc2VhbGVkT2JqZWN0KS50by5iZS5zZWFsZWQ7XG4gICAqICAgICBleHBlY3QoZnJvemVuT2JqZWN0KS50by5iZS5zZWFsZWQ7XG4gICAqICAgICBleHBlY3Qoe30pLnRvLm5vdC5iZS5zZWFsZWQ7XG4gICAqXG4gICAqIEBuYW1lIHNlYWxlZFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ3NlYWxlZCcsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIC8vIEluIEVTNSwgaWYgdGhlIGFyZ3VtZW50IHRvIHRoaXMgbWV0aG9kIGlzIG5vdCBhbiBvYmplY3QgKGEgcHJpbWl0aXZlKSwgdGhlbiBpdCB3aWxsIGNhdXNlIGEgVHlwZUVycm9yLlxuICAgIC8vIEluIEVTNiwgYSBub24tb2JqZWN0IGFyZ3VtZW50IHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3YXMgYSBzZWFsZWQgb3JkaW5hcnkgb2JqZWN0LCBzaW1wbHkgcmV0dXJuIHRydWUuXG4gICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1NlYWxlZFxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvdmlkZXMgRVM2IGJlaGF2aW9yIHdoZW4gYSBUeXBlRXJyb3IgaXMgdGhyb3duIHVuZGVyIEVTNS5cblxuICAgIHZhciBpc1NlYWxlZDtcblxuICAgIHRyeSB7XG4gICAgICBpc1NlYWxlZCA9IE9iamVjdC5pc1NlYWxlZChvYmopO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikgaXNTZWFsZWQgPSB0cnVlO1xuICAgICAgZWxzZSB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpc1NlYWxlZFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBzZWFsZWQnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBzZWFsZWQnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZnJvemVuXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGZyb3plbiAoY2Fubm90IGhhdmUgbmV3IHByb3BlcnRpZXMgYWRkZWQgdG8gaXRcbiAgICogYW5kIGl0cyBleGlzdGluZyBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBtb2RpZmllZCkuXG4gICAqXG4gICAqICAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAqXG4gICAqICAgICBleHBlY3QoZnJvemVuT2JqZWN0KS50by5iZS5mcm96ZW47XG4gICAqICAgICBleHBlY3Qoe30pLnRvLm5vdC5iZS5mcm96ZW47XG4gICAqXG4gICAqIEBuYW1lIGZyb3plblxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2Zyb3plbicsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIC8vIEluIEVTNSwgaWYgdGhlIGFyZ3VtZW50IHRvIHRoaXMgbWV0aG9kIGlzIG5vdCBhbiBvYmplY3QgKGEgcHJpbWl0aXZlKSwgdGhlbiBpdCB3aWxsIGNhdXNlIGEgVHlwZUVycm9yLlxuICAgIC8vIEluIEVTNiwgYSBub24tb2JqZWN0IGFyZ3VtZW50IHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3YXMgYSBmcm96ZW4gb3JkaW5hcnkgb2JqZWN0LCBzaW1wbHkgcmV0dXJuIHRydWUuXG4gICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc0Zyb3plblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvdmlkZXMgRVM2IGJlaGF2aW9yIHdoZW4gYSBUeXBlRXJyb3IgaXMgdGhyb3duIHVuZGVyIEVTNS5cblxuICAgIHZhciBpc0Zyb3plbjtcblxuICAgIHRyeSB7XG4gICAgICBpc0Zyb3plbiA9IE9iamVjdC5pc0Zyb3plbihvYmopO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikgaXNGcm96ZW4gPSB0cnVlO1xuICAgICAgZWxzZSB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpc0Zyb3plblxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmcm96ZW4nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBmcm96ZW4nXG4gICAgKTtcbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2NvcmUvYXNzZXJ0aW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgdXRpbCkge1xuICBjaGFpLmV4cGVjdCA9IGZ1bmN0aW9uICh2YWwsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IGNoYWkuQXNzZXJ0aW9uKHZhbCwgbWVzc2FnZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0sIFtvcGVyYXRvcl0pXG4gICAqXG4gICAqIFRocm93IGEgZmFpbHVyZS5cbiAgICpcbiAgICogQG5hbWUgZmFpbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBuYW1lc3BhY2UgRXhwZWN0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGNoYWkuZXhwZWN0LmZhaWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnZXhwZWN0LmZhaWwoKSc7XG4gICAgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IobWVzc2FnZSwge1xuICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICwgb3BlcmF0b3I6IG9wZXJhdG9yXG4gICAgfSwgY2hhaS5leHBlY3QuZmFpbCk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9leHBlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcbiAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uO1xuXG4gIGZ1bmN0aW9uIGxvYWRTaG91bGQgKCkge1xuICAgIC8vIGV4cGxpY2l0bHkgZGVmaW5lIHRoaXMgbWV0aG9kIGFzIGZ1bmN0aW9uIGFzIHRvIGhhdmUgaXQncyBuYW1lIHRvIGluY2x1ZGUgYXMgYHNzZmlgXG4gICAgZnVuY3Rpb24gc2hvdWxkR2V0dGVyKCkge1xuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdGhpcyBpbnN0YW5jZW9mIE51bWJlciB8fCB0aGlzIGluc3RhbmNlb2YgQm9vbGVhbiApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odGhpcy52YWx1ZU9mKCksIG51bGwsIHNob3VsZEdldHRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEFzc2VydGlvbih0aGlzLCBudWxsLCBzaG91bGRHZXR0ZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRTZXR0ZXIodmFsdWUpIHtcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2NoYWkvaXNzdWVzLzg2OiB0aGlzIG1ha2VzXG4gICAgICAvLyBgd2hhdGV2ZXIuc2hvdWxkID0gc29tZVZhbHVlYCBhY3R1YWxseSBzZXQgYHNvbWVWYWx1ZWAsIHdoaWNoIGlzXG4gICAgICAvLyBlc3BlY2lhbGx5IHVzZWZ1bCBmb3IgYGdsb2JhbC5zaG91bGQgPSByZXF1aXJlKCdjaGFpJykuc2hvdWxkKClgLlxuICAgICAgLy9cbiAgICAgIC8vIE5vdGUgdGhhdCB3ZSBoYXZlIHRvIHVzZSBbW0RlZmluZVByb3BlcnR5XV0gaW5zdGVhZCBvZiBbW1B1dF1dXG4gICAgICAvLyBzaW5jZSBvdGhlcndpc2Ugd2Ugd291bGQgdHJpZ2dlciB0aGlzIHZlcnkgc2V0dGVyIVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzaG91bGQnLCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIG1vZGlmeSBPYmplY3QucHJvdG90eXBlIHRvIGhhdmUgYHNob3VsZGBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgJ3Nob3VsZCcsIHtcbiAgICAgIHNldDogc2hvdWxkU2V0dGVyXG4gICAgICAsIGdldDogc2hvdWxkR2V0dGVyXG4gICAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdmFyIHNob3VsZCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC5mYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSwgW29wZXJhdG9yXSlcbiAgICAgKlxuICAgICAqIFRocm93IGEgZmFpbHVyZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIGZhaWxcbiAgICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAgICogQG5hbWVzcGFjZSBTaG91bGRcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLmZhaWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IpIHtcbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdzaG91bGQuZmFpbCgpJztcbiAgICAgIHRocm93IG5ldyBjaGFpLkFzc2VydGlvbkVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgICAsIG9wZXJhdG9yOiBvcGVyYXRvclxuICAgICAgfSwgc2hvdWxkLmZhaWwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICAgKlxuICAgICAqIEFzc2VydHMgbm9uLXN0cmljdCBlcXVhbGl0eSAoYD09YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLmVxdWFsKDMsICczJywgJz09IGNvZXJjZXMgdmFsdWVzIHRvIHN0cmluZ3MnKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIGVxdWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5lcXVhbCA9IGZ1bmN0aW9uICh2YWwxLCB2YWwyLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsMSwgbXNnKS50by5lcXVhbCh2YWwyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC50aHJvdyhmdW5jdGlvbiwgW2NvbnN0cnVjdG9yL3N0cmluZy9yZWdleHBdLCBbc3RyaW5nL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICAgKlxuICAgICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgICAqIGBjb25zdHJ1Y3RvcmAsIG9yIGFsdGVybmF0ZWx5IHRoYXQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvciB3aXRoIG1lc3NhZ2VcbiAgICAgKiBtYXRjaGluZyBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqICAgICBzaG91bGQudGhyb3coZm4sICdmdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3InKTtcbiAgICAgKiAgICAgc2hvdWxkLnRocm93KGZuLCAvZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yLyk7XG4gICAgICogICAgIHNob3VsZC50aHJvdyhmbiwgUmVmZXJlbmNlRXJyb3IpO1xuICAgICAqICAgICBzaG91bGQudGhyb3coZm4sIFJlZmVyZW5jZUVycm9yLCAnZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yJyk7XG4gICAgICogICAgIHNob3VsZC50aHJvdyhmbiwgUmVmZXJlbmNlRXJyb3IsIC9mdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3IvKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIHRocm93XG4gICAgICogQGFsaWFzIFRocm93XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5UaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJydCwgZXJycywgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLlRocm93KGVycnQsIGVycnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLmV4aXN0XG4gICAgICpcbiAgICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBuZWl0aGVyIGBudWxsYCBub3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGZvbyA9ICdoaSc7XG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLmV4aXN0KGZvbywgJ2ZvbyBleGlzdHMnKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIGV4aXN0XG4gICAgICogQG5hbWVzcGFjZSBTaG91bGRcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLmV4aXN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5leGlzdDtcbiAgICB9XG5cbiAgICAvLyBuZWdhdGlvblxuICAgIHNob3VsZC5ub3QgPSB7fVxuXG4gICAgLyoqXG4gICAgICogIyMjIC5ub3QuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgICAqXG4gICAgICogQXNzZXJ0cyBub24tc3RyaWN0IGluZXF1YWxpdHkgKGAhPWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgICAqXG4gICAgICogICAgIHNob3VsZC5ub3QuZXF1YWwoMywgNCwgJ3RoZXNlIG51bWJlcnMgYXJlIG5vdCBlcXVhbCcpO1xuICAgICAqXG4gICAgICogQG5hbWUgbm90LmVxdWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5ub3QuZXF1YWwgPSBmdW5jdGlvbiAodmFsMSwgdmFsMiwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbDEsIG1zZykudG8ubm90LmVxdWFsKHZhbDIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLnRocm93KGZ1bmN0aW9uLCBbY29uc3RydWN0b3IvcmVnZXhwXSwgW21lc3NhZ2VdKVxuICAgICAqXG4gICAgICogQXNzZXJ0cyB0aGF0IGBmdW5jdGlvbmAgd2lsbCBfbm90XyB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuIGluc3RhbmNlIG9mXG4gICAgICogYGNvbnN0cnVjdG9yYCwgb3IgYWx0ZXJuYXRlbHkgdGhhdCBpdCB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvciB3aXRoIG1lc3NhZ2VcbiAgICAgKiBtYXRjaGluZyBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqICAgICBzaG91bGQubm90LnRocm93KGZuLCBFcnJvciwgJ2Z1bmN0aW9uIGRvZXMgbm90IHRocm93Jyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSBub3QudGhyb3dcbiAgICAgKiBAYWxpYXMgbm90LlRocm93XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5ub3QuVGhyb3cgPSBmdW5jdGlvbiAoZm4sIGVycnQsIGVycnMsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by5ub3QuVGhyb3coZXJydCwgZXJycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICMjIyAubm90LmV4aXN0XG4gICAgICpcbiAgICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBuZWl0aGVyIGBudWxsYCBub3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGJhciA9IG51bGw7XG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLm5vdC5leGlzdChiYXIsICdiYXIgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIG5vdC5leGlzdFxuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5ub3QuZXhpc3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5leGlzdDtcbiAgICB9XG5cbiAgICBzaG91bGRbJ3Rocm93J10gPSBzaG91bGRbJ1Rocm93J107XG4gICAgc2hvdWxkLm5vdFsndGhyb3cnXSA9IHNob3VsZC5ub3RbJ1Rocm93J107XG5cbiAgICByZXR1cm4gc2hvdWxkO1xuICB9O1xuXG4gIGNoYWkuc2hvdWxkID0gbG9hZFNob3VsZDtcbiAgY2hhaS5TaG91bGQgPSBsb2FkU2hvdWxkO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9pbnRlcmZhY2Uvc2hvdWxkLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcblxuICAvKiFcbiAgICogQ2hhaSBkZXBlbmRlbmNpZXMuXG4gICAqL1xuXG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvblxuICAgICwgZmxhZyA9IHV0aWwuZmxhZztcblxuICAvKiFcbiAgICogTW9kdWxlIGV4cG9ydC5cbiAgICovXG5cbiAgLyoqXG4gICAqICMjIyBhc3NlcnQoZXhwcmVzc2lvbiwgbWVzc2FnZSlcbiAgICpcbiAgICogV3JpdGUgeW91ciBvd24gdGVzdCBleHByZXNzaW9ucy5cbiAgICpcbiAgICogICAgIGFzc2VydCgnZm9vJyAhPT0gJ2JhcicsICdmb28gaXMgbm90IGJhcicpO1xuICAgKiAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoW10pLCAnZW1wdHkgYXJyYXlzIGFyZSBhcnJheXMnKTtcbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwcmVzc2lvbiB0byB0ZXN0IGZvciB0cnV0aGluZXNzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIHRvIGRpc3BsYXkgb24gZXJyb3JcbiAgICogQG5hbWUgYXNzZXJ0XG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHZhciBhc3NlcnQgPSBjaGFpLmFzc2VydCA9IGZ1bmN0aW9uIChleHByZXNzLCBlcnJtc2cpIHtcbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24obnVsbCwgbnVsbCwgY2hhaS5hc3NlcnQpO1xuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHByZXNzXG4gICAgICAsIGVycm1zZ1xuICAgICAgLCAnWyBuZWdhdGlvbiBtZXNzYWdlIHVuYXZhaWxhYmxlIF0nXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5mYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSwgW29wZXJhdG9yXSlcbiAgICpcbiAgICogVGhyb3cgYSBmYWlsdXJlLiBOb2RlLmpzIGBhc3NlcnRgIG1vZHVsZS1jb21wYXRpYmxlLlxuICAgKlxuICAgKiBAbmFtZSBmYWlsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmZhaWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnYXNzZXJ0LmZhaWwoKSc7XG4gICAgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IobWVzc2FnZSwge1xuICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICwgb3BlcmF0b3I6IG9wZXJhdG9yXG4gICAgfSwgYXNzZXJ0LmZhaWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzT2sob2JqZWN0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyB0cnV0aHkuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNPaygnZXZlcnl0aGluZycsICdldmVyeXRoaW5nIGlzIG9rJyk7XG4gICAqICAgICBhc3NlcnQuaXNPayhmYWxzZSwgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzT2tcbiAgICogQGFsaWFzIG9rXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc09rID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykuaXMub2s7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RPayhvYmplY3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIGZhbHN5LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90T2soJ2V2ZXJ5dGhpbmcnLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICogICAgIGFzc2VydC5pc05vdE9rKGZhbHNlLCAndGhpcyB3aWxsIHBhc3MnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RPa1xuICAgKiBAYWxpYXMgbm90T2tcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIHRlc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90T2sgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS5pcy5ub3Qub2s7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIG5vbi1zdHJpY3QgZXF1YWxpdHkgKGA9PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmVxdWFsKDMsICczJywgJz09IGNvZXJjZXMgdmFsdWVzIHRvIHN0cmluZ3MnKTtcbiAgICpcbiAgICogQG5hbWUgZXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQuZXF1YWwpO1xuXG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIGV4cCA9PSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlcXVhbCAje2FjdH0nXG4gICAgICAsIGV4cFxuICAgICAgLCBhY3RcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBub24tc3RyaWN0IGluZXF1YWxpdHkgKGAhPWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEVxdWFsKDMsIDQsICd0aGVzZSBudW1iZXJzIGFyZSBub3QgZXF1YWwnKTtcbiAgICpcbiAgICogQG5hbWUgbm90RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQubm90RXF1YWwpO1xuXG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIGV4cCAhPSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2FjdH0nXG4gICAgICAsIGV4cFxuICAgICAgLCBhY3RcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBzdHJpY3QgZXF1YWxpdHkgKGA9PT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCB0cnVlLCAndGhlc2UgYm9vbGVhbnMgYXJlIHN0cmljdGx5IGVxdWFsJyk7XG4gICAqXG4gICAqIEBuYW1lIHN0cmljdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLmVxdWFsKGV4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHN0cmljdCBpbmVxdWFsaXR5IChgIT09YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90U3RyaWN0RXF1YWwoMywgJzMnLCAnbm8gY29lcmNpb24gZm9yIHN0cmljdCBlcXVhbGl0eScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RTdHJpY3RFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5ub3QuZXF1YWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGFjdHVhbGAgaXMgZGVlcGx5IGVxdWFsIHRvIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcEVxdWFsKHsgdGVhOiAnZ3JlZW4nIH0sIHsgdGVhOiAnZ3JlZW4nIH0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwRXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLmVxbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydCB0aGF0IGBhY3R1YWxgIGlzIG5vdCBkZWVwbHkgZXF1YWwgdG8gYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwRXF1YWwoeyB0ZWE6ICdncmVlbicgfSwgeyB0ZWE6ICdqYXNtaW5lJyB9KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5ub3QuZXFsKGV4cCk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQWJvdmUodmFsdWVUb0NoZWNrLCB2YWx1ZVRvQmVBYm92ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZVRvQ2hlY2tgIGlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiAoPikgYHZhbHVlVG9CZUFib3ZlYFxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzQWJvdmUoNSwgMiwgJzUgaXMgc3RyaWN0bHkgZ3JlYXRlciB0aGFuIDInKTtcbiAgICpcbiAgICogQG5hbWUgaXNBYm92ZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQ2hlY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0JlQWJvdmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQWJvdmUgPSBmdW5jdGlvbiAodmFsLCBhYnYsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmFib3ZlKGFidik7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQXRMZWFzdCh2YWx1ZVRvQ2hlY2ssIHZhbHVlVG9CZUF0TGVhc3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBgdmFsdWVUb0NoZWNrYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gKD49KSBgdmFsdWVUb0JlQXRMZWFzdGBcbiAgICpcbiAgICogICAgIGFzc2VydC5pc0F0TGVhc3QoNSwgMiwgJzUgaXMgZ3JlYXRlciBvciBlcXVhbCB0byAyJyk7XG4gICAqICAgICBhc3NlcnQuaXNBdExlYXN0KDMsIDMsICczIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMycpO1xuICAgKlxuICAgKiBAbmFtZSBpc0F0TGVhc3RcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0NoZWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9CZUF0TGVhc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQXRMZWFzdCA9IGZ1bmN0aW9uICh2YWwsIGF0bHN0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5sZWFzdChhdGxzdCk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQmVsb3codmFsdWVUb0NoZWNrLCB2YWx1ZVRvQmVCZWxvdywgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZVRvQ2hlY2tgIGlzIHN0cmljdGx5IGxlc3MgdGhhbiAoPCkgYHZhbHVlVG9CZUJlbG93YFxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzQmVsb3coMywgNiwgJzMgaXMgc3RyaWN0bHkgbGVzcyB0aGFuIDYnKTtcbiAgICpcbiAgICogQG5hbWUgaXNCZWxvd1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQ2hlY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0JlQmVsb3dcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQmVsb3cgPSBmdW5jdGlvbiAodmFsLCBibHcsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmJlbG93KGJsdyk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQXRNb3N0KHZhbHVlVG9DaGVjaywgdmFsdWVUb0JlQXRNb3N0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgYHZhbHVlVG9DaGVja2AgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICg8PSkgYHZhbHVlVG9CZUF0TW9zdGBcbiAgICpcbiAgICogICAgIGFzc2VydC5pc0F0TW9zdCgzLCA2LCAnMyBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gNicpO1xuICAgKiAgICAgYXNzZXJ0LmlzQXRNb3N0KDQsIDQsICc0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byA0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQXRNb3N0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9DaGVja1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQmVBdE1vc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQXRNb3N0ID0gZnVuY3Rpb24gKHZhbCwgYXRtc3QsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLm1vc3QoYXRtc3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzVHJ1ZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyB0cnVlLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVNlcnZlZCA9IHRydWU7XG4gICAqICAgICBhc3NlcnQuaXNUcnVlKHRlYVNlcnZlZCwgJ3RoZSB0ZWEgaGFzIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzVHJ1ZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNUcnVlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykuaXNbJ3RydWUnXTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdFRydWUodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IHRydWUuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ3Rhc3R5IGNoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90VHJ1ZSh0ZWEsICdncmVhdCwgdGltZSBmb3IgdGVhIScpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdFRydWVcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90VHJ1ZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5lcXVhbCh0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0ZhbHNlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGZhbHNlLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVNlcnZlZCA9IGZhbHNlO1xuICAgKiAgICAgYXNzZXJ0LmlzRmFsc2UodGVhU2VydmVkLCAnbm8gdGVhIHlldD8gaG1tLi4uJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRmFsc2VcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRmFsc2UgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS5pc1snZmFsc2UnXTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEZhbHNlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG5vdCBmYWxzZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAndGFzdHkgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3RGYWxzZSh0ZWEsICdncmVhdCwgdGltZSBmb3IgdGVhIScpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEZhbHNlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEZhbHNlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmVxdWFsKGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc051bGwodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbnVsbC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc051bGwoZXJyLCAndGhlcmUgd2FzIG5vIGVycm9yJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTnVsbFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOdWxsID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uZXF1YWwobnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3ROdWxsKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG5vdCBudWxsLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYSA9ICd0YXN0eSBjaGFpJztcbiAgICogICAgIGFzc2VydC5pc05vdE51bGwodGVhLCAnZ3JlYXQsIHRpbWUgZm9yIHRlYSEnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3ROdWxsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE51bGwgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuZXF1YWwobnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOYU5cbiAgICogQXNzZXJ0cyB0aGF0IHZhbHVlIGlzIE5hTlxuICAgKlxuICAgKiAgICBhc3NlcnQuaXNOYU4oJ2ZvbycsICdmb28gaXMgTmFOJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTmFOXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05hTiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLk5hTjtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE5hTlxuICAgKiBBc3NlcnRzIHRoYXQgdmFsdWUgaXMgbm90IE5hTlxuICAgKlxuICAgKiAgICBhc3NlcnQuaXNOb3ROYU4oNCwgJzQgaXMgbm90IE5hTicpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE5hTlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgYXNzZXJ0LmlzTm90TmFOID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykubm90LnRvLmJlLk5hTjtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1VuZGVmaW5lZCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciB0ZWE7XG4gICAqICAgICBhc3NlcnQuaXNVbmRlZmluZWQodGVhLCAnbm8gdGVhIGRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNVbmRlZmluZWRcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzVW5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uZXF1YWwodW5kZWZpbmVkKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0RlZmluZWQodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYSA9ICdjdXAgb2YgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNEZWZpbmVkKHRlYSwgJ3RlYSBoYXMgYmVlbiBkZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRGVmaW5lZFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNEZWZpbmVkID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmVxdWFsKHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNGdW5jdGlvbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gc2VydmVUZWEoKSB7IHJldHVybiAnY3VwIG9mIHRlYSc7IH07XG4gICAqICAgICBhc3NlcnQuaXNGdW5jdGlvbihzZXJ2ZVRlYSwgJ2dyZWF0LCB3ZSBjYW4gaGF2ZSB0ZWEgbm93Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRnVuY3Rpb25cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdmdW5jdGlvbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RnVuY3Rpb24odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBmdW5jdGlvbi5cbiAgICpcbiAgICogICAgIHZhciBzZXJ2ZVRlYSA9IFsgJ2hlYXQnLCAncG91cicsICdzaXAnIF07XG4gICAqICAgICBhc3NlcnQuaXNOb3RGdW5jdGlvbihzZXJ2ZVRlYSwgJ2dyZWF0LCB3ZSBoYXZlIGxpc3RlZCB0aGUgc3RlcHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RGdW5jdGlvblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdmdW5jdGlvbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzT2JqZWN0KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGFuIG9iamVjdCBvZiB0eXBlICdPYmplY3QnIChhcyByZXZlYWxlZCBieSBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2ApLlxuICAgKiBfVGhlIGFzc2VydGlvbiBkb2VzIG5vdCBtYXRjaCBzdWJjbGFzc2VkIG9iamVjdHMuX1xuICAgKlxuICAgKiAgICAgdmFyIHNlbGVjdGlvbiA9IHsgbmFtZTogJ0NoYWknLCBzZXJ2ZTogJ3dpdGggc3BpY2VzJyB9O1xuICAgKiAgICAgYXNzZXJ0LmlzT2JqZWN0KHNlbGVjdGlvbiwgJ3RlYSBzZWxlY3Rpb24gaXMgYW4gb2JqZWN0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzT2JqZWN0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc09iamVjdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90T2JqZWN0KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGFuIG9iamVjdCBvZiB0eXBlICdPYmplY3QnIChhcyByZXZlYWxlZCBieSBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2ApLlxuICAgKlxuICAgKiAgICAgdmFyIHNlbGVjdGlvbiA9ICdjaGFpJ1xuICAgKiAgICAgYXNzZXJ0LmlzTm90T2JqZWN0KHNlbGVjdGlvbiwgJ3RlYSBzZWxlY3Rpb24gaXMgbm90IGFuIG9iamVjdCcpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90T2JqZWN0KG51bGwsICdudWxsIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RPYmplY3RcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90T2JqZWN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEoJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzQXJyYXkodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYW4gYXJyYXkuXG4gICAqXG4gICAqICAgICB2YXIgbWVudSA9IFsgJ2dyZWVuJywgJ2NoYWknLCAnb29sb25nJyBdO1xuICAgKiAgICAgYXNzZXJ0LmlzQXJyYXkobWVudSwgJ3doYXQga2luZCBvZiB0ZWEgZG8gd2Ugd2FudD8nKTtcbiAgICpcbiAgICogQG5hbWUgaXNBcnJheVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNBcnJheSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmFuKCdhcnJheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90QXJyYXkodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYW4gYXJyYXkuXG4gICAqXG4gICAqICAgICB2YXIgbWVudSA9ICdncmVlbnxjaGFpfG9vbG9uZyc7XG4gICAqICAgICBhc3NlcnQuaXNOb3RBcnJheShtZW51LCAnd2hhdCBraW5kIG9mIHRlYSBkbyB3ZSB3YW50PycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEFycmF5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEFycmF5ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmFuKCdhcnJheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzU3RyaW5nKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYU9yZGVyID0gJ2NoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzU3RyaW5nKHRlYU9yZGVyLCAnb3JkZXIgcGxhY2VkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzU3RyaW5nXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc1N0cmluZyA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ3N0cmluZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90U3RyaW5nKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYU9yZGVyID0gNDtcbiAgICogICAgIGFzc2VydC5pc05vdFN0cmluZyh0ZWFPcmRlciwgJ29yZGVyIHBsYWNlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdFN0cmluZ1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RTdHJpbmcgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSgnc3RyaW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOdW1iZXIodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBudW1iZXIuXG4gICAqXG4gICAqICAgICB2YXIgY3VwcyA9IDI7XG4gICAqICAgICBhc3NlcnQuaXNOdW1iZXIoY3VwcywgJ2hvdyBtYW55IGN1cHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOdW1iZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc051bWJlciA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ251bWJlcicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90TnVtYmVyKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgbnVtYmVyLlxuICAgKlxuICAgKiAgICAgdmFyIGN1cHMgPSAnMiBjdXBzIHBsZWFzZSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3ROdW1iZXIoY3VwcywgJ2hvdyBtYW55IGN1cHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3ROdW1iZXJcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90TnVtYmVyID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEoJ251bWJlcicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzQm9vbGVhbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIGJvb2xlYW4uXG4gICAqXG4gICAqICAgICB2YXIgdGVhUmVhZHkgPSB0cnVlXG4gICAqICAgICAgICwgdGVhU2VydmVkID0gZmFsc2U7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNCb29sZWFuKHRlYVJlYWR5LCAnaXMgdGhlIHRlYSByZWFkeScpO1xuICAgKiAgICAgYXNzZXJ0LmlzQm9vbGVhbih0ZWFTZXJ2ZWQsICdoYXMgdGVhIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQm9vbGVhblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNCb29sZWFuID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYSgnYm9vbGVhbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90Qm9vbGVhbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIGJvb2xlYW4uXG4gICAqXG4gICAqICAgICB2YXIgdGVhUmVhZHkgPSAneWVwJ1xuICAgKiAgICAgICAsIHRlYVNlcnZlZCA9ICdub3BlJztcbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdEJvb2xlYW4odGVhUmVhZHksICdpcyB0aGUgdGVhIHJlYWR5Jyk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RCb29sZWFuKHRlYVNlcnZlZCwgJ2hhcyB0ZWEgYmVlbiBzZXJ2ZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RCb29sZWFuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEJvb2xlYW4gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSgnYm9vbGVhbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnR5cGVPZih2YWx1ZSwgbmFtZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCdzIHR5cGUgaXMgYG5hbWVgLCBhcyBkZXRlcm1pbmVkIGJ5XG4gICAqIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICpcbiAgICogICAgIGFzc2VydC50eXBlT2YoeyB0ZWE6ICdjaGFpJyB9LCAnb2JqZWN0JywgJ3dlIGhhdmUgYW4gb2JqZWN0Jyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKFsnY2hhaScsICdqYXNtaW5lJ10sICdhcnJheScsICd3ZSBoYXZlIGFuIGFycmF5Jyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKCd0ZWEnLCAnc3RyaW5nJywgJ3dlIGhhdmUgYSBzdHJpbmcnKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YoL3RlYS8sICdyZWdleHAnLCAnd2UgaGF2ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbicpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZihudWxsLCAnbnVsbCcsICd3ZSBoYXZlIGEgbnVsbCcpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZih1bmRlZmluZWQsICd1bmRlZmluZWQnLCAnd2UgaGF2ZSBhbiB1bmRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgdHlwZU9mXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC50eXBlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFR5cGVPZih2YWx1ZSwgbmFtZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCdzIHR5cGUgaXMgX25vdF8gYG5hbWVgLCBhcyBkZXRlcm1pbmVkIGJ5XG4gICAqIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RUeXBlT2YoJ3RlYScsICdudW1iZXInLCAnc3RyaW5ncyBhcmUgbm90IG51bWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90VHlwZU9mXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlb2YgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90VHlwZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaW5zdGFuY2VPZihvYmplY3QsIGNvbnN0cnVjdG9yLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGFuIGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICB2YXIgVGVhID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5uYW1lID0gbmFtZTsgfVxuICAgKiAgICAgICAsIGNoYWkgPSBuZXcgVGVhKCdjaGFpJyk7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5zdGFuY2VPZihjaGFpLCBUZWEsICdjaGFpIGlzIGFuIGluc3RhbmNlIG9mIHRlYScpO1xuICAgKlxuICAgKiBAbmFtZSBpbnN0YW5jZU9mXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmluc3RhbmNlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5pbnN0YW5jZU9mKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluc3RhbmNlT2Yob2JqZWN0LCBjb25zdHJ1Y3RvciwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZWAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICB2YXIgVGVhID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5uYW1lID0gbmFtZTsgfVxuICAgKiAgICAgICAsIGNoYWkgPSBuZXcgU3RyaW5nKCdjaGFpJyk7XG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5zdGFuY2VPZihjaGFpLCBUZWEsICdjaGFpIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiB0ZWEnKTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5zdGFuY2VPZlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbnN0YW5jZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmluc3RhbmNlT2YodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgaGF5c3RhY2tgIGluY2x1ZGVzIGBuZWVkbGVgLiBXb3Jrc1xuICAgKiBmb3Igc3RyaW5ncyBhbmQgYXJyYXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoJ2Zvb2JhcicsICdiYXInLCAnZm9vYmFyIGNvbnRhaW5zIHN0cmluZyBcImJhclwiJyk7XG4gICAqICAgICBhc3NlcnQuaW5jbHVkZShbIDEsIDIsIDMgXSwgMywgJ2FycmF5IGNvbnRhaW5zIHZhbHVlJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0LmluY2x1ZGUpLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgZG9lcyBub3QgaW5jbHVkZSBgbmVlZGxlYC4gV29ya3NcbiAgICogZm9yIHN0cmluZ3MgYW5kIGFycmF5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKCdmb29iYXInLCAnYmF6JywgJ3N0cmluZyBub3QgaW5jbHVkZSBzdWJzdHJpbmcnKTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKFsgMSwgMiwgMyBdLCA0LCAnYXJyYXkgbm90IGluY2x1ZGUgY29udGFpbiB2YWx1ZScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3RJbmNsdWRlKS5ub3QuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm1hdGNoKHZhbHVlLCByZWdleHAsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm1hdGNoKCdmb29iYXInLCAvXmZvby8sICdyZWdleHAgbWF0Y2hlcycpO1xuICAgKlxuICAgKiBAbmFtZSBtYXRjaFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5tYXRjaCA9IGZ1bmN0aW9uIChleHAsIHJlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnKS50by5tYXRjaChyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90TWF0Y2godmFsdWUsIHJlZ2V4cCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBkb2VzIG5vdCBtYXRjaCB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE1hdGNoKCdmb29iYXInLCAvXmZvby8sICdyZWdleHAgZG9lcyBub3QgbWF0Y2gnKTtcbiAgICpcbiAgICogQG5hbWUgbm90TWF0Y2hcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90TWF0Y2ggPSBmdW5jdGlvbiAoZXhwLCByZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZykudG8ubm90Lm1hdGNoKHJlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYScpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQucHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90UHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAnY29mZmVlJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLm5vdC5oYXZlLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCB3aGljaCBjYW4gYmUgYVxuICAgKiBzdHJpbmcgdXNpbmcgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgZGVlcCByZWZlcmVuY2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCwgd2hpY2hcbiAgICogY2FuIGJlIGEgc3RyaW5nIHVzaW5nIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXAgcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBQcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEub29sb25nJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBQcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQucHJvcGVydHlWYWwoeyB0ZWE6ICdpcyBnb29kJyB9LCAndGVhJywgJ2lzIGdvb2QnKTtcbiAgICpcbiAgICogQG5hbWUgcHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHlOb3RWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAsIGJ1dCB3aXRoIGEgdmFsdWVcbiAgICogZGlmZmVyZW50IGZyb20gdGhhdCBnaXZlbiBieSBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5Tm90VmFsKHsgdGVhOiAnaXMgZ29vZCcgfSwgJ3RlYScsICdpcyBiYWQnKTtcbiAgICpcbiAgICogQG5hbWUgcHJvcGVydHlOb3RWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnByb3BlcnR5Tm90VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5ub3QuaGF2ZS5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBkZWVwXG4gICAqIHJlZmVyZW5jZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLmdyZWVuJywgJ21hdGNoYScpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5kZWVwLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFByb3BlcnR5Tm90VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCBidXQgd2l0aCBhIHZhbHVlXG4gICAqIGRpZmZlcmVudCBmcm9tIHRoYXQgZ2l2ZW4gYnkgYHZhbHVlYC4gYHByb3BlcnR5YCBjYW4gdXNlIGRvdC0gYW5kXG4gICAqIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXAgcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBQcm9wZXJ0eU5vdFZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEuZ3JlZW4nLCAna29uYWNoYScpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlOb3RWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eU5vdFZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmxlbmd0aE9mKG9iamVjdCwgbGVuZ3RoLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBgbGVuZ3RoYCBwcm9wZXJ0eSB3aXRoIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZihbMSwyLDNdLCAzLCAnYXJyYXkgaGFzIGxlbmd0aCBvZiAzJyk7XG4gICAqICAgICBhc3NlcnQubGVuZ3RoT2YoJ2Zvb2JhcicsIDYsICdzdHJpbmcgaGFzIGxlbmd0aCBvZiA2Jyk7XG4gICAqXG4gICAqIEBuYW1lIGxlbmd0aE9mXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5sZW5ndGhPZiA9IGZ1bmN0aW9uIChleHAsIGxlbiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZykudG8uaGF2ZS5sZW5ndGgobGVuKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC50aHJvd3MoZnVuY3Rpb24sIFtjb25zdHJ1Y3Rvci9zdHJpbmcvcmVnZXhwXSwgW3N0cmluZy9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgKiBgY29uc3RydWN0b3JgLCBvciBhbHRlcm5hdGVseSB0aGF0IGl0IHdpbGwgdGhyb3cgYW4gZXJyb3Igd2l0aCBtZXNzYWdlXG4gICAqIG1hdGNoaW5nIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgJ2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvcicpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgL2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvci8pO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgUmVmZXJlbmNlRXJyb3IpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgUmVmZXJlbmNlRXJyb3IsICdmdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3InKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIFJlZmVyZW5jZUVycm9yLCAvZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yLyk7XG4gICAqXG4gICAqIEBuYW1lIHRocm93c1xuICAgKiBAYWxpYXMgdGhyb3dcbiAgICogQGFsaWFzIFRocm93XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC50aHJvd3MgPSBmdW5jdGlvbiAoZm4sIGVycnQsIGVycnMsIG1zZykge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGVycnQgfHwgZXJydCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgZXJycyA9IGVycnQ7XG4gICAgICBlcnJ0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYXNzZXJ0RXJyID0gbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by50aHJvdyhlcnJ0LCBlcnJzKTtcbiAgICByZXR1cm4gZmxhZyhhc3NlcnRFcnIsICdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90VGhyb3coZnVuY3Rpb24sIFtjb25zdHJ1Y3Rvci9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgX25vdF8gdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgKiBgY29uc3RydWN0b3JgLCBvciBhbHRlcm5hdGVseSB0aGF0IGl0IHdpbGwgbm90IHRocm93IGFuIGVycm9yIHdpdGggbWVzc2FnZVxuICAgKiBtYXRjaGluZyBgcmVnZXhwYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIEVycm9yLCAnZnVuY3Rpb24gZG9lcyBub3QgdGhyb3cnKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdFRocm93XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbiAoZm4sIHR5cGUsIG1zZykge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHR5cGUpIHtcbiAgICAgIG1zZyA9IHR5cGU7XG4gICAgICB0eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLm5vdC5UaHJvdyh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5vcGVyYXRvcih2YWwxLCBvcGVyYXRvciwgdmFsMiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBDb21wYXJlcyB0d28gdmFsdWVzIHVzaW5nIGBvcGVyYXRvcmAuXG4gICAqXG4gICAqICAgICBhc3NlcnQub3BlcmF0b3IoMSwgJzwnLCAyLCAnZXZlcnl0aGluZyBpcyBvaycpO1xuICAgKiAgICAgYXNzZXJ0Lm9wZXJhdG9yKDEsICc+JywgMiwgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqXG4gICAqIEBuYW1lIG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbDFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm9wZXJhdG9yID0gZnVuY3Rpb24gKHZhbCwgb3BlcmF0b3IsIHZhbDIsIG1zZykge1xuICAgIHZhciBvaztcbiAgICBzd2l0Y2gob3BlcmF0b3IpIHtcbiAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgb2sgPSB2YWwgPT0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc9PT0nOlxuICAgICAgICBvayA9IHZhbCA9PT0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc+JzpcbiAgICAgICAgb2sgPSB2YWwgPiB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgb2sgPSB2YWwgPj0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc8JzpcbiAgICAgICAgb2sgPSB2YWwgPCB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgb2sgPSB2YWwgPD0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICchPSc6XG4gICAgICAgIG9rID0gdmFsICE9IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgb2sgPSB2YWwgIT09IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wZXJhdG9yIFwiJyArIG9wZXJhdG9yICsgJ1wiJyk7XG4gICAgfVxuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihvaywgbXNnKTtcbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgdHJ1ZSA9PT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICcgKyB1dGlsLmluc3BlY3QodmFsKSArICcgdG8gYmUgJyArIG9wZXJhdG9yICsgJyAnICsgdXRpbC5pbnNwZWN0KHZhbDIpXG4gICAgICAsICdleHBlY3RlZCAnICsgdXRpbC5pbnNwZWN0KHZhbCkgKyAnIHRvIG5vdCBiZSAnICsgb3BlcmF0b3IgKyAnICcgKyB1dGlsLmluc3BlY3QodmFsMikgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5jbG9zZVRvKGFjdHVhbCwgZXhwZWN0ZWQsIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIGBleHBlY3RlZGAsIHRvIHdpdGhpbiBhICsvLSBgZGVsdGFgIHJhbmdlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmNsb3NlVG8oMS41LCAxLCAwLjUsICdudW1iZXJzIGFyZSBjbG9zZScpO1xuICAgKlxuICAgKiBAbmFtZSBjbG9zZVRvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhY3R1YWxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY2xvc2VUbyA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgZGVsdGEsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLmJlLmNsb3NlVG8oZXhwLCBkZWx0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuYXBwcm94aW1hdGVseShhY3R1YWwsIGV4cGVjdGVkLCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCBgZXhwZWN0ZWRgLCB0byB3aXRoaW4gYSArLy0gYGRlbHRhYCByYW5nZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5hcHByb3hpbWF0ZWx5KDEuNSwgMSwgMC41LCAnbnVtYmVycyBhcmUgY2xvc2UnKTtcbiAgICpcbiAgICogQG5hbWUgYXBwcm94aW1hdGVseVxuICAgKiBAcGFyYW0ge051bWJlcn0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmFwcHJveGltYXRlbHkgPSBmdW5jdGlvbiAoYWN0LCBleHAsIGRlbHRhLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5iZS5hcHByb3hpbWF0ZWx5KGV4cCwgZGVsdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnNhbWVNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGhhdmUgdGhlIHNhbWUgbWVtYmVycy5cbiAgICogT3JkZXIgaXMgbm90IHRha2VuIGludG8gYWNjb3VudC5cbiAgICpcbiAgICogICAgIGFzc2VydC5zYW1lTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAxLCAzIF0sICdzYW1lIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgc2FtZU1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZykudG8uaGF2ZS5zYW1lLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5zYW1lRGVlcE1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIC0gdXNpbmcgYSBkZWVwIGVxdWFsaXR5IGNoZWNraW5nLlxuICAgKiBPcmRlciBpcyBub3QgdGFrZW4gaW50byBhY2NvdW50LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnNhbWVEZWVwTWVtYmVycyhbIHtiOiAzfSwge2E6IDJ9LCB7YzogNX0gXSwgWyB7YzogNX0sIHtiOiAzfSwge2E6IDJ9IF0sICdzYW1lIGRlZXAgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBzYW1lRGVlcE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lRGVlcE1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2cpLnRvLmhhdmUuc2FtZS5kZWVwLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpcyBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgLlxuICAgKiBPcmRlciBpcyBub3QgdGFrZW4gaW50byBhY2NvdW50LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDEgXSwgJ2luY2x1ZGUgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZykudG8uaW5jbHVkZS5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlRGVlcE1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXMgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCAtIHVzaW5nIGRlZXAgZXF1YWxpdHkgY2hlY2tpbmcuXG4gICAqIE9yZGVyIGlzIG5vdCB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAqIER1cGxpY2F0ZXMgYXJlIGlnbm9yZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZURlZXBNZW1iZXJzKFsge2E6IDF9LCB7YjogMn0sIHtjOiAzfSBdLCBbIHtiOiAyfSwge2E6IDF9LCB7YjogMn0gXSwgJ2luY2x1ZGUgZGVlcCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVEZWVwTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGVEZWVwTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2cpLnRvLmluY2x1ZGUuZGVlcC5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5vbmVPZihpbkxpc3QsIGxpc3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IG5vbi1vYmplY3QsIG5vbi1hcnJheSB2YWx1ZSBgaW5MaXN0YCBhcHBlYXJzIGluIHRoZSBmbGF0IGFycmF5IGBsaXN0YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5vbmVPZigxLCBbIDIsIDEgXSwgJ05vdCBmb3VuZCBpbiBsaXN0Jyk7XG4gICAqXG4gICAqIEBuYW1lIG9uZU9mXG4gICAqIEBwYXJhbSB7Kn0gaW5MaXN0XG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGxpc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm9uZU9mID0gZnVuY3Rpb24gKGluTGlzdCwgbGlzdCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihpbkxpc3QsIG1zZykudG8uYmUub25lT2YobGlzdCk7XG4gIH1cblxuICAgLyoqXG4gICAqICMjIyAuY2hhbmdlcyhmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gY2hhbmdlcyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSAyMiB9O1xuICAgKiAgICAgYXNzZXJ0LmNoYW5nZXMoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY2hhbmdlcyA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wKSB7XG4gICAgbmV3IEFzc2VydGlvbihmbikudG8uY2hhbmdlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAgLyoqXG4gICAqICMjIyAuZG9lc05vdENoYW5nZShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgY2hhbmdlcyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKCdmb28nKTsgfTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90Q2hhbmdlKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdENoYW5nZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RDaGFuZ2UgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCkge1xuICAgIG5ldyBBc3NlcnRpb24oZm4pLnRvLm5vdC5jaGFuZ2Uob2JqLCBwcm9wKTtcbiAgfVxuXG4gICAvKipcbiAgICogIyMjIC5pbmNyZWFzZXMoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHkpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGluY3JlYXNlcyBhbiBvYmplY3QgcHJvcGVydHlcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gMTMgfTtcbiAgICogICAgIGFzc2VydC5pbmNyZWFzZXMoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNyZWFzZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNyZWFzZXMgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCkge1xuICAgIG5ldyBBc3NlcnRpb24oZm4pLnRvLmluY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAgLyoqXG4gICAqICMjIyAuZG9lc05vdEluY3JlYXNlKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBpbmNyZWFzZSBvYmplY3QgcHJvcGVydHlcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gOCB9O1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RJbmNyZWFzZShmbiwgb2JqLCAndmFsJyk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RJbmNyZWFzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RJbmNyZWFzZSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wKSB7XG4gICAgbmV3IEFzc2VydGlvbihmbikudG8ubm90LmluY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAgLyoqXG4gICAqICMjIyAuZGVjcmVhc2VzKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkZWNyZWFzZXMgYW4gb2JqZWN0IHByb3BlcnR5XG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDUgfTtcbiAgICogICAgIGFzc2VydC5kZWNyZWFzZXMoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBkZWNyZWFzZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWNyZWFzZXMgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCkge1xuICAgIG5ldyBBc3NlcnRpb24oZm4pLnRvLmRlY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAgLyoqXG4gICAqICMjIyAuZG9lc05vdERlY3JlYXNlKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBkZWNyZWFzZXMgYW4gb2JqZWN0IHByb3BlcnR5XG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDE1IH07XG4gICAqICAgICBhc3NlcnQuZG9lc05vdERlY3JlYXNlKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdERlY3JlYXNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdERlY3JlYXNlID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3ApIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGZuKS50by5ub3QuZGVjcmVhc2Uob2JqLCBwcm9wKTtcbiAgfVxuXG4gIC8qIVxuICAgKiAjIyMgLmlmRXJyb3Iob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIGlmIHZhbHVlIGlzIG5vdCBhIGZhbHNlIHZhbHVlLCBhbmQgdGhyb3dzIGlmIGl0IGlzIGEgdHJ1ZSB2YWx1ZS5cbiAgICogVGhpcyBpcyBhZGRlZCB0byBhbGxvdyBmb3IgY2hhaSB0byBiZSBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIE5vZGUnc1xuICAgKiBhc3NlcnQgY2xhc3MuXG4gICAqXG4gICAqICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdJIGFtIGEgY3VzdG9tIGVycm9yJyk7XG4gICAqICAgICBhc3NlcnQuaWZFcnJvcihlcnIpOyAvLyBSZXRocm93cyBlcnIhXG4gICAqXG4gICAqIEBuYW1lIGlmRXJyb3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAodmFsKSB7XG4gICAgICB0aHJvdyh2YWwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0V4dGVuc2libGUob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgZXh0ZW5zaWJsZSAoY2FuIGhhdmUgbmV3IHByb3BlcnRpZXMgYWRkZWQgdG8gaXQpLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzRXh0ZW5zaWJsZSh7fSk7XG4gICAqXG4gICAqIEBuYW1lIGlzRXh0ZW5zaWJsZVxuICAgKiBAYWxpYXMgZXh0ZW5zaWJsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRXh0ZW5zaWJsZSA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmJlLmV4dGVuc2libGU7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RFeHRlbnNpYmxlKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIF9ub3RfIGV4dGVuc2libGUuXG4gICAqXG4gICAqICAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAqICAgICB2YXIgc2VhbGVkT2JqZWN0ID0gT2JqZWN0LnNlYWwoe30pO1xuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlc2Uoe30pO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90RXh0ZW5zaWJsZShub25FeHRlbnNpYmxlT2JqZWN0KTtcbiAgICogICAgIGFzc2VydC5pc05vdEV4dGVuc2libGUoc2VhbGVkT2JqZWN0KTtcbiAgICogICAgIGFzc2VydC5pc05vdEV4dGVuc2libGUoZnJvemVuT2JqZWN0KTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RFeHRlbnNpYmxlXG4gICAqIEBhbGlhcyBub3RFeHRlbnNpYmxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RFeHRlbnNpYmxlID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmJlLmV4dGVuc2libGU7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNTZWFsZWQob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgc2VhbGVkIChjYW5ub3QgaGF2ZSBuZXcgcHJvcGVydGllcyBhZGRlZCB0byBpdFxuICAgKiBhbmQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIHJlbW92ZWQpLlxuICAgKlxuICAgKiAgICAgdmFyIHNlYWxlZE9iamVjdCA9IE9iamVjdC5zZWFsKHt9KTtcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3Quc2VhbCh7fSk7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNTZWFsZWQoc2VhbGVkT2JqZWN0KTtcbiAgICogICAgIGFzc2VydC5pc1NlYWxlZChmcm96ZW5PYmplY3QpO1xuICAgKlxuICAgKiBAbmFtZSBpc1NlYWxlZFxuICAgKiBAYWxpYXMgc2VhbGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNTZWFsZWQgPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5iZS5zZWFsZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RTZWFsZWQob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgX25vdF8gc2VhbGVkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90U2VhbGVkKHt9KTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RTZWFsZWRcbiAgICogQGFsaWFzIG5vdFNlYWxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90U2VhbGVkID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmJlLnNlYWxlZDtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Zyb3plbihvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBmcm96ZW4gKGNhbm5vdCBoYXZlIG5ldyBwcm9wZXJ0aWVzIGFkZGVkIHRvIGl0XG4gICAqIGFuZCBpdHMgZXhpc3RpbmcgcHJvcGVydGllcyBjYW5ub3QgYmUgbW9kaWZpZWQpLlxuICAgKlxuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgKiAgICAgYXNzZXJ0LmZyb3plbihmcm96ZW5PYmplY3QpO1xuICAgKlxuICAgKiBAbmFtZSBpc0Zyb3plblxuICAgKiBAYWxpYXMgZnJvemVuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGcm96ZW4gPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5iZS5mcm96ZW47XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RGcm96ZW4ob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgX25vdF8gZnJvemVuLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90RnJvemVuKHt9KTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RGcm96ZW5cbiAgICogQGFsaWFzIG5vdEZyb3plblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90RnJvemVuID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmJlLmZyb3plbjtcbiAgfTtcblxuICAvKiFcbiAgICogQWxpYXNlcy5cbiAgICovXG5cbiAgKGZ1bmN0aW9uIGFsaWFzKG5hbWUsIGFzKXtcbiAgICBhc3NlcnRbYXNdID0gYXNzZXJ0W25hbWVdO1xuICAgIHJldHVybiBhbGlhcztcbiAgfSlcbiAgKCdpc09rJywgJ29rJylcbiAgKCdpc05vdE9rJywgJ25vdE9rJylcbiAgKCd0aHJvd3MnLCAndGhyb3cnKVxuICAoJ3Rocm93cycsICdUaHJvdycpXG4gICgnaXNFeHRlbnNpYmxlJywgJ2V4dGVuc2libGUnKVxuICAoJ2lzTm90RXh0ZW5zaWJsZScsICdub3RFeHRlbnNpYmxlJylcbiAgKCdpc1NlYWxlZCcsICdzZWFsZWQnKVxuICAoJ2lzTm90U2VhbGVkJywgJ25vdFNlYWxlZCcpXG4gICgnaXNGcm96ZW4nLCAnZnJvemVuJylcbiAgKCdpc05vdEZyb3plbicsICdub3RGcm96ZW4nKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvaW50ZXJmYWNlL2Fzc2VydC5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInBhdGhcIlxuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJmcy1leHRyYVwiXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJhc3luY1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImFzeW5jXCJcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtd29ya2Zsb3ctY29tcGlsZVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtd29ya2Zsb3ctY29tcGlsZVwiXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0cnVmZmxlLWRlYnVnLXV0aWxzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHJ1ZmZsZS1kZWJ1Zy11dGlsc1wiXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0cnVmZmxlLWFydGlmYWN0b3JcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0cnVmZmxlLWFydGlmYWN0b3JcIlxuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHJ1ZmZsZS1taWdyYXRlXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHJ1ZmZsZS1taWdyYXRlXCJcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtYm94XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHJ1ZmZsZS1ib3hcIlxuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHJ1ZmZsZS1yZXNvbHZlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtcmVzb2x2ZXJcIlxuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNlc3Npb25cIik7XG5cbmltcG9ydCB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCBhc3QgZnJvbSBcImxpYi9hc3Qvc2VsZWN0b3JzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcblxuaW1wb3J0IGNvbmZpZ3VyZVN0b3JlIGZyb20gXCJsaWIvc3RvcmVcIjtcblxuaW1wb3J0ICogYXMgY29udHJvbGxlciBmcm9tIFwibGliL2NvbnRyb2xsZXIvYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5cbmltcG9ydCByb290U2FnYSBmcm9tIFwiLi9zYWdhc1wiO1xuaW1wb3J0IHJlZHVjZXIgZnJvbSBcIi4vcmVkdWNlcnNcIjtcblxuLyoqXG4gKiBEZWJ1Z2dlciBTZXNzaW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlc3Npb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxDb250cmFjdD59IGNvbnRyYWN0cyAtIGNvbnRyYWN0IGRlZmluaXRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gZmlsZXMgLSBhcnJheSBvZiBmaWxlbmFtZXMgZm9yIHNvdXJjZU1hcCBpbmRleGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eEhhc2ggLSB0cmFuc2FjdGlvbiBoYXNoXG4gICAqIEBwYXJhbSB7V2ViM1Byb3ZpZGVyfSBwcm92aWRlciAtIHdlYjMgcHJvdmlkZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRyYWN0cywgZmlsZXMsIHR4SGFzaCwgcHJvdmlkZXIpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3N0b3JlID0gY29uZmlndXJlU3RvcmUocmVkdWNlciwgcm9vdFNhZ2EpO1xuXG4gICAgbGV0IHsgY29udGV4dHMsIHNvdXJjZXMgfSA9IFNlc3Npb24ubm9ybWFsaXplKGNvbnRyYWN0cywgZmlsZXMpO1xuXG4gICAgLy8gcmVjb3JkIGNvbnRyYWN0c1xuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbnMucmVjb3JkQ29udHJhY3RzKGNvbnRleHRzLCBzb3VyY2VzKSk7XG5cbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnN0YXJ0KHR4SGFzaCwgcHJvdmlkZXIpKTtcbiAgfVxuXG4gIHJlYWR5KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSggKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9zdG9yZS5zdWJzY3JpYmUoICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2Vzc2lvbiA9PSBcIkFDVElWRVwiKSB7XG4gICAgICAgICAgYWNjZXB0KClcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5zdGF0ZS5zZXNzaW9uID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICByZWplY3QodGhpcy5zdGF0ZS5zZXNzaW9uLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdXAgYXJ0aWZhY3RzIGludG8gXCJjb250ZXh0c1wiIGFuZCBcInNvdXJjZXNcIiwgZGl2aWRpbmcgYXJ0aWZhY3RcbiAgICogZGF0YSBpbnRvIGFwcHJvcHJpYXRlIGJ1Y2tldHMuXG4gICAqXG4gICAqIE11bHRpcGxlIGNvbnRyYWN0cyBjYW4gYmUgZGVmaW5lZCBpbiB0aGUgc2FtZSBzb3VyY2UgZmlsZSwgYnV0IGhhdmVcbiAgICogZGlmZmVyZW50IGJ5dGVjb2Rlcy5cbiAgICpcbiAgICogVGhpcyBpdGVyYXRlcyBvdmVyIHRoZSBjb250cmFjdHMgYW5kIGNvbGxlY3RzIGJpbmFyaWVzIHNlcGFyYXRlbHlcbiAgICogZnJvbSBzb3VyY2VzLCB1c2luZyB0aGUgb3B0aW9uYWwgYGZpbGVzYCBhcmd1bWVudCB0byBmb3JjZVxuICAgKiBzb3VyY2Ugb3JkZXJpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplKGNvbnRyYWN0cywgZmlsZXMgPSBudWxsKSB7XG4gICAgbGV0IHNvdXJjZXNCeVBhdGggPSB7fTtcbiAgICBsZXQgY29udGV4dHMgPSBbXTtcbiAgICBsZXQgc291cmNlcztcblxuICAgIGZvciAobGV0IGNvbnRyYWN0IG9mIGNvbnRyYWN0cykge1xuICAgICAgbGV0IHtcbiAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICBiaW5hcnksXG4gICAgICAgIHNvdXJjZU1hcCxcbiAgICAgICAgZGVwbG95ZWRCaW5hcnksXG4gICAgICAgIGRlcGxveWVkU291cmNlTWFwLFxuICAgICAgICBzb3VyY2VQYXRoLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGFzdFxuICAgICAgfSA9IGNvbnRyYWN0O1xuXG4gICAgICBzb3VyY2VzQnlQYXRoW3NvdXJjZVBhdGhdID0geyBzb3VyY2VQYXRoLCBzb3VyY2UsIGFzdCB9O1xuXG4gICAgICBpZiAoYmluYXJ5ICYmIGJpbmFyeSAhPSBcIjB4XCIpIHtcbiAgICAgICAgY29udGV4dHMucHVzaCh7XG4gICAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICAgIGJpbmFyeSxcbiAgICAgICAgICBzb3VyY2VNYXBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZXBsb3llZEJpbmFyeSAmJiBkZXBsb3llZEJpbmFyeSAhPSBcIjB4XCIpIHtcbiAgICAgICAgY29udGV4dHMucHVzaCh7XG4gICAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICAgIGJpbmFyeTogZGVwbG95ZWRCaW5hcnksXG4gICAgICAgICAgc291cmNlTWFwOiBkZXBsb3llZFNvdXJjZU1hcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZpbGVzKSB7XG4gICAgICBzb3VyY2VzID0gT2JqZWN0LnZhbHVlcyhzb3VyY2VzQnlQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlcyA9IGZpbGVzLm1hcChmaWxlID0+IHNvdXJjZXNCeVBhdGhbZmlsZV0pO1xuICAgIH1cblxuICAgIHJldHVybiB7IGNvbnRleHRzLCBzb3VyY2VzIH07XG4gIH1cblxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLmdldFN0YXRlKCk7XG4gIH1cblxuICB2aWV3KHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yKHRoaXMuc3RhdGUpO1xuICB9XG5cbiAgZ2V0IGZpbmlzaGVkKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnNlc3Npb24gPT0gXCJGSU5JU0hFRFwiO1xuICB9XG5cbiAgZ2V0IGZhaWxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hlZCAmJiB0aGlzLnZpZXcoZXZtLmN1cnJlbnQuY2FsbHN0YWNrKS5sZW5ndGhcbiAgfVxuXG4gIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICh0aGlzLmZpbmlzaGVkKSB7XG4gICAgICBkZWJ1ZyhcImZpbmlzaGVkOiBpbnRlcmNlcHRpbmcgYWN0aW9uICVvXCIsIGFjdGlvbik7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb24pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbnRlcnJ1cHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5pbnRlcnJ1cHQoKSk7XG4gIH1cblxuICBhZHZhbmNlKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuYWR2YW5jZSgpKTtcbiAgfVxuXG4gIHN0ZXBOZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuc3RlcE5leHQoKSk7XG4gIH1cblxuICBzdGVwT3ZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChjb250cm9sbGVyLnN0ZXBPdmVyKCkpO1xuICB9XG5cbiAgc3RlcEludG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5zdGVwSW50bygpKTtcbiAgfVxuXG4gIHN0ZXBPdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5zdGVwT3V0KCkpO1xuICB9XG5cbiAgY29udGludWVVbnRpbCguLi5icmVha3BvaW50cykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuY29udGludWVVbnRpbCguLi5icmVha3BvaW50cykpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3Nlc3Npb24vaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3ZhbHVlc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvdmFsdWVzXCJcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtc29saWRpdHktdXRpbHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0cnVmZmxlLXNvbGlkaXR5LXV0aWxzXCJcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtY29kZS11dGlsc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtY29kZS11dGlsc1wiXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJub2RlLWludGVydmFsLXRyZWVcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJub2RlLWludGVydmFsLXRyZWVcIlxuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcHJvZHVjdGlvblwiKTtcbn0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT0gXCJ0ZXN0XCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi90ZXN0XCIpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9kZXZlbG9wbWVudFwiKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc3RvcmUvaW5kZXguanMiLCJpbXBvcnQgY29uZmlndXJlU3RvcmUgZnJvbSBcIi4vY29tbW9uXCI7XG5leHBvcnQgZGVmYXVsdCBjb25maWd1cmVTdG9yZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc3RvcmUvdGVzdC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpzdG9yZTpjb21tb25cIik7XG5jb25zdCByZWR1eERlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpyZWR1eFwiKTtcblxuaW1wb3J0IHsgY29tcG9zZSwgY3JlYXRlU3RvcmUsIGFwcGx5TWlkZGxld2FyZSB9IGZyb20gXCJyZWR1eFwiO1xuaW1wb3J0IGNyZWF0ZVNhZ2FNaWRkbGV3YXJlIGZyb20gXCJyZWR1eC1zYWdhXCI7XG5pbXBvcnQgY3JlYXRlTG9nZ2VyIGZyb20gXCJyZWR1eC1jbGktbG9nZ2VyXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBhYmJyZXZpYXRlVmFsdWVzKHZhbHVlLCBvcHRpb25zID0ge30sIGRlcHRoID0gMCkge1xuICBvcHRpb25zLnN0cmluZ0xpbWl0ID0gb3B0aW9ucy5zdHJpbmdMaW1pdCB8fCA2NjtcbiAgb3B0aW9ucy5hcnJheUxpbWl0ID0gb3B0aW9ucy5hcnJheUxpbWl0IHx8IDg7XG4gIG9wdGlvbnMucmVjdXJzZUxpbWl0ID0gb3B0aW9ucy5yZWN1cnNlTGltaXQgfHwgNDtcblxuICBpZiAoZGVwdGggPiBvcHRpb25zLnJlY3Vyc2VMaW1pdCkge1xuICAgIHJldHVybiBcIi4uLlwiO1xuICB9XG5cbiAgY29uc3QgcmVjdXJzZSA9IChjaGlsZCkgPT4gYWJicmV2aWF0ZVZhbHVlcyhjaGlsZCwgb3B0aW9ucywgZGVwdGggKyAxKTtcblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPiBvcHRpb25zLmFycmF5TGltaXQpIHtcbiAgICAgIHZhbHVlID0gW1xuICAgICAgICAuLi52YWx1ZS5zbGljZSgwLCBvcHRpb25zLmFycmF5TGltaXQgLyAyKSxcbiAgICAgICAgXCIuLi5cIixcbiAgICAgICAgLi4udmFsdWUuc2xpY2UodmFsdWUubGVuZ3RoIC0gb3B0aW9ucy5hcnJheUxpbWl0IC8gMiArIDEpXG4gICAgICBdO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS5tYXAocmVjdXJzZSk7XG5cbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgLi4uT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcChcbiAgICAgICAgKFtrLCB2XSkgPT4gKHsgW3JlY3Vyc2UoayldOiByZWN1cnNlKHYpIH0pXG4gICAgICApXG4gICAgKTtcblxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5sZW5ndGggPiBvcHRpb25zLnN0cmluZ0xpbWl0KSB7XG4gICAgbGV0IGlubmVyID0gXCIuLi5cIjtcbiAgICBsZXQgZXh0cmFjdEFtb3VudCA9IChvcHRpb25zLnN0cmluZ0xpbWl0IC0gaW5uZXIubGVuZ3RoKSAvIDI7XG4gICAgbGV0IGxlYWRpbmcgPSB2YWx1ZS5zbGljZSgwLCBNYXRoLmNlaWwoZXh0cmFjdEFtb3VudCkpO1xuICAgIGxldCB0cmFpbGluZyA9IHZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aCAtIE1hdGguZmxvb3IoZXh0cmFjdEFtb3VudCkpO1xuICAgIHJldHVybiBgJHtsZWFkaW5nfSR7aW5uZXJ9JHt0cmFpbGluZ31gO1xuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbmZpZ3VyZVN0b3JlIChyZWR1Y2VyLCBzYWdhLCBpbml0aWFsU3RhdGUsIGNvbXBvc2VFbmhhbmNlcnMpIHtcbiAgY29uc3Qgc2FnYU1pZGRsZXdhcmUgPSBjcmVhdGVTYWdhTWlkZGxld2FyZSgpO1xuXG4gIGlmICghY29tcG9zZUVuaGFuY2Vycykge1xuICAgIGNvbXBvc2VFbmhhbmNlcnMgPSBjb21wb3NlO1xuICB9XG5cbiAgY29uc3QgbG9nZ2VyTWlkZGxld2FyZSA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgbG9nOiByZWR1eERlYnVnLFxuICAgIHN0YXRlVHJhbnNmb3JtZXI6IChzdGF0ZSkgPT4gYWJicmV2aWF0ZVZhbHVlcyhzdGF0ZSwge1xuICAgICAgYXJyYXlMaW1pdDogNCxcbiAgICAgIHJlY3Vyc2VMaW1pdDogM1xuICAgIH0pLFxuICAgIGFjdGlvblRyYW5zZm9ybWVyOiBhYmJyZXZpYXRlVmFsdWVzLFxuICB9KTtcblxuICBsZXQgc3RvcmUgPSBjcmVhdGVTdG9yZShcbiAgICByZWR1Y2VyLCBpbml0aWFsU3RhdGUsXG5cbiAgICBjb21wb3NlRW5oYW5jZXJzKFxuICAgICAgYXBwbHlNaWRkbGV3YXJlKFxuICAgICAgICBzYWdhTWlkZGxld2FyZSxcbiAgICAgICAgbG9nZ2VyTWlkZGxld2FyZVxuICAgICAgKVxuICAgIClcbiAgKTtcblxuICBzYWdhTWlkZGxld2FyZS5ydW4oc2FnYSk7XG5cbiAgcmV0dXJuIHN0b3JlO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zdG9yZS9jb21tb24uanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWR1eC1zYWdhXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVkdXgtc2FnYVwiXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXgtY2xpLWxvZ2dlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJlZHV4LWNsaS1sb2dnZXJcIlxuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpzZXNzaW9uOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBjYW5jZWwsIGNhbGwsIGFsbCwgZm9yaywgdGFrZSwgcHV0IH0gZnJvbSAncmVkdXgtc2FnYS9lZmZlY3RzJztcblxuaW1wb3J0IHsgcHJlZml4TmFtZSB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBhc3QgZnJvbSBcImxpYi9hc3Qvc2FnYXNcIjtcbmltcG9ydCAqIGFzIGNvbnRyb2xsZXIgZnJvbSBcImxpYi9jb250cm9sbGVyL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBldm0gZnJvbSBcImxpYi9ldm0vc2FnYXNcIjtcbmltcG9ydCAqIGFzIHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2FnYXNcIjtcbmltcG9ydCAqIGFzIGRhdGEgZnJvbSBcImxpYi9kYXRhL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyB3ZWIzIGZyb20gXCJsaWIvd2ViMy9zYWdhc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiAqc2FnYSAoKSB7XG4gIGRlYnVnKFwic3RhcnRpbmcgbGlzdGVuZXJzXCIpO1xuICBsZXQgbGlzdGVuZXJzID0geWllbGQgKmZvcmtMaXN0ZW5lcnMoKTtcblxuICAvLyByZWNlaXZpbmcgJiBzYXZpbmcgY29udHJhY3RzIGludG8gc3RhdGVcbiAgZGVidWcoXCJ3YWl0aW5nIGZvciBjb250cmFjdCBpbmZvcm1hdGlvblwiKTtcbiAgbGV0IHsgY29udGV4dHMsIHNvdXJjZXMgfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5SRUNPUkRfQ09OVFJBQ1RTKTtcblxuICBkZWJ1ZyhcInJlY29yZGluZyBjb250cmFjdCBiaW5hcmllc1wiKTtcbiAgeWllbGQgKnJlY29yZENvbnRleHRzKC4uLmNvbnRleHRzKTtcblxuICBkZWJ1ZyhcInJlY29yZGluZyBjb250cmFjdCBzb3VyY2VzXCIpO1xuICB5aWVsZCAqcmVjb3JkU291cmNlcyguLi5zb3VyY2VzKTtcblxuICBkZWJ1ZyhcIndhaXRpbmcgZm9yIHN0YXJ0XCIpO1xuICAvLyB3YWl0IGZvciBzdGFydCBzaWduYWxcbiAgbGV0IHt0eEhhc2gsIHByb3ZpZGVyfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5TVEFSVCk7XG4gIGRlYnVnKFwic3RhcnRpbmdcIik7XG5cbiAgLy8gcHJvY2VzcyB0cmFuc2FjdGlvblxuICBkZWJ1ZyhcImZldGNoaW5nIHRyYW5zYWN0aW9uIGluZm9cIik7XG4gIGxldCBlcnIgPSB5aWVsZCAqZmV0Y2hUeCh0eEhhc2gsIHByb3ZpZGVyKTtcbiAgaWYgKGVycikge1xuICAgIGRlYnVnKFwiZXJyb3IgJW9cIiwgZXJyKTtcbiAgICB5aWVsZCAqZXJyb3IoZXJyKTtcblxuICB9IGVsc2Uge1xuICAgIGRlYnVnKFwidmlzaXRpbmcgQVNUc1wiKTtcbiAgICAvLyB2aXNpdCBhc3RzXG4gICAgeWllbGQgKmFzdC52aXNpdEFsbCgpO1xuXG4gICAgZGVidWcoXCJyZWFkeWluZ1wiKTtcbiAgICAvLyBzaWduYWwgdGhhdCBzdGVwcGluZyBjYW4gYmVnaW5cbiAgICB5aWVsZCAqcmVhZHkoKTtcblxuICAgIGRlYnVnKFwid2FpdGluZyBmb3IgdHJhY2UgRU9UXCIpO1xuICAgIC8vIHdhaXQgdW50aWwgdHJhY2UgaGl0cyBFT1RcbiAgICB5aWVsZCAqdHJhY2Uud2FpdCgpO1xuXG4gICAgZGVidWcoXCJmaW5pc2hpbmdcIik7XG4gICAgLy8gZmluaXNoXG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZmluaXNoKCkpO1xuICB9XG5cbiAgZGVidWcoXCJzdG9wcGluZyBsaXN0ZW5lcnNcIik7XG4gIHlpZWxkIGFsbChcbiAgICBsaXN0ZW5lcnMubWFwKHRhc2sgPT4gY2FuY2VsKHRhc2spKVxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwic2Vzc2lvblwiLCBzYWdhKTtcblxuXG5mdW5jdGlvbiAqZm9ya0xpc3RlbmVycygpIHtcbiAgcmV0dXJuIHlpZWxkIGFsbChcbiAgICBbYXN0LCBjb250cm9sbGVyLCBkYXRhLCBldm0sIHNvbGlkaXR5LCB0cmFjZSwgd2ViM11cbiAgICAgIC5tYXAoIGFwcCA9PiBmb3JrKGFwcC5zYWdhKSApXG4gICk7XG59XG5cbmZ1bmN0aW9uKiBmZXRjaFR4KHR4SGFzaCwgcHJvdmlkZXIpIHtcbiAgbGV0IHJlc3VsdCA9IHlpZWxkICp3ZWIzLmluc3BlY3RUcmFuc2FjdGlvbih0eEhhc2gsIHByb3ZpZGVyKTtcblxuICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgcmV0dXJuIHJlc3VsdC5lcnJvcjtcbiAgfVxuXG4gIHlpZWxkICpldm0uYmVnaW4ocmVzdWx0KTtcblxuICBsZXQgYWRkcmVzc2VzID0geWllbGQgKnRyYWNlLnByb2Nlc3NUcmFjZShyZXN1bHQudHJhY2UpO1xuICBpZiAocmVzdWx0LmFkZHJlc3MgJiYgYWRkcmVzc2VzLmluZGV4T2YocmVzdWx0LmFkZHJlc3MpID09IC0xKSB7XG4gICAgYWRkcmVzc2VzLnB1c2gocmVzdWx0LmFkZHJlc3MpO1xuICB9XG5cbiAgbGV0IGJpbmFyaWVzID0geWllbGQgKndlYjMub2J0YWluQmluYXJpZXMoYWRkcmVzc2VzKTtcblxuICB5aWVsZCBhbGwoXG4gICAgYWRkcmVzc2VzLm1hcCggKGFkZHJlc3MsIGkpID0+IGNhbGwocmVjb3JkSW5zdGFuY2UsIGFkZHJlc3MsIGJpbmFyaWVzW2ldKSApXG4gICk7XG59XG5cbmZ1bmN0aW9uKiByZWNvcmRDb250ZXh0cyguLi5jb250ZXh0cykge1xuICBmb3IgKGxldCB7IGNvbnRyYWN0TmFtZSwgYmluYXJ5LCBzb3VyY2VNYXAgfSBvZiBjb250ZXh0cykge1xuICAgIHlpZWxkICpldm0uYWRkQ29udGV4dChjb250cmFjdE5hbWUsIGJpbmFyeSk7XG5cbiAgICBpZiAoc291cmNlTWFwKSB7XG4gICAgICB5aWVsZCAqc29saWRpdHkuYWRkU291cmNlTWFwKGJpbmFyeSwgc291cmNlTWFwKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24qIHJlY29yZFNvdXJjZXMoLi4uc291cmNlcykge1xuICBmb3IgKGxldCB7IHNvdXJjZVBhdGgsIHNvdXJjZSwgYXN0IH0gb2Ygc291cmNlcykge1xuICAgIHlpZWxkICpzb2xpZGl0eS5hZGRTb3VyY2Uoc291cmNlLCBzb3VyY2VQYXRoLCBhc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uICpyZWNvcmRJbnN0YW5jZShhZGRyZXNzLCBiaW5hcnkpIHtcbiAgeWllbGQgKmV2bS5hZGRJbnN0YW5jZShhZGRyZXNzLCBiaW5hcnkpO1xufVxuXG5mdW5jdGlvbiAqcmVhZHkoKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnJlYWR5KCkpO1xufVxuXG5mdW5jdGlvbiAqZXJyb3IoZXJyKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmVycm9yKGVycikpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zZXNzaW9uL3NhZ2FzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmFzdDpzYWdhc1wiKTtcblxuaW1wb3J0IHsgYWxsLCBjYWxsLCByYWNlLCBmb3JrLCBqb2luLCB0YWtlLCB0YWtlRXZlcnksIHB1dCwgc2VsZWN0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuXG5pbXBvcnQgeyBwcmVmaXhOYW1lIH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCAqIGFzIGRhdGEgZnJvbSBcImxpYi9kYXRhL3NhZ2FzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuaW1wb3J0IGFzdCBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cblxuZnVuY3Rpb24gKndhbGsoc291cmNlSWQsIG5vZGUsIHBvaW50ZXIgPSBcIlwiLCBwYXJlbnRJZCA9IG51bGwpIHtcbiAgZGVidWcoXCJ3YWxraW5nICVvICVvXCIsIHBvaW50ZXIsIG5vZGUpO1xuXG4gIHlpZWxkICpoYW5kbGVFbnRlcihzb3VyY2VJZCwgbm9kZSwgcG9pbnRlciwgcGFyZW50SWQpO1xuXG4gIGlmIChub2RlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBmb3IgKGxldCBbaSwgY2hpbGRdIG9mIG5vZGUuZW50cmllcygpKSB7XG4gICAgICB5aWVsZCBjYWxsKHdhbGssIHNvdXJjZUlkLCBjaGlsZCwgYCR7cG9pbnRlcn0vJHtpfWAsIHBhcmVudElkKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIGZvciAobGV0IFtrZXksIGNoaWxkXSBvZiBPYmplY3QuZW50cmllcyhub2RlKSkge1xuICAgICAgeWllbGQgY2FsbCh3YWxrLCBzb3VyY2VJZCwgY2hpbGQsIGAke3BvaW50ZXJ9LyR7a2V5fWAsIG5vZGUuaWQpO1xuICAgIH1cbiAgfVxuXG4gIHlpZWxkICpoYW5kbGVFeGl0KHNvdXJjZUlkLCBub2RlLCBwb2ludGVyKTtcbn1cblxuZnVuY3Rpb24gKmhhbmRsZUVudGVyKHNvdXJjZUlkLCBub2RlLCBwb2ludGVyLCBwYXJlbnRJZCkge1xuICBpZiAoIShub2RlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRlYnVnKFwiZW50ZXJpbmcgJXNcIiwgcG9pbnRlcik7XG5cbiAgaWYgKG5vZGUuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlYnVnKFwiJXMgcmVjb3JkaW5nIHNjb3BlICVzXCIsIHBvaW50ZXIsIG5vZGUuaWQpO1xuICAgIHlpZWxkICpkYXRhLnNjb3BlKG5vZGUuaWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCk7XG4gIH1cblxuICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICBjYXNlIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiOlxuICAgICAgZGVidWcoXCIlcyByZWNvcmRpbmcgdmFyaWFibGUgJW9cIiwgcG9pbnRlciwgbm9kZSk7XG4gICAgICB5aWVsZCAqZGF0YS5kZWNsYXJlKG5vZGUpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gKmhhbmRsZUV4aXQoc291cmNlSWQsIG5vZGUsIHBvaW50ZXIpIHtcbiAgZGVidWcoXCJleGl0aW5nICVzXCIsIHBvaW50ZXIpO1xuXG4gIC8vIG5vLW9wIHJpZ2h0IG5vd1xufVxuXG5mdW5jdGlvbiAqd2Fsa1NhZ2Eoe3NvdXJjZUlkLCBhc3R9KSB7XG4gIHlpZWxkIHdhbGsoc291cmNlSWQsIGFzdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAqdmlzaXRBbGwoaWR4KSB7XG4gIGxldCBzb3VyY2VzID0geWllbGQgc2VsZWN0KGFzdC52aWV3cy5zb3VyY2VzKTtcblxuICBsZXQgdGFza3MgPSB5aWVsZCBhbGwoXG4gICAgT2JqZWN0LmVudHJpZXMoc291cmNlcylcbiAgICAgIC5maWx0ZXIoIChbaWQsIHthc3R9XSkgPT4gISFhc3QgKVxuICAgICAgLm1hcCggKFtpZCwge2FzdH1dKSA9PiBmb3JrKCAoKSA9PiBwdXQoYWN0aW9ucy52aXNpdChpZCwgYXN0KSkpIClcbiAgKVxuXG4gIGlmICh0YXNrcy5sZW5ndGggPiAwKSB7XG4gICAgeWllbGQgam9pbiguLi50YXNrcyk7XG4gIH1cblxuICB5aWVsZCBwdXQoYWN0aW9ucy5kb25lVmlzaXRpbmcoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgeWllbGQgcmFjZSh7XG4gICAgdmlzaXRvcjogdGFrZUV2ZXJ5KGFjdGlvbnMuVklTSVQsIHdhbGtTYWdhKSxcbiAgICBkb25lOiB0YWtlKGFjdGlvbnMuRE9ORV9WSVNJVElORylcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWZpeE5hbWUoXCJhc3RcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2FzdC9zYWdhcy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpkYXRhOmRlY29kZVwiKTtcblxuaW1wb3J0IHtCaWdOdW1iZXJ9IGZyb20gXCJiaWdudW1iZXIuanNcIjtcblxuaW1wb3J0ICogYXMgbWVtb3J5IGZyb20gXCIuL21lbW9yeVwiO1xuaW1wb3J0ICogYXMgc3RvcmFnZSBmcm9tIFwiLi9zdG9yYWdlXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgV09SRF9TSVpFIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWQocG9pbnRlciwgc3RhdGUpIHtcbiAgaWYgKHBvaW50ZXIuc3RhY2sgIT0gdW5kZWZpbmVkICYmIHN0YXRlLnN0YWNrICYmIHBvaW50ZXIuc3RhY2sgPCBzdGF0ZS5zdGFjay5sZW5ndGgpIHtcbiAgICByZXR1cm4gc3RhdGUuc3RhY2tbcG9pbnRlci5zdGFja107XG4gIH0gZWxzZSBpZiAocG9pbnRlci5zdG9yYWdlICE9IHVuZGVmaW5lZCAmJiBzdGF0ZS5zdG9yYWdlKSB7XG4gICAgcmV0dXJuIHN0b3JhZ2UucmVhZFJhbmdlKHN0YXRlLnN0b3JhZ2UsIHBvaW50ZXIuc3RvcmFnZSk7XG4gIH0gZWxzZSBpZiAocG9pbnRlci5tZW1vcnkgIT0gdW5kZWZpbmVkICYmIHN0YXRlLm1lbW9yeSkge1xuICAgIHJldHVybiBtZW1vcnkucmVhZEJ5dGVzKHN0YXRlLm1lbW9yeSwgcG9pbnRlci5tZW1vcnkuc3RhcnQsIHBvaW50ZXIubWVtb3J5Lmxlbmd0aCk7XG4gIH0gZWxzZSBpZiAocG9pbnRlci5saXRlcmFsKSB7XG4gICAgcmV0dXJuIHBvaW50ZXIubGl0ZXJhbDtcbiAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVWYWx1ZShkZWZpbml0aW9uLCBwb2ludGVyLCBzdGF0ZSwgLi4uYXJncykge1xuICBsZXQgYnl0ZXMgPSByZWFkKHBvaW50ZXIsIHN0YXRlKTtcbiAgaWYgKCFieXRlcykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBzd2l0Y2ggKHV0aWxzLnR5cGVDbGFzcyhkZWZpbml0aW9uKSkge1xuICAgIGNhc2UgXCJib29sXCI6XG4gICAgICByZXR1cm4gIXV0aWxzLnRvQmlnTnVtYmVyKGJ5dGVzKS5pc1plcm8oKTtcblxuICAgIGNhc2UgXCJ1aW50XCI6XG4gICAgICByZXR1cm4gdXRpbHMudG9CaWdOdW1iZXIoYnl0ZXMpO1xuXG4gICAgY2FzZSBcImludFwiOlxuICAgICAgcmV0dXJuIHV0aWxzLnRvU2lnbmVkQmlnTnVtYmVyKGJ5dGVzKTtcblxuICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICByZXR1cm4gdXRpbHMudG9IZXhTdHJpbmcoYnl0ZXMsIHRydWUpO1xuXG4gICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICBkZWJ1ZyhcInR5cGVJZGVudGlmaWVyICVzICVvXCIsIHV0aWxzLnR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pLCBieXRlcyk7XG4gICAgICBsZXQgbGVuZ3RoID0gdXRpbHMuc3BlY2lmaWVkU2l6ZShkZWZpbml0aW9uKTtcbiAgICAgIHJldHVybiB1dGlscy50b0hleFN0cmluZyhieXRlcywgbGVuZ3RoKTtcblxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGRlYnVnKFwidHlwZUlkZW50aWZpZXIgJXMgJW9cIiwgdXRpbHMudHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbiksIGJ5dGVzKTtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBkZWJ1ZyhcIlVua25vd24gdmFsdWUgdHlwZTogJXNcIiwgdXRpbHMudHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbikpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU1lbW9yeVJlZmVyZW5jZShkZWZpbml0aW9uLCBwb2ludGVyLCBzdGF0ZSwgLi4uYXJncykge1xuICBsZXQgcmF3VmFsdWUgPSB1dGlscy50b0JpZ051bWJlcihyZWFkKHBvaW50ZXIsIHN0YXRlKSkudG9OdW1iZXIoKTtcblxuICB2YXIgYnl0ZXM7XG4gIHN3aXRjaCAodXRpbHMudHlwZUNsYXNzKGRlZmluaXRpb24pKSB7XG5cbiAgICBjYXNlIFwiYnl0ZXNcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBieXRlcyA9IHJlYWQoe1xuICAgICAgICBtZW1vcnk6IHsgc3RhcnQ6IHJhd1ZhbHVlLCBsZW5ndGg6IFdPUkRfU0laRX1cbiAgICAgIH0sIHN0YXRlKTsgLy8gYnl0ZXMgY29udGFpbiBsZW5ndGhcblxuICAgICAgcmV0dXJuIGRlY29kZVZhbHVlKGRlZmluaXRpb24sIHtcbiAgICAgICAgbWVtb3J5OiB7IHN0YXJ0OiByYXdWYWx1ZSArIFdPUkRfU0laRSwgbGVuZ3RoOiBieXRlcyB9XG4gICAgICB9LCBzdGF0ZSwgLi4uYXJncyk7XG5cbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIGJ5dGVzID0gdXRpbHMudG9CaWdOdW1iZXIocmVhZCh7XG4gICAgICAgIG1lbW9yeTogeyBzdGFydDogcmF3VmFsdWUsIGxlbmd0aDogV09SRF9TSVpFIH0sXG4gICAgICB9LCBzdGF0ZSkpLnRvTnVtYmVyKCk7ICAvLyBieXRlcyBjb250YWluIGFycmF5IGxlbmd0aFxuXG4gICAgICBieXRlcyA9IHJlYWQoeyBtZW1vcnk6IHtcbiAgICAgICAgc3RhcnQ6IHJhd1ZhbHVlICsgV09SRF9TSVpFLCBsZW5ndGg6IGJ5dGVzICogV09SRF9TSVpFXG4gICAgICB9fSwgc3RhdGUpOyAvLyBub3cgYnl0ZXMgY29udGFpbiBpdGVtc1xuXG4gICAgICByZXR1cm4gbWVtb3J5LmNodW5rKGJ5dGVzLCBXT1JEX1NJWkUpXG4gICAgICAgIC5tYXAoXG4gICAgICAgICAgKGNodW5rKSA9PiBkZWNvZGUodXRpbHMuYmFzZURlZmluaXRpb24oZGVmaW5pdGlvbiksIHtcbiAgICAgICAgICAgIGxpdGVyYWw6IGNodW5rXG4gICAgICAgICAgfSwgc3RhdGUsIC4uLmFyZ3MpXG4gICAgICAgIClcblxuICAgIGNhc2UgXCJzdHJ1Y3RcIjpcbiAgICAgIGxldCBbcmVmc10gPSBhcmdzO1xuICAgICAgbGV0IHN0cnVjdERlZmluaXRpb24gPSByZWZzW2RlZmluaXRpb24udHlwZU5hbWUucmVmZXJlbmNlZERlY2xhcmF0aW9uXTtcbiAgICAgIGxldCBzdHJ1Y3RWYXJpYWJsZXMgPSBzdHJ1Y3REZWZpbml0aW9uLnZhcmlhYmxlcyB8fCBbXTtcblxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LCAuLi5zdHJ1Y3RWYXJpYWJsZXNcbiAgICAgICAgICAubWFwKFxuICAgICAgICAgICAgKHtuYW1lLCBpZH0sIGkpID0+IHtcbiAgICAgICAgICAgICAgbGV0IG1lbWJlckRlZmluaXRpb24gPSByZWZzW2lkXS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgICBsZXQgbWVtYmVyUG9pbnRlciA9IHtcbiAgICAgICAgICAgICAgICBtZW1vcnk6IHsgc3RhcnQ6IHJhd1ZhbHVlICsgaSAqIFdPUkRfU0laRSwgbGVuZ3RoOiBXT1JEX1NJWkUgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAvLyBsZXQgbWVtYmVyUG9pbnRlciA9IG1lbW9yeS5yZWFkKHN0YXRlLm1lbW9yeSwgcG9pbnRlciArIGkgKiBXT1JEX1NJWkUpO1xuXG4gICAgICAgICAgICAgIC8vIEhBQ0tcbiAgICAgICAgICAgICAgbWVtYmVyRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAuLi5tZW1iZXJEZWZpbml0aW9uLFxuXG4gICAgICAgICAgICAgICAgdHlwZURlc2NyaXB0aW9uczoge1xuICAgICAgICAgICAgICAgICAgLi4ubWVtYmVyRGVmaW5pdGlvbi50eXBlRGVzY3JpcHRpb25zLFxuXG4gICAgICAgICAgICAgICAgICB0eXBlSWRlbnRpZmllcjpcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyRGVmaW5pdGlvbi50eXBlRGVzY3JpcHRpb25zLnR5cGVJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL19zdG9yYWdlXy9nLCBcIl9tZW1vcnlfXCIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgW25hbWVdOiBkZWNvZGUoXG4gICAgICAgICAgICAgICAgICBtZW1iZXJEZWZpbml0aW9uLCBtZW1iZXJQb2ludGVyLCBzdGF0ZSwgLi4uYXJnc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICApO1xuXG5cbiAgICBkZWZhdWx0OlxuICAgICAgZGVidWcoXCJVbmtub3duIG1lbW9yeSByZWZlcmVuY2UgdHlwZTogJXNcIiwgdXRpbHMudHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbikpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgfVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdG9yYWdlUmVmZXJlbmNlKGRlZmluaXRpb24sIHBvaW50ZXIsIHN0YXRlLCAuLi5hcmdzKSB7XG4gIHZhciBkYXRhO1xuICB2YXIgYnl0ZXM7XG4gIHZhciBsZW5ndGg7XG4gIHZhciBzbG90O1xuXG4gIHN3aXRjaCAodXRpbHMudHlwZUNsYXNzKGRlZmluaXRpb24pKSB7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICBkZWJ1ZyhcInN0b3JhZ2UgYXJyYXkhICVvXCIsIHBvaW50ZXIpO1xuICAgICAgZGF0YSA9IHJlYWQocG9pbnRlciwgc3RhdGUpO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSB1dGlscy50b0JpZ051bWJlcihkYXRhKS50b051bWJlcigpO1xuICAgICAgZGVidWcoXCJsZW5ndGggJW9cIiwgbGVuZ3RoKTtcblxuICAgICAgY29uc3QgYmFzZVNpemUgPSB1dGlscy5zdG9yYWdlU2l6ZSh1dGlscy5iYXNlRGVmaW5pdGlvbihkZWZpbml0aW9uKSk7XG4gICAgICBjb25zdCBwZXJXb3JkID0gTWF0aC5mbG9vcihXT1JEX1NJWkUgLyBiYXNlU2l6ZSk7XG4gICAgICBkZWJ1ZyhcImJhc2VTaXplICVvXCIsIGJhc2VTaXplKTtcbiAgICAgIGRlYnVnKFwicGVyV29yZCAlZFwiLCBwZXJXb3JkKTtcblxuICAgICAgY29uc3Qgb2Zmc2V0ID0gKGkpID0+IHtcbiAgICAgICAgaWYgKHBlcldvcmQgPT0gMSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoaSAqIGJhc2VTaXplIC8gV09SRF9TSVpFKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSAoaSkgPT4ge1xuICAgICAgICBpZiAocGVyV29yZCA9PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFdPUkRfU0laRSAtIGJhc2VTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwZXJXb3JkIC0gaSAlIHBlcldvcmQgLSAxO1xuICAgICAgICByZXR1cm4gcG9zaXRpb24gKiBiYXNlU2l6ZTtcbiAgICAgIH1cblxuICAgICAgZGVidWcoXCJwb2ludGVyOiAlb1wiLCBwb2ludGVyKTtcbiAgICAgIHJldHVybiBbLi4uQXJyYXkobGVuZ3RoKS5rZXlzKCldXG4gICAgICAgIC5tYXAoIChpKSA9PiB7XG4gICAgICAgICAgbGV0IGNoaWxkRnJvbSA9IHBvaW50ZXIuc3RvcmFnZS5mcm9tLm9mZnNldCAhPSB1bmRlZmluZWQgP1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzbG90OiBbXCIweFwiICsgdXRpbHMudG9CaWdOdW1iZXIoXG4gICAgICAgICAgICAgICAgdXRpbHMua2VjY2FrMjU2KC4uLnBvaW50ZXIuc3RvcmFnZS5mcm9tLnNsb3QpXG4gICAgICAgICAgICAgICkucGx1cyhwb2ludGVyLnN0b3JhZ2UuZnJvbS5vZmZzZXQpLnRvU3RyaW5nKDE2KV0sXG4gICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0KGkpLFxuICAgICAgICAgICAgICBpbmRleDogaW5kZXgoaSlcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHNsb3Q6IFtwb2ludGVyLnN0b3JhZ2UuZnJvbS5zbG90XSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQoaSksXG4gICAgICAgICAgICAgIGluZGV4OiBpbmRleChpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gY2hpbGRGcm9tO1xuICAgICAgICB9KVxuICAgICAgICAubWFwKCAoY2hpbGRGcm9tLCBpZHgpID0+IHtcbiAgICAgICAgICBkZWJ1ZyhcImNoaWxkRnJvbSAlZCwgJW9cIiwgaWR4LCBjaGlsZEZyb20pO1xuICAgICAgICAgIHJldHVybiBkZWNvZGUodXRpbHMuYmFzZURlZmluaXRpb24oZGVmaW5pdGlvbiksIHsgc3RvcmFnZToge1xuICAgICAgICAgICAgZnJvbTogY2hpbGRGcm9tLFxuICAgICAgICAgICAgbGVuZ3RoOiBiYXNlU2l6ZVxuICAgICAgICAgIH19LCBzdGF0ZSwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuXG4gICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgZGF0YSA9IHJlYWQocG9pbnRlciwgc3RhdGUpO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YVtXT1JEX1NJWkUgLSAxXSAlIDIgPT0gMCkge1xuICAgICAgICAvLyBzdHJpbmcgbGl2ZXMgaW4gd29yZCwgbGVuZ3RoIGlzIGxhc3QgYnl0ZSAvIDJcbiAgICAgICAgbGVuZ3RoID0gZGF0YVtXT1JEX1NJWkUgLSAxXSAvIDI7XG4gICAgICAgIGRlYnVnKFwiaW4td29yZDsgbGVuZ3RoICVvXCIsIGxlbmd0aCk7XG4gICAgICAgIGlmIChsZW5ndGggPT0gMCkge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlY29kZVZhbHVlKGRlZmluaXRpb24sIHsgc3RvcmFnZToge1xuICAgICAgICAgIGZyb206IHsgc2xvdDogcG9pbnRlci5zdG9yYWdlLmZyb20uc2xvdCwgaW5kZXg6IDAgfSxcbiAgICAgICAgICB0bzogeyBzbG90OiBwb2ludGVyLnN0b3JhZ2UuZnJvbS5zbG90LCBpbmRleDogbGVuZ3RoIC0gMX1cbiAgICAgICAgfX0sIHN0YXRlLCAuLi5hcmdzKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuZ3RoID0gdXRpbHMudG9CaWdOdW1iZXIoZGF0YSkubWludXMoMSkuZGl2KDIpLnRvTnVtYmVyKCk7XG4gICAgICAgIGRlYnVnKFwibmV3LXdvcmQsIGxlbmd0aCAlb1wiLCBsZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiBkZWNvZGVWYWx1ZShkZWZpbml0aW9uLCB7IHN0b3JhZ2U6IHtcbiAgICAgICAgICBmcm9tOiB7IHNsb3Q6IFtwb2ludGVyLnN0b3JhZ2UuZnJvbS5zbG90XSwgaW5kZXg6IDAgfSxcbiAgICAgICAgICBsZW5ndGhcbiAgICAgICAgfX0sIHN0YXRlLCAuLi5hcmdzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgXCJzdHJ1Y3RcIjpcbiAgICAgIGxldCBbcmVmc10gPSBhcmdzO1xuXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sIC4uLk9iamVjdC5lbnRyaWVzKHBvaW50ZXIuc3RvcmFnZS5jaGlsZHJlbilcbiAgICAgICAgICAubWFwKCAoW2lkLCBjaGlsZFBvaW50ZXJdKSA9PiAoe1xuICAgICAgICAgICAgW2NoaWxkUG9pbnRlci5uYW1lXTogZGVjb2RlKFxuICAgICAgICAgICAgICByZWZzW2lkXS5kZWZpbml0aW9uLCB7IHN0b3JhZ2U6IGNoaWxkUG9pbnRlciB9LCBzdGF0ZSwgLi4uYXJnc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pKVxuICAgICAgKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBkZWJ1ZyhcIlVua25vd24gc3RvcmFnZSByZWZlcmVuY2UgdHlwZTogJXNcIiwgdXRpbHMudHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbikpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVjb2RlKGRlZmluaXRpb24sIC4uLmFyZ3MpIHtcbiAgaWYgKCF1dGlscy5pc1JlZmVyZW5jZShkZWZpbml0aW9uKSkge1xuICAgIHJldHVybiBkZWNvZGVWYWx1ZShkZWZpbml0aW9uLCAuLi5hcmdzKTtcbiAgfVxuXG4gIHN3aXRjaCAodXRpbHMucmVmZXJlbmNlVHlwZShkZWZpbml0aW9uKSkge1xuICAgIGNhc2UgXCJtZW1vcnlcIjpcbiAgICAgIHJldHVybiBkZWNvZGVNZW1vcnlSZWZlcmVuY2UoZGVmaW5pdGlvbiwgLi4uYXJncyk7XG4gICAgY2FzZSBcInN0b3JhZ2VcIjpcbiAgICAgIHJldHVybiBkZWNvZGVTdG9yYWdlUmVmZXJlbmNlKGRlZmluaXRpb24sIC4uLmFyZ3MpO1xuICAgIGRlZmF1bHQ6XG4gICAgICBkZWJ1ZyhcIlVua25vd24gcmVmZXJlbmNlIGNhdGVnb3J5OiAlc1wiLCB1dGlscy50eXBlSWRlbnRpZmllcihkZWZpbml0aW9uKSk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvZGVjb2RlL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmRhdGE6ZGVjb2RlOm1lbW9yeVwiKTtcblxuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcImJpZ251bWJlci5qc1wiO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgV09SRF9TSVpFIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuLyoqXG4gKiByZWFkIHdvcmQgZnJvbSBtZW1vcnlcbiAqXG4gKiByZXF1aXJlcyBgYnl0ZWAgdG8gYmUgYSBtdWx0aXBsZSBvZiBXT1JEX1NJWkUgKDMyKVxuICpcbiAqIEBwYXJhbSBtZW1vcnkgLSBVaW50OEFycmF5XG4gKiBAcmV0dXJuIHtCaWdOdW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkKG1lbW9yeSwgYnl0ZSkge1xuICByZXR1cm4gcmVhZEJ5dGVzKG1lbW9yeSwgYnl0ZSwgV09SRF9TSVpFKTtcbn1cblxuLyoqXG4gKiByZWFkIDxieXRlcz4gYW1vdW50IG9mIGJ5dGVzIGZyb20gbWVtb3J5LCBzdGFydGluZyBhdCBieXRlIDxzdGFydD5cbiAqXG4gKiBAcGFyYW0gbWVtb3J5IC0gVWludDhBcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZEJ5dGVzKG1lbW9yeSwgYnl0ZSwgbGVuZ3RoKSB7XG4gIGJ5dGUgPSB1dGlscy50b0JpZ051bWJlcihieXRlKTtcbiAgbGVuZ3RoID0gdXRpbHMudG9CaWdOdW1iZXIobGVuZ3RoKTtcblxuICBpZiAoYnl0ZS50b051bWJlcigpID49IG1lbW9yeS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoID8gbGVuZ3RoLnRvTnVtYmVyKCkgOiAwKTtcbiAgfVxuXG4gIGlmIChsZW5ndGggPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG1lbW9yeS5idWZmZXIsIGJ5dGUudG9OdW1iZXIoKSk7XG4gIH1cblxuICAvLyBncmFiIGBsZW5ndGhgIGJ5dGVzIG5vIG1hdHRlciB3aGF0LCBoZXJlIGZpbGwgdGhpcyBhcnJheVxuICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgudG9OdW1iZXIoKSk7XG5cbiAgLy8gaWYgd2UncmUgcmVhZGluZyBwYXN0IHRoZSBlbmQgb2YgbWVtb3J5LCB0cnVuY2F0ZSB0aGUgbGVuZ3RoIHRvIHJlYWRcbiAgbGV0IGV4Y2VzcyA9IGJ5dGUucGx1cyhsZW5ndGgpLm1pbnVzKG1lbW9yeS5sZW5ndGgpLnRvTnVtYmVyKCk7XG4gIGlmIChleGNlc3MgPiAwKSB7XG4gICAgbGVuZ3RoID0gbmV3IEJpZ051bWJlcihtZW1vcnkubGVuZ3RoKS5taW51cyhieXRlKTtcbiAgfVxuXG4gIGxldCBleGlzdGluZyA9IG5ldyBVaW50OEFycmF5KG1lbW9yeS5idWZmZXIsIGJ5dGUudG9OdW1iZXIoKSwgbGVuZ3RoLnRvTnVtYmVyKCkpO1xuXG4gIGJ5dGVzLnNldChleGlzdGluZyk7XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG4vKipcbiAqIFNwbGl0IG1lbW9yeSBpbnRvIGNodW5rc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2h1bmsobWVtb3J5LCBzaXplID0gV09SRF9TSVpFKSB7XG4gIGxldCBjaHVua3MgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lbW9yeS5sZW5ndGg7IGkgKz0gc2l6ZSkge1xuICAgIGxldCBjaHVuayA9IHJlYWRCeXRlcyhtZW1vcnksIGksIHNpemUpO1xuICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgfVxuXG4gIHJldHVybiBjaHVua3M7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvZGVjb2RlL21lbW9yeS5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpkYXRhOmRlY29kZTpzdG9yYWdlXCIpO1xuXG5pbXBvcnQgeyBXT1JEX1NJWkUgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vdXRpbHNcIjtcblxuXG4vKipcbiAqIHJlYWQgc2xvdCBmcm9tIHN0b3JhZ2VcbiAqXG4gKiBAcGFyYW0gc2xvdCAtIGJpZyBudW1iZXIgb3IgYXJyYXkgb2YgcmVndWxhciBudW1iZXJzXG4gKiBAcGFyYW0gb2Zmc2V0IC0gZm9yIGFycmF5LCBvZmZzZXQgZnJvbSB0aGUga2VjY2FrIGRldGVybWluZWQgbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWQoc3RvcmFnZSwgc2xvdCwgb2Zmc2V0ID0gMCkge1xuICBpZiAoc2xvdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgc2xvdCA9IHV0aWxzLmtlY2NhazI1NiguLi5zbG90Lm1hcCh1dGlscy50b0JpZ051bWJlcikpO1xuICB9XG5cbiAgc2xvdCA9IHV0aWxzLnRvQmlnTnVtYmVyKHNsb3QpLnBsdXMob2Zmc2V0KTtcblxuICBkZWJ1ZyhcInJlYWRpbmcgc2xvdDogJW9cIiwgdXRpbHMudG9IZXhTdHJpbmcoc2xvdCkpO1xuXG4gIGxldCB3b3JkID0gc3RvcmFnZVt1dGlscy50b0hleFN0cmluZyhzbG90LCBXT1JEX1NJWkUpXSB8fFxuICAgIG5ldyBVaW50OEFycmF5KFdPUkRfU0laRSk7XG5cbiAgZGVidWcoXCJ3b3JkICVvXCIsIHdvcmQpO1xuICByZXR1cm4gd29yZFxufVxuXG4vKipcbiAqIHJlYWQgYWxsIGJ5dGVzIGluIHNvbWUgcmFuZ2UuXG4gKlxuICogcGFyYW1ldGVycyBgZnJvbWAgYW5kIGB0b2AgYXJlIG9iamVjdHMgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBzbG90IC0gKHJlcXVpcmVkKSBlaXRoZXIgYSBiaWdudW1iZXIgb3IgYSBcInBhdGhcIiBhcnJheSBvZiBpbnRlZ2VyIG9mZnNldHNcbiAqXG4gKiAgICAgcGF0aCBhcnJheSB2YWx1ZXMgZ2V0IGNvbnZlcnRlZCBpbnRvIGtlY2NhazI1NiBoYXNoIGFzIHBlciBzb2xpZGl0eVxuICogICAgIHN0b3JhZ2UgYWxsb2NhdGlvbiBtZXRob2RcbiAqXG4gKiAgICAgcmVmOiBodHRwczovL3NvbGlkaXR5LnJlYWR0aGVkb2NzLmlvL2VuL3YwLjQuMjMvbWlzY2VsbGFuZW91cy5odG1sI2xheW91dC1vZi1zdGF0ZS12YXJpYWJsZXMtaW4tc3RvcmFnZVxuICogICAgIChzZWFyY2ggXCJjb25jYXRlbmF0aW9uXCIpXG4gKlxuICogIG9mZnNldCAtIChkZWZhdWx0OiAwKSBzbG90IG9mZnNldFxuICpcbiAqICBpbmRleCAtIChkZWZhdWx0OiAwKSBieXRlIGluZGV4IGluIHdvcmRcbiAqXG4gKiBAcGFyYW0gZnJvbSAtIGxvY2F0aW9uIChzZWUgXilcbiAqIEBwYXJhbSB0byAtIGxvY2F0aW9uIChzZWUgXikuIGluY2x1c2l2ZS5cbiAqIEBwYXJhbSBsZW5ndGggLSBpbnN0ZWFkIG9mIGB0b2AsIG51bWJlciBvZiBieXRlcyBhZnRlciBgZnJvbWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRSYW5nZShzdG9yYWdlLCB7ZnJvbSwgdG8sIGxlbmd0aH0pIHtcbiAgaWYgKCFsZW5ndGggJiYgIXRvIHx8IGxlbmd0aCAmJiB0bykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm11c3Qgc3BlY2lmeSBleGFjdGx5IG9uZSBgdG9gfGBsZW5ndGhgXCIpO1xuICB9XG5cbiAgZnJvbSA9IHtcbiAgICAuLi5mcm9tLFxuICAgIG9mZnNldDogZnJvbS5vZmZzZXQgfHwgMFxuICB9O1xuXG4gIGlmIChsZW5ndGgpIHtcbiAgICB0byA9IHtcbiAgICAgIHNsb3Q6IGZyb20uc2xvdCxcbiAgICAgIG9mZnNldDogZnJvbS5vZmZzZXQgKyBNYXRoLmZsb29yKChmcm9tLmluZGV4ICsgbGVuZ3RoIC0gMSkgLyBXT1JEX1NJWkUpLFxuICAgICAgaW5kZXg6IChmcm9tLmluZGV4ICsgbGVuZ3RoIC0gMSkgJSBXT1JEX1NJWkVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRvID0ge1xuICAgICAgLi4udG8sXG4gICAgICBvZmZzZXQ6IHRvLm9mZnNldCB8fCAwXG4gICAgfVxuICB9XG5cbiAgZGVidWcoXCJyZWFkUmFuZ2UgJW9cIiwge2Zyb20sdG99KTtcblxuICBjb25zdCB0b3RhbFdvcmRzID0gdG8ub2Zmc2V0IC0gZnJvbS5vZmZzZXQgKyAxO1xuICBkZWJ1ZyhcInRvdGFsV29yZHMgJW9cIiwgdG90YWxXb3Jkcyk7XG5cbiAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0b3RhbFdvcmRzICogV09SRF9TSVpFKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsV29yZHM7IGkrKykge1xuICAgIGxldCBvZmZzZXQgPSBpICsgZnJvbS5vZmZzZXQ7XG4gICAgZGF0YS5zZXQocmVhZChzdG9yYWdlLCBmcm9tLnNsb3QsIG9mZnNldCksIGkgKiBXT1JEX1NJWkUpO1xuICB9XG4gIGRlYnVnKFwid29yZHMgJW9cIiwgZGF0YSk7XG5cbiAgZGF0YSA9IGRhdGEuc2xpY2UoZnJvbS5pbmRleCwgKHRvdGFsV29yZHMgLSAxKSAqIFdPUkRfU0laRSArIHRvLmluZGV4ICsgMSk7XG5cbiAgZGVidWcoXCJkYXRhOiAlb1wiLCBkYXRhKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kYXRhL2RlY29kZS9zdG9yYWdlLmpzIiwiZXhwb3J0IGNvbnN0IFZJU0lUID0gXCJWSVNJVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0KHNvdXJjZUlkLCBhc3QpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBWSVNJVCxcbiAgICBzb3VyY2VJZCwgYXN0XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IERPTkVfVklTSVRJTkcgPSBcIkRPTkVfVklTSVRJTkdcIjtcbmV4cG9ydCBmdW5jdGlvbiBkb25lVmlzaXRpbmcoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogRE9ORV9WSVNJVElOR1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9hc3QvYWN0aW9ucy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpjb250cm9sbGVyOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBwdXQsIGNhbGwsIHJhY2UsIHRha2UsIHNlbGVjdCB9IGZyb20gJ3JlZHV4LXNhZ2EvZWZmZWN0cyc7XG5cbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9zYWdhc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5cbmltcG9ydCBjb250cm9sbGVyIGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuY29uc3QgQ09OVFJPTF9TQUdBUyA9IHtcbiAgW2FjdGlvbnMuQURWQU5DRV06IGFkdmFuY2UsXG4gIFthY3Rpb25zLlNURVBfTkVYVF06IHN0ZXBOZXh0LFxuICBbYWN0aW9ucy5TVEVQX09WRVJdOiBzdGVwT3ZlcixcbiAgW2FjdGlvbnMuU1RFUF9JTlRPXTogc3RlcEludG8sXG4gIFthY3Rpb25zLlNURVBfT1VUXTogc3RlcE91dCxcbiAgW2FjdGlvbnMuQ09OVElOVUVfVU5USUxdOiBjb250aW51ZVVudGlsXG59O1xuXG4vKiogQVNUIG5vZGUgdHlwZXMgdGhhdCBhcmUgc2tpcHBlZCB0byBmaWx0ZXIgb3V0IHNvbWUgbm9pc2UgKi9cbmNvbnN0IFNLSVBQRURfVFlQRVMgPSBuZXcgU2V0KFtcbiAgXCJDb250cmFjdERlZmluaXRpb25cIixcbiAgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG5dKTtcblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGRlYnVnKFwid2FpdGluZyBmb3IgY29udHJvbCBhY3Rpb25cIik7XG4gICAgbGV0IGFjdGlvbiA9IHlpZWxkIHRha2UoT2JqZWN0LmtleXMoQ09OVFJPTF9TQUdBUykpO1xuICAgIGRlYnVnKFwiZ290IGNvbnRyb2wgYWN0aW9uXCIpO1xuICAgIGxldCBzYWdhID0gQ09OVFJPTF9TQUdBU1thY3Rpb24udHlwZV07XG5cbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5iZWdpblN0ZXAoYWN0aW9uLnR5cGUpKTtcblxuICAgIHlpZWxkIHJhY2Uoe1xuICAgICAgZXhlYzogY2FsbChzYWdhLCBhY3Rpb24pLFxuICAgICAgaW50ZXJydXB0OiB0YWtlKGFjdGlvbnMuSU5URVJSVVBUKVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWZpeE5hbWUoXCJjb250cm9sbGVyXCIsIHNhZ2EpO1xuXG4vKipcbiAqIEFkdmFuY2UgdGhlIHN0YXRlIGJ5IG9uZSBpbnN0cnVjdGlvblxuICovXG5mdW5jdGlvbiogYWR2YW5jZSgpIHtcbiAgLy8gc2VuZCBhY3Rpb24gdG8gYWR2YW5jZSB0cmFjZVxuICB5aWVsZCAqdHJhY2UuYWR2YW5jZSgpO1xufVxuXG4vKipcbiAqIHN0ZXBOZXh0IC0gc3RlcCB0byB0aGUgbmV4dCBsb2dpY2FsIGNvZGUgc2VnbWVudFxuICpcbiAqIE5vdGU6IEl0IG1pZ2h0IHRha2UgbXVsdGlwbGUgaW5zdHJ1Y3Rpb25zIHRvIGV4cHJlc3MgdGhlIHNhbWUgc2VjdGlvbiBvZiBjb2RlLlxuICogXCJTdGVwcGluZ1wiLCB0aGVuLCBpcyBzdGVwcGluZyB0byB0aGUgbmV4dCBsb2dpY2FsIGl0ZW0sIG5vdCBzdGVwcGluZyB0byB0aGUgbmV4dFxuICogaW5zdHJ1Y3Rpb24uIFNlZSBhZHZhbmNlKCkgaWYgeW91J2QgbGlrZSB0byBhZHZhbmNlIGJ5IG9uZSBpbnN0cnVjdGlvbi5cbiAqL1xuZnVuY3Rpb24qIHN0ZXBOZXh0ICgpIHtcbiAgY29uc3Qgc3RhcnRpbmdSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuXG4gIHZhciB1cGNvbWluZztcblxuICBkbyB7XG4gICAgLy8gYWR2YW5jZSBhdCBsZWFzdCBvbmNlIHN0ZXBcbiAgICB5aWVsZCogYWR2YW5jZSgpO1xuXG4gICAgLy8gYW5kIGNoZWNrIHRoZSBuZXh0IHNvdXJjZSByYW5nZVxuICAgIHVwY29taW5nID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbik7XG5cbiAgICAvLyBpZiB0aGUgbmV4dCBzdGVwJ3Mgc291cmNlIHJhbmdlIGlzIHN0aWxsIHRoZSBzYW1lLCBrZWVwIGdvaW5nXG4gIH0gd2hpbGUgKFxuICAgICF1cGNvbWluZy5ub2RlIHx8XG4gICAgU0tJUFBFRF9UWVBFUy5oYXModXBjb21pbmcubm9kZS5ub2RlVHlwZSkgfHxcblxuICAgIHVwY29taW5nLnNvdXJjZVJhbmdlLnN0YXJ0ID09IHN0YXJ0aW5nUmFuZ2Uuc3RhcnQgJiZcbiAgICB1cGNvbWluZy5zb3VyY2VSYW5nZS5sZW5ndGggPT0gc3RhcnRpbmdSYW5nZS5sZW5ndGhcbiAgKTtcbn1cblxuLyoqXG4gKiBzdGVwSW50byAtIHN0ZXAgaW50byB0aGUgY3VycmVudCBmdW5jdGlvblxuICpcbiAqIENvbmNlcHR1YWxseSB0aGlzIGlzIGVhc3ksIGJ1dCBmcm9tIGEgcHJvZ3JhbW1pbmcgc3RhbmRwb2ludCBpdCdzIGhhcmQuXG4gKiBDb2RlIGxpa2UgYGdldEJhbGFuY2UobXNnLnNlbmRlcilgIG1pZ2h0IGJlIGhpZ2hsaWdodGVkLCBidXQgdGhlcmUgY291bGRcbiAqIGJlIGEgbnVtYmVyIG9mIGRpZmZlcmVudCBpbnRlcm1lZGlhdGUgc3RlcHMgKGxpa2UgZXZhbHVhdGluZyBgbXNnLnNlbmRlcmApXG4gKiBiZWZvcmUgYGdldEJhbGFuY2VgIGlzIHN0ZXBwZWQgaW50by4gVGhpcyBmdW5jdGlvbiB3aWxsIHN0ZXAgaW50byB0aGUgZmlyc3RcbiAqIGZ1bmN0aW9uIGF2YWlsYWJsZSAod2hlcmUgaW5zdHJ1Y3Rpb24uanVtcCA9PSBcImlcIiksIGlnbm9yaW5nIGFueSBpbnRlcm1lZGlhdGVcbiAqIHN0ZXBzIHRoYXQgZmFsbCB3aXRoaW4gdGhlIHNhbWUgY29kZSByYW5nZS4gSWYgdGhlcmUncyBhIHN0ZXAgZW5jb3VudGVyZWRcbiAqIHRoYXQgZXhpc3RzIG91dHNpZGUgb2YgdGhlIHJhbmdlLCB0aGVuIHN0ZXBJbnRvIHdpbGwgb25seSBleGVjdXRlIHVudGlsIHRoYXRcbiAqIHN0ZXAuXG4gKi9cbmZ1bmN0aW9uKiBzdGVwSW50byAoKSB7XG4gIGlmICh5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LndpbGxKdW1wKSkge1xuICAgIHlpZWxkKiBzdGVwTmV4dCgpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uaXNNdWx0aWxpbmUpKSB7XG4gICAgeWllbGQqIHN0ZXBPdmVyKCk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGFydGluZ0RlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgY29uc3Qgc3RhcnRpbmdSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuICB2YXIgY3VycmVudERlcHRoO1xuICB2YXIgY3VycmVudFJhbmdlO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIGN1cnJlbnREZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gICAgY3VycmVudFJhbmdlID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5zb3VyY2VSYW5nZSk7XG5cbiAgfSB3aGlsZSAoXG4gICAgLy8gdGhlIGZ1bmN0aW9uIHN0YWNrIGhhcyBub3QgaW5jcmVhc2VkLFxuICAgIGN1cnJlbnREZXB0aCA8PSBzdGFydGluZ0RlcHRoICYmXG5cbiAgICAvLyB0aGUgY3VycmVudCBzb3VyY2UgcmFuZ2UgYmVnaW5zIG9uIG9yIGFmdGVyIHRoZSBzdGFydGluZyByYW5nZVxuICAgIGN1cnJlbnRSYW5nZS5zdGFydCA+PSBzdGFydGluZ1JhbmdlLnN0YXJ0ICYmXG5cbiAgICAvLyBhbmQgdGhlIGN1cnJlbnQgcmFuZ2UgZW5kcyBvbiBvciBiZWZvcmUgdGhlIHN0YXJ0aW5nIHJhbmdlIGVuZHNcbiAgICAoY3VycmVudFJhbmdlLnN0YXJ0ICsgY3VycmVudFJhbmdlLmxlbmd0aCkgPD1cbiAgICAgIChzdGFydGluZ1JhbmdlLnN0YXJ0ICsgc3RhcnRpbmdSYW5nZS5sZW5ndGgpXG4gICk7XG59XG5cbi8qKlxuICogU3RlcCBvdXQgb2YgdGhlIGN1cnJlbnQgZnVuY3Rpb25cbiAqXG4gKiBUaGlzIHdpbGwgcnVuIHVudGlsIHRoZSBkZWJ1Z2dlciBlbmNvdW50ZXJzIGEgZGVjcmVhc2UgaW4gZnVuY3Rpb24gZGVwdGguXG4gKi9cbmZ1bmN0aW9uKiBzdGVwT3V0ICgpIHtcbiAgaWYgKHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uaXNNdWx0aWxpbmUpKSB7XG4gICAgeWllbGQgKnN0ZXBPdmVyKCk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGFydGluZ0RlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgdmFyIGN1cnJlbnREZXB0aDtcblxuICBkbyB7XG4gICAgeWllbGQqIHN0ZXBOZXh0KCk7XG5cbiAgICBjdXJyZW50RGVwdGggPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpO1xuXG4gIH0gd2hpbGUoY3VycmVudERlcHRoID49IHN0YXJ0aW5nRGVwdGgpO1xufVxuXG4vKipcbiAqIHN0ZXBPdmVyIC0gc3RlcCBvdmVyIHRoZSBjdXJyZW50IGxpbmVcbiAqXG4gKiBTdGVwIG92ZXIgdGhlIGN1cnJlbnQgbGluZS4gVGhpcyB3aWxsIHN0ZXAgdG8gdGhlIG5leHQgaW5zdHJ1Y3Rpb24gdGhhdFxuICogZXhpc3RzIG9uIGEgZGlmZmVyZW50IGxpbmUgb2YgY29kZSB3aXRoaW4gdGhlIHNhbWUgZnVuY3Rpb24gZGVwdGguXG4gKi9cbmZ1bmN0aW9uKiBzdGVwT3ZlciAoKSB7XG4gIGNvbnN0IHN0YXJ0aW5nRGVwdGggPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpO1xuICBjb25zdCBzdGFydGluZ1JhbmdlID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5zb3VyY2VSYW5nZSk7XG4gIHZhciBjdXJyZW50RGVwdGg7XG4gIHZhciBjdXJyZW50UmFuZ2U7XG5cbiAgZG8ge1xuICAgIHlpZWxkKiBzdGVwTmV4dCgpO1xuXG4gICAgY3VycmVudERlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgICBjdXJyZW50UmFuZ2UgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLnNvdXJjZVJhbmdlKTtcblxuICB9IHdoaWxlIChcbiAgICAvLyBrZWVwIHN0ZXBwaW5nIHByb3ZpZGVkOlxuICAgIC8vXG4gICAgLy8gd2UgaGF2ZW4ndCBqdW1wZWQgb3V0XG4gICAgIShjdXJyZW50RGVwdGggPCBzdGFydGluZ0RlcHRoKSAmJlxuXG4gICAgLy8gZWl0aGVyOiBmdW5jdGlvbiBkZXB0aCBpcyBncmVhdGVyIHRoYW4gc3RhcnRpbmcgKGlnbm9yZSBmdW5jdGlvbiBjYWxscylcbiAgICAvLyBvciwgaWYgd2UncmUgYXQgdGhlIHNhbWUgZGVwdGgsIGtlZXAgc3RlcHBpbmcgdW50aWwgd2UncmUgb24gYSBuZXdcbiAgICAvLyBsaW5lLlxuICAgIChjdXJyZW50RGVwdGggPiBzdGFydGluZ0RlcHRoIHx8XG4gICAgICBjdXJyZW50UmFuZ2UubGluZXMuc3RhcnQubGluZSA9PSBzdGFydGluZ1JhbmdlLmxpbmVzLnN0YXJ0LmxpbmUpXG4gIClcbn1cblxuLyoqXG4gKiBjb250aW51ZVVudGlsIC0gc3RlcCB0aHJvdWdoIGV4ZWN1dGlvbiB1bnRpbCBhIGJyZWFrcG9pbnRcbiAqXG4gKiBAcGFyYW0gYnJlYWtwb2ludHMgLSBhcnJheSBvZiBicmVha3BvaW50cyAoeyAuLi5jYWxsLCBsaW5lIH0pXG4gKi9cbmZ1bmN0aW9uICpjb250aW51ZVVudGlsICh7YnJlYWtwb2ludHN9KSB7XG4gIHZhciBjdXJyZW50Q2FsbDtcbiAgdmFyIGN1cnJlbnRMb2NhdGlvbjtcblxuICBsZXQgYnJlYWtwb2ludEhpdCA9IGZhbHNlO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIGN1cnJlbnRDYWxsID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5leGVjdXRpb25Db250ZXh0KTtcbiAgICBjdXJyZW50TG9jYXRpb24gPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uKTtcblxuICAgIGJyZWFrcG9pbnRIaXQgPSBicmVha3BvaW50c1xuICAgICAgLmZpbHRlciggKHthZGRyZXNzLCBiaW5hcnksIGxpbmUsIG5vZGV9KSA9PlxuICAgICAgICAoXG4gICAgICAgICAgYWRkcmVzcyA9PSBjdXJyZW50Q2FsbC5hZGRyZXNzIHx8XG4gICAgICAgICAgYmluYXJ5ID09IGN1cnJlbnRDYWxsLmJpbmFyeVxuICAgICAgICApICYmIChcbiAgICAgICAgICBsaW5lID09IGN1cnJlbnRMb2NhdGlvbi5zb3VyY2VSYW5nZS5saW5lcy5zdGFydC5saW5lIHx8XG4gICAgICAgICAgbm9kZSA9PSBjdXJyZW50TG9jYXRpb24ubm9kZS5pZFxuICAgICAgICApXG4gICAgICApXG4gICAgICAubGVuZ3RoID4gMDtcblxuICB9IHdoaWxlICghYnJlYWtwb2ludEhpdCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2NvbnRyb2xsZXIvc2FnYXMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6Y29udHJvbGxlcjpzYWdhc1wiKTtcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuaW1wb3J0IGFzdCBmcm9tIFwibGliL2FzdC9zZWxlY3RvcnNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBpZGVudGl0eSA9ICh4KSA9PiB4XG5cbi8qKlxuICogY29udHJvbGxlclxuICovXG5jb25zdCBjb250cm9sbGVyID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcblxuICAvKipcbiAgICogY29udHJvbGxlci5jdXJyZW50XG4gICAqL1xuICBjdXJyZW50OiB7XG4gICAgLyoqXG4gICAgICogY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbkRlcHRoOiBjcmVhdGVMZWFmKFtzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQuZXhlY3V0aW9uQ29udGV4dFxuICAgICAqL1xuICAgIGV4ZWN1dGlvbkNvbnRleHQ6IGNyZWF0ZUxlYWYoW2V2bS5jdXJyZW50LmNhbGxdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQud2lsbEp1bXBcbiAgICAgKi9cbiAgICB3aWxsSnVtcDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0p1bXBdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb25cbiAgICAgKi9cbiAgICBsb2NhdGlvbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2VcbiAgICAgICAqL1xuICAgICAgc291cmNlUmFuZ2U6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQuc291cmNlUmFuZ2VdLCBpZGVudGl0eSksXG5cbiAgICAgIC8qKlxuICAgICAgICogY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLm5vZGVcbiAgICAgICAqL1xuICAgICAgbm9kZTogY3JlYXRlTGVhZihbYXN0LmN1cnJlbnQubm9kZV0sIGlkZW50aXR5KSxcblxuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uaXNNdWx0aWxpbmVcbiAgICAgICAqL1xuICAgICAgaXNNdWx0aWxpbmU6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQuaXNNdWx0aWxpbmVdLCBpZGVudGl0eSksXG4gICAgfVxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29udHJvbGxlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvY29udHJvbGxlci9zZWxlY3RvcnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6c29saWRpdHk6c2FnYXNcIik7XG5cbmltcG9ydCB7IGNhbGwsIHB1dCwgdGFrZSwgc2VsZWN0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuaW1wb3J0IHsgcHJlZml4TmFtZSB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5pbXBvcnQgeyBUSUNLIH0gZnJvbSBcImxpYi90cmFjZS9hY3Rpb25zXCI7XG5cbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiAqYWRkU291cmNlKHNvdXJjZSwgc291cmNlUGF0aCwgYXN0KSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmFkZFNvdXJjZShzb3VyY2UsIHNvdXJjZVBhdGgsIGFzdCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gKmFkZFNvdXJjZU1hcChiaW5hcnksIHNvdXJjZU1hcCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5hZGRTb3VyY2VNYXAoYmluYXJ5LCBzb3VyY2VNYXApKTtcbn1cblxuZnVuY3Rpb24qIGZ1bmN0aW9uRGVwdGhTYWdhICgpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB5aWVsZCB0YWtlKFRJQ0spO1xuICAgIGRlYnVnKFwiZ290IFRJQ0tcIik7XG4gICAgbGV0IGluc3RydWN0aW9uID0geWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb24pO1xuICAgIGRlYnVnKFwiaW5zdHJ1Y3Rpb246ICVvXCIsIGluc3RydWN0aW9uKTtcblxuICAgIGlmICh5aWVsZCBzZWxlY3Qoc29saWRpdHkuY3VycmVudC53aWxsSnVtcCkpIHtcbiAgICAgIGxldCBqdW1wRGlyZWN0aW9uID0geWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQuanVtcERpcmVjdGlvbik7XG5cblxuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuanVtcChqdW1wRGlyZWN0aW9uKSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSAoKSB7XG4gIHlpZWxkIGNhbGwoZnVuY3Rpb25EZXB0aFNhZ2EpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwic29saWRpdHlcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3NvbGlkaXR5L3NhZ2FzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmV2bTpzYWdhc1wiKTtcblxuaW1wb3J0IHsgY2FsbCwgcHV0LCB0YWtlLCBzZWxlY3QgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5pbXBvcnQgeyBwcmVmaXhOYW1lLCBrZWNjYWsyNTYgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0IHsgVElDSyB9IGZyb20gXCJsaWIvdHJhY2UvYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuLyoqXG4gKiBBZGRzIEVWTSBieXRlY29kZSBjb250ZXh0XG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBJRCAoMHgtcHJlZml4ZWQga2VjY2FrIG9mIGJpbmFyeSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uICphZGRDb250ZXh0KGNvbnRyYWN0TmFtZSwgYmluYXJ5KSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmFkZENvbnRleHQoY29udHJhY3ROYW1lLCBiaW5hcnkpKTtcblxuICByZXR1cm4ga2VjY2FrMjU2KGJpbmFyeSk7XG59XG5cbi8qKlxuICogQWRkcyBrbm93biBkZXBsb3llZCBpbnN0YW5jZSBvZiBiaW5hcnkgYXQgYWRkcmVzc1xuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gSUQgKDB4LXByZWZpeGVkIGtlY2NhayBvZiBiaW5hcnkpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAqYWRkSW5zdGFuY2UoYWRkcmVzcywgYmluYXJ5KSB7XG4gIGxldCBzZWFyY2ggPSB5aWVsZCBzZWxlY3QoZXZtLmluZm8uYmluYXJpZXMuc2VhcmNoKTtcbiAgbGV0IHsgY29udGV4dCB9ID0gc2VhcmNoKGJpbmFyeSk7XG5cbiAgeWllbGQgcHV0KGFjdGlvbnMuYWRkSW5zdGFuY2UoYWRkcmVzcywgY29udGV4dCwgYmluYXJ5KSk7XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogYmVnaW4oeyBhZGRyZXNzLCBiaW5hcnkgfSkge1xuICBpZiAoYWRkcmVzcykge1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmNhbGwoYWRkcmVzcykpO1xuICB9IGVsc2Uge1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmNyZWF0ZShiaW5hcnkpKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIGNhbGxzdGFja1NhZ2EgKCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHlpZWxkIHRha2UoVElDSyk7XG4gICAgZGVidWcoXCJnb3QgVElDS1wiKTtcblxuICAgIGlmICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5pc0NhbGwpKSB7XG4gICAgICBkZWJ1ZyhcImdvdCBjYWxsXCIpO1xuICAgICAgbGV0IGFkZHJlc3MgPSB5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5jYWxsQWRkcmVzcyk7XG5cbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmNhbGwoYWRkcmVzcykpO1xuXG4gICAgfSBlbHNlIGlmICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5pc0NyZWF0ZSkpIHtcbiAgICAgIGRlYnVnKFwiZ290IGNyZWF0ZVwiKTtcbiAgICAgIGxldCBiaW5hcnkgPSB5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5jcmVhdGVCaW5hcnkpO1xuXG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5jcmVhdGUoYmluYXJ5KSk7XG5cbiAgICB9IGVsc2UgaWYgKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzSGFsdGluZykpIHtcbiAgICAgIGRlYnVnKFwiZ290IHJldHVyblwiKTtcbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLnJldHVybkNhbGwoKSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSAoKSB7XG4gIHlpZWxkIGNhbGwoY2FsbHN0YWNrU2FnYSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWZpeE5hbWUoXCJldm1cIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2V2bS9zYWdhcy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjp3ZWIzOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBhbGwsIHRha2VFdmVyeSwgYXBwbHksIGZvcmssIGpvaW4sIHRha2UsIHB1dCwgc2VsZWN0IH0gZnJvbSAncmVkdXgtc2FnYS9lZmZlY3RzJztcbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuXG5pbXBvcnQgV2ViM0FkYXB0ZXIgZnJvbSBcIi4uL2FkYXB0ZXJcIjtcblxuZnVuY3Rpb24qIGZldGNoVHJhbnNhY3Rpb25JbmZvKGFkYXB0ZXIsIHt0eEhhc2h9KSB7XG4gIGRlYnVnKFwiaW5zcGVjdGluZyB0cmFuc2FjdGlvblwiKTtcbiAgdmFyIHRyYWNlO1xuICB0cnkge1xuICAgIHRyYWNlID0geWllbGQgYXBwbHkoYWRhcHRlciwgYWRhcHRlci5nZXRUcmFjZSwgW3R4SGFzaF0pO1xuICB9IGNhdGNoKGUpIHtcbiAgICBkZWJ1ZyhcInB1dHRpbmcgZXJyb3JcIik7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZXJyb3IoZSkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRlYnVnKFwiZ290IHRyYWNlXCIpO1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlVHJhY2UodHJhY2UpKTtcblxuICBsZXQgdHggPSB5aWVsZCBhcHBseShhZGFwdGVyLCBhZGFwdGVyLmdldFRyYW5zYWN0aW9uLCBbdHhIYXNoXSk7XG4gIGlmICh0eC50byAmJiB0eC50byAhPSBcIjB4MFwiKSB7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMucmVjZWl2ZUNhbGwoe2FkZHJlc3M6IHR4LnRvfSkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCByZWNlaXB0ID0geWllbGQgYXBwbHkoYWRhcHRlciwgYWRhcHRlci5nZXRSZWNlaXB0LCBbdHhIYXNoXSk7XG4gIGlmIChyZWNlaXB0LmNvbnRyYWN0QWRkcmVzcykge1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLnJlY2VpdmVDYWxsKHtiaW5hcnk6IHR4LmlucHV0fSkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBcIkNvdWxkIG5vdCBmaW5kIGNvbnRyYWN0IGFzc29jaWF0ZWQgd2l0aCB0cmFuc2FjdGlvbi4gXCIgK1xuICAgIFwiUGxlYXNlIG1ha2Ugc3VyZSB5b3UncmUgZGVidWdnaW5nIGEgdHJhbnNhY3Rpb24gdGhhdCBleGVjdXRlcyBhIFwiICtcbiAgICBcImNvbnRyYWN0IGZ1bmN0aW9uIG9yIGNyZWF0ZXMgYSBuZXcgY29udHJhY3QuXCJcbiAgKTtcbn1cblxuZnVuY3Rpb24qIGZldGNoQmluYXJ5KGFkYXB0ZXIsIHthZGRyZXNzfSkge1xuICBkZWJ1ZyhcImZldGNoaW5nIGJpbmFyeSBmb3IgJXNcIiwgYWRkcmVzcyk7XG4gIGxldCBiaW5hcnkgPSB5aWVsZCBhcHBseShhZGFwdGVyLCBhZGFwdGVyLmdldERlcGxveWVkQ29kZSwgW2FkZHJlc3NdKTtcblxuICBkZWJ1ZyhcInJlY2VpdmVkIGJpbmFyeSBmb3IgJXNcIiwgYWRkcmVzcyk7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnJlY2VpdmVCaW5hcnkoYWRkcmVzcywgYmluYXJ5KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAqaW5zcGVjdFRyYW5zYWN0aW9uKHR4SGFzaCwgcHJvdmlkZXIpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuaW5pdChwcm92aWRlcikpO1xuICB5aWVsZCBwdXQoYWN0aW9ucy5pbnNwZWN0KHR4SGFzaCkpO1xuXG4gIGxldCBhY3Rpb24gPSB5aWVsZCB0YWtlKCAoe3R5cGV9KSA9PlxuICAgIHR5cGUgPT0gYWN0aW9ucy5SRUNFSVZFX1RSQUNFIHx8IHR5cGUgPT0gYWN0aW9ucy5FUlJPUl9XRUIzXG4gICk7XG4gIGRlYnVnKFwiYWN0aW9uICVvXCIsIGFjdGlvbik7XG5cbiAgdmFyIHRyYWNlO1xuICBpZiAoYWN0aW9uLnR5cGUgPT0gYWN0aW9ucy5SRUNFSVZFX1RSQUNFKSB7XG4gICAgdHJhY2UgPSBhY3Rpb24udHJhY2U7XG4gICAgZGVidWcoXCJyZWNlaXZlZCB0cmFjZVwiKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBlcnJvcjogYWN0aW9uLmVycm9yIH07XG4gIH1cblxuICBsZXQge2FkZHJlc3MsIGJpbmFyeX0gPSB5aWVsZCB0YWtlKGFjdGlvbnMuUkVDRUlWRV9DQUxMKTtcbiAgZGVidWcoXCJyZWNlaXZlZCBjYWxsXCIpO1xuXG4gIHJldHVybiB7IHRyYWNlLCBhZGRyZXNzLCBiaW5hcnkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uICpvYnRhaW5CaW5hcmllcyhhZGRyZXNzZXMpIHtcbiAgbGV0IHRhc2tzID0geWllbGQgYWxsKFxuICAgIGFkZHJlc3Nlcy5tYXAoIChhZGRyZXNzKSA9PiBmb3JrKHJlY2VpdmVCaW5hcnksIGFkZHJlc3MpIClcbiAgKTtcblxuICBkZWJ1ZyhcInJlcXVlc3RpbmcgYmluYXJpZXNcIik7XG4gIHlpZWxkIGFsbChcbiAgICBhZGRyZXNzZXMubWFwKCAoYWRkcmVzcykgPT4gcHV0KGFjdGlvbnMuZmV0Y2hCaW5hcnkoYWRkcmVzcykpIClcbiAgKTtcblxuICBsZXQgYmluYXJpZXMgPSBbXTtcbiAgYmluYXJpZXMgPSB5aWVsZCBhbGwoXG4gICAgdGFza3MubWFwKHRhc2sgPT4gam9pbih0YXNrKSlcbiAgKTtcblxuICBkZWJ1ZyhcImJpbmFyaWVzICVvXCIsIGJpbmFyaWVzKTtcblxuICByZXR1cm4gYmluYXJpZXM7XG59XG5cbmZ1bmN0aW9uICpyZWNlaXZlQmluYXJ5KGFkZHJlc3MpIHtcbiAgbGV0IHtiaW5hcnl9ID0geWllbGQgdGFrZSgoYWN0aW9uKSA9PiAoXG4gICAgYWN0aW9uLnR5cGUgPT0gYWN0aW9ucy5SRUNFSVZFX0JJTkFSWSAmJlxuICAgIGFjdGlvbi5hZGRyZXNzID09IGFkZHJlc3NcbiAgKSk7XG4gIGRlYnVnKFwiZ290IGJpbmFyeSBmb3IgJXNcIiwgYWRkcmVzcyk7XG5cbiAgcmV0dXJuIGJpbmFyeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICAvLyB3YWl0IGZvciB3ZWIzIGluaXQgc2lnbmFsXG4gIGxldCB7cHJvdmlkZXJ9ID0geWllbGQgdGFrZShhY3Rpb25zLklOSVRfV0VCMyk7XG4gIGxldCBhZGFwdGVyID0gbmV3IFdlYjNBZGFwdGVyKHByb3ZpZGVyKTtcblxuICB5aWVsZCB0YWtlRXZlcnkoYWN0aW9ucy5JTlNQRUNULCBmZXRjaFRyYW5zYWN0aW9uSW5mbywgYWRhcHRlcik7XG4gIHlpZWxkIHRha2VFdmVyeShhY3Rpb25zLkZFVENIX0JJTkFSWSwgZmV0Y2hCaW5hcnksIGFkYXB0ZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwid2ViM1wiLCBzYWdhKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvd2ViMy9zYWdhcy9pbmRleC5qcyIsImV4cG9ydCBjb25zdCBJTklUX1dFQjMgPSBcIklOSVRfV0VCM1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGluaXQocHJvdmlkZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBJTklUX1dFQjMsXG4gICAgcHJvdmlkZXJcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgSU5TUEVDVCA9IFwiSU5TUEVDVF9UUkFOU0FDVElPTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3BlY3QodHhIYXNoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogSU5TUEVDVCxcbiAgICB0eEhhc2hcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgRkVUQ0hfQklOQVJZID0gXCJGRVRDSF9CSU5BUllcIjtcbmV4cG9ydCBmdW5jdGlvbiBmZXRjaEJpbmFyeShhZGRyZXNzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogRkVUQ0hfQklOQVJZLFxuICAgIGFkZHJlc3NcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFQ0VJVkVfQklOQVJZID0gXCJSRUNFSVZFX0JJTkFSWVwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlY2VpdmVCaW5hcnkoYWRkcmVzcywgYmluYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDRUlWRV9CSU5BUlksXG4gICAgYWRkcmVzcywgYmluYXJ5XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFJFQ0VJVkVfVFJBQ0UgPSBcIlJFQ0VJVkVfVFJBQ0VcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWNlaXZlVHJhY2UodHJhY2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUNFSVZFX1RSQUNFLFxuICAgIHRyYWNlXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFJFQ0VJVkVfQ0FMTCA9IFwiUkVDRUlWRV9DQUxMXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVjZWl2ZUNhbGwoe2FkZHJlc3MsIGJpbmFyeX0pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUNFSVZFX0NBTEwsXG4gICAgYWRkcmVzcywgYmluYXJ5XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEVSUk9SX1dFQjMgPSBcIkVSUk9SX1dFQjNcIjtcbmV4cG9ydCBmdW5jdGlvbiBlcnJvcihlcnJvcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEVSUk9SX1dFQjMsXG4gICAgZXJyb3JcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvd2ViMy9hY3Rpb25zL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuXG5pbXBvcnQgV2ViMyBmcm9tIFwid2ViM1wiO1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6d2ViMzphZGFwdGVyXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWIzQWRhcHRlciB7XG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgdGhpcy53ZWIzID0gbmV3IFdlYjMocHJvdmlkZXIpO1xuICB9XG5cbiAgYXN5bmMgZ2V0VHJhY2UodHhIYXNoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCAoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMud2ViMy5jdXJyZW50UHJvdmlkZXIuc2VuZEFzeW5jKHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgbWV0aG9kOiBcImRlYnVnX3RyYWNlVHJhbnNhY3Rpb25cIixcbiAgICAgICAgcGFyYW1zOiBbdHhIYXNoLCB7fV0sXG4gICAgICAgIGlkOiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgfSwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgZGVidWcoXCJyZXN1bHQ6ICVvXCIsIHJlc3VsdCk7XG4gICAgICAgIGFjY2VwdChyZXN1bHQucmVzdWx0LnN0cnVjdExvZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24odHhIYXNoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCAoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMud2ViMy5ldGguZ2V0VHJhbnNhY3Rpb24odHhIYXNoLCAoZXJyLCB0eCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG5cbiAgICAgICAgcmV0dXJuIGFjY2VwdCh0eCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBhc3luYyBnZXRSZWNlaXB0KHR4SGFzaCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSggKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLndlYjMuZXRoLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gsIChlcnIsIHJlY2VpcHQpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuXG4gICAgICAgIHJldHVybiBhY2NlcHQocmVjZWlwdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogZ2V0RGVwbG95ZWRDb2RlIC0gZ2V0IHRoZSBkZXBsb3llZCBjb2RlIGZvciBhbiBhZGRyZXNzIGZyb20gdGhlIGNsaWVudFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGFkZHJlc3NcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIGRlcGxveWVkQmluYXJ5XG4gICAqL1xuICBhc3luYyBnZXREZXBsb3llZENvZGUoYWRkcmVzcykge1xuICAgIGRlYnVnKFwiZ2V0dGluZyBkZXBsb3llZCBjb2RlIGZvciAlc1wiLCBhZGRyZXNzKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLndlYjMuZXRoLmdldENvZGUoYWRkcmVzcywgKGVyciwgZGVwbG95ZWRCaW5hcnkpID0+IHtcbiAgICAgICAgaWYgKGVycikgZGVidWcoXCJlcnJvcjogJW9cIiwgZXJyKTtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICBkZWJ1ZyhcImdvdCBkZXBsb3llZCBjb2RlIGZvciAlc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgYWNjZXB0KGRlcGxveWVkQmluYXJ5KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi93ZWIzL2FkYXB0ZXIuanMiLCJpbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0IGRhdGEgZnJvbSBcImxpYi9kYXRhL3JlZHVjZXJzXCI7XG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3JlZHVjZXJzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9yZWR1Y2Vyc1wiO1xuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2UvcmVkdWNlcnNcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5cbmV4cG9ydCBjb25zdCBXQUlUSU5HID0gXCJXQUlUSU5HXCI7XG5leHBvcnQgY29uc3QgQUNUSVZFID0gXCJBQ1RJVkVcIjtcbmV4cG9ydCBjb25zdCBFUlJPUiA9IFwiRVJST1JcIjtcbmV4cG9ydCBjb25zdCBGSU5JU0hFRCA9IFwiRklOSVNIRURcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNlc3Npb24oc3RhdGUgPSBXQUlUSU5HLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5SRUFEWTpcbiAgICAgIHJldHVybiBBQ1RJVkU7XG5cbiAgICBjYXNlIGFjdGlvbnMuRVJST1I6XG4gICAgICByZXR1cm4geyBlcnJvcjogYWN0aW9uLmVycm9yIH07XG5cbiAgICBjYXNlIGFjdGlvbnMuRklOSVNIOlxuICAgICAgcmV0dXJuIEZJTklTSEVEO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCByZWR1Y2VTdGF0ZSA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHNlc3Npb24sXG4gIGRhdGEsXG4gIGV2bSxcbiAgc29saWRpdHksXG4gIHRyYWNlLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZVN0YXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zZXNzaW9uL3JlZHVjZXJzLmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmRhdGE6cmVkdWNlcnNcIik7XG5cbmltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gXCJyZWR1eFwiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuY29uc3QgREVGQVVMVF9TQ09QRVMgPSB7XG4gIGJ5SWQ6IHt9XG59O1xuXG5mdW5jdGlvbiBzY29wZXMoc3RhdGUgPSBERUZBVUxUX1NDT1BFUywgYWN0aW9uKSB7XG4gIHZhciBjb250ZXh0O1xuICB2YXIgc2NvcGU7XG4gIHZhciB2YXJpYWJsZXM7XG5cbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5TQ09QRTpcbiAgICAgIHNjb3BlID0gc3RhdGUuYnlJZFthY3Rpb24uaWRdIHx8IHt9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBieUlkOiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlJZCxcblxuICAgICAgICAgIFthY3Rpb24uaWRdOiB7XG4gICAgICAgICAgICAuLi5zY29wZSxcblxuICAgICAgICAgICAgaWQ6IGFjdGlvbi5pZCxcbiAgICAgICAgICAgIHNvdXJjZUlkOiBhY3Rpb24uc291cmNlSWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogYWN0aW9uLnBhcmVudElkLFxuICAgICAgICAgICAgcG9pbnRlcjogYWN0aW9uLnBvaW50ZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGNhc2UgYWN0aW9ucy5ERUNMQVJFOlxuICAgICAgc2NvcGUgPSBzdGF0ZS5ieUlkW2FjdGlvbi5ub2RlLnNjb3BlXSB8fCB7fTtcbiAgICAgIHZhcmlhYmxlcyA9IHNjb3BlLnZhcmlhYmxlcyB8fCBbXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlJZDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5SWQsXG5cbiAgICAgICAgICBbYWN0aW9uLm5vZGUuc2NvcGVdOiB7XG4gICAgICAgICAgICAuLi5zY29wZSxcblxuICAgICAgICAgICAgdmFyaWFibGVzOiBbXG4gICAgICAgICAgICAgIC4uLnZhcmlhYmxlcyxcblxuICAgICAgICAgICAgICB7bmFtZTogYWN0aW9uLm5vZGUubmFtZSwgaWQ6IGFjdGlvbi5ub2RlLmlkfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBpbmZvID0gY29tYmluZVJlZHVjZXJzKHtcbiAgc2NvcGVzXG59KTtcblxuY29uc3QgREVGQVVMVF9BU1NJR05NRU5UUyA9IHtcbiAgYnlJZDoge31cbn07XG5cbmZ1bmN0aW9uIGFzc2lnbm1lbnRzKHN0YXRlID0gREVGQVVMVF9BU1NJR05NRU5UUywgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuQVNTSUdOOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlJZDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5SWQsXG5cbiAgICAgICAgICAuLi5PYmplY3QuYXNzaWduKHt9LFxuICAgICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMoYWN0aW9uLmFzc2lnbm1lbnRzKS5tYXAoXG4gICAgICAgICAgICAgIChbaWQsIHJlZl0pID0+ICh7XG4gICAgICAgICAgICAgICAgW2lkXToge1xuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUuYnlJZFtpZF0sXG4gICAgICAgICAgICAgICAgICByZWZcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufTtcblxuY29uc3QgcHJvYyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGFzc2lnbm1lbnRzXG59KTtcblxuY29uc3QgcmVkdWNlciA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGluZm8sXG4gIHByb2Ncbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZWR1Y2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kYXRhL3JlZHVjZXJzLmpzIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmNvbnN0IERFRkFVTFRfQ09OVEVYVFMgPSB7XG4gIGJ5Q29udGV4dDoge30sXG4gIGJ5QmluYXJ5OiB7fVxufTtcblxuZnVuY3Rpb24gY29udGV4dHMoc3RhdGUgPSBERUZBVUxUX0NPTlRFWFRTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIC8qXG4gICAgICogQWRkaW5nIGEgbmV3IGNvbnRleHRcbiAgICAgKi9cbiAgICBjYXNlIGFjdGlvbnMuQUREX0NPTlRFWFQ6XG4gICAgICBsZXQgeyBjb250cmFjdE5hbWUsIGJpbmFyeSB9ID0gYWN0aW9uO1xuXG4gICAgICBpZiAoc3RhdGUuYnlCaW5hcnlbYmluYXJ5XSkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIGxldCBjb250ZXh0ID0ga2VjY2FrMjU2KGJpbmFyeSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5Q29udGV4dDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5Q29udGV4dCxcblxuICAgICAgICAgIFtjb250ZXh0XTogeyBjb250ZXh0LCBiaW5hcnksIGNvbnRyYWN0TmFtZSB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnlCaW5hcnk6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUJpbmFyeSxcblxuICAgICAgICAgIFtiaW5hcnldOiB7IGNvbnRleHQ6IGNvbnRleHQgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgLypcbiAgICAgKiBEZWZhdWx0IGNhc2VcbiAgICAgKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IERFRkFVTFRfSU5TVEFOQ0VTID0ge1xuICBieUFkZHJlc3M6IHt9LFxuICBieUNvbnRleHQ6IHt9XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlcyhzdGF0ZSA9IERFRkFVTFRfSU5TVEFOQ0VTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIC8qXG4gICAgICogQWRkaW5nIGEgbmV3IGFkZHJlc3MgZm9yIGNvbnRleHRcbiAgICAgKi9cbiAgICBjYXNlIGFjdGlvbnMuQUREX0lOU1RBTkNFOlxuICAgICAgbGV0IHsgYWRkcmVzcywgY29udGV4dCwgYmluYXJ5IH0gPSBhY3Rpb247XG5cbiAgICAgIC8vIGdldCBrbm93biBhZGRyZXNzZXMgZm9yIHRoaXMgY29udGV4dFxuICAgICAgbGV0IG90aGVySW5zdGFuY2VzID0gc3RhdGUuYnlDb250ZXh0W2NvbnRleHRdIHx8IFtdO1xuICAgICAgbGV0IG90aGVyQWRkcmVzc2VzID0gb3RoZXJJbnN0YW5jZXMubWFwKCh7YWRkcmVzc30pID0+IGFkZHJlc3MpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBieUFkZHJlc3M6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUFkZHJlc3MsXG5cbiAgICAgICAgICBbYWRkcmVzc106IHsgY29udGV4dCwgYmluYXJ5IH1cbiAgICAgICAgfSxcblxuICAgICAgICBieUNvbnRleHQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUNvbnRleHQsXG5cbiAgICAgICAgICAvLyByZWNvbnN0cnVjdCBjb250ZXh0IGluc3RhbmNlcyB0byBpbmNsdWRlIG5ldyBhZGRyZXNzXG4gICAgICAgICAgW2NvbnRleHRdOiBBcnJheS5mcm9tKG5ldyBTZXQob3RoZXJBZGRyZXNzZXMpLmFkZChhZGRyZXNzKSlcbiAgICAgICAgICAgIC5tYXAoKGFkZHJlc3MpID0+ICh7YWRkcmVzc30pKVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgLypcbiAgICAgKiBEZWZhdWx0IGNhc2VcbiAgICAgKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbn1cblxuY29uc3QgaW5mbyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGNvbnRleHRzLFxuICBpbnN0YW5jZXNcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsbHN0YWNrKHN0YXRlID0gW10sIGFjdGlvbikge1xuICBzd2l0Y2goYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuQ0FMTDpcbiAgICAgIGxldCBhZGRyZXNzID0gYWN0aW9uLmFkZHJlc3M7XG4gICAgICByZXR1cm4gc3RhdGUuY29uY2F0KFsge2FkZHJlc3N9IF0pO1xuXG4gICAgY2FzZSBhY3Rpb25zLkNSRUFURTpcbiAgICAgIGNvbnN0IGJpbmFyeSA9IGFjdGlvbi5iaW5hcnk7XG4gICAgICByZXR1cm4gc3RhdGUuY29uY2F0KFsge2JpbmFyeX0gXSk7XG5cbiAgICBjYXNlIGFjdGlvbnMuUkVUVVJOOlxuICAgICAgcmV0dXJuIHN0YXRlLnNsaWNlKDAsIC0xKTsgLy8gcG9wXG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9O1xufVxuXG5jb25zdCBwcm9jID0gY29tYmluZVJlZHVjZXJzKHtcbiAgY2FsbHN0YWNrXG59KTtcblxuY29uc3QgcmVkdWNlciA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGluZm8sXG4gIHByb2Ncbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZWR1Y2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9ldm0vcmVkdWNlcnMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tXCJcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuXG5jb25zdCBERUZBVUxUX1NPVVJDRVMgPSB7XG4gIGJ5SWQ6IHt9XG59O1xuXG5mdW5jdGlvbiBzb3VyY2VzKHN0YXRlID0gREVGQVVMVF9TT1VSQ0VTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIC8qXG4gICAgICogQWRkaW5nIGEgbmV3IHNvdXJjZVxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfU09VUkNFOlxuICAgICAgbGV0IHsgYXN0LCBzb3VyY2UsIHNvdXJjZVBhdGggfSA9IGFjdGlvbjtcblxuICAgICAgbGV0IGlkID0gT2JqZWN0LmtleXMoc3RhdGUuYnlJZCkubGVuZ3RoO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBieUlkOiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlJZCxcblxuICAgICAgICAgIFtpZF06IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgYXN0LFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgc291cmNlUGF0aFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLypcbiAgICAgKiBEZWZhdWx0IGNhc2VcbiAgICAgKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cblxuY29uc3QgREVGQVVMVF9TT1VSQ0VNQVBTID0ge1xuICBieUNvbnRleHQ6IHt9XG59O1xuXG5mdW5jdGlvbiBzb3VyY2VNYXBzKHN0YXRlID0gREVGQVVMVF9TT1VSQ0VNQVBTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIC8qXG4gICAgICogQWRkaW5nIGEgbmV3IHNvdXJjZU1hcFxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfU09VUkNFTUFQOlxuICAgICAgbGV0IHsgYmluYXJ5LCBzb3VyY2VNYXAgfSA9IGFjdGlvbjtcbiAgICAgIGxldCBjb250ZXh0ID0ga2VjY2FrMjU2KGJpbmFyeSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5Q29udGV4dDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5Q29udGV4dCxcblxuICAgICAgICAgIFtjb250ZXh0XToge1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHNvdXJjZU1hcFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIC8qXG4gICAgICogRGVmYXVsdCBDYXNlXG4gICAgICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBpbmZvID0gY29tYmluZVJlZHVjZXJzKHtcbiAgc291cmNlcyxcbiAgc291cmNlTWFwc1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jdGlvbkRlcHRoKHN0YXRlID0gMSwgYWN0aW9uKSB7XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5KVU1QKSB7XG4gICAgY29uc3QgZGVsdGEgPSBzcGVsdW5rKGFjdGlvbi5qdW1wRGlyZWN0aW9uKVxuICAgIHJldHVybiBzdGF0ZSArIGRlbHRhO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzcGVsdW5rKGp1bXApIHtcbiAgaWYgKGp1bXAgPT0gXCJpXCIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChqdW1wID09IFwib1wiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBmdW5jdGlvbkRlcHRoXG59KTtcblxuY29uc3QgcmVkdWNlciA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGluZm8sXG4gIHByb2Ncbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZWR1Y2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zb2xpZGl0eS9yZWR1Y2Vycy5qcyIsImltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gXCJyZWR1eFwiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4KHN0YXRlID0gMCwgYWN0aW9uKSB7XG4gIGlmIChhY3Rpb24udHlwZSA9PSBhY3Rpb25zLlRPQ0sgfHwgYWN0aW9uLnR5cGUgPT0gYWN0aW9ucy5FTkRfT0ZfVFJBQ0UpIHtcbiAgICByZXR1cm4gc3RhdGUgKyAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RlcHMoc3RhdGUgPSBudWxsLCBhY3Rpb24pIHtcbiAgaWYgKGFjdGlvbi50eXBlID09IGFjdGlvbnMuU0FWRV9TVEVQUykge1xuICAgIHJldHVybiBhY3Rpb24uc3RlcHM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IGluZm8gPSBjb21iaW5lUmVkdWNlcnMoe1xuICBzdGVwc1xufSlcblxuY29uc3QgcHJvYyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGluZGV4XG59KVxuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgaW5mbyxcbiAgcHJvY1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3RyYWNlL3JlZHVjZXJzLmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcInRlc3Q6Y29udGV4dFwiKTtcblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcImNoYWlcIjtcblxuaW1wb3J0IEdhbmFjaGUgZnJvbSBcImdhbmFjaGUtY2xpXCI7XG5pbXBvcnQgV2ViMyBmcm9tIFwid2ViM1wiO1xuXG5pbXBvcnQgeyBwcmVwYXJlQ29udHJhY3RzIH0gZnJvbSBcIi4vaGVscGVyc1wiO1xuaW1wb3J0IERlYnVnZ2VyIGZyb20gXCJsaWIvZGVidWdnZXJcIjtcblxuaW1wb3J0IHNlc3Npb25TZWxlY3RvciBmcm9tIFwibGliL3Nlc3Npb24vc2VsZWN0b3JzXCI7XG5pbXBvcnQgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9zZWxlY3RvcnNcIjtcblxuY29uc3QgX19PVVRFUiA9IGBcbnByYWdtYSBzb2xpZGl0eSBeMC40LjE4O1xuXG5pbXBvcnQgXCIuL0lubmVyQ29udHJhY3Quc29sXCI7XG5cbmNvbnRyYWN0IE91dGVyQ29udHJhY3Qge1xuICBldmVudCBPdXRlcigpO1xuXG4gIElubmVyQ29udHJhY3QgaW5uZXI7XG5cbiAgZnVuY3Rpb24gT3V0ZXJDb250cmFjdChhZGRyZXNzIF9pbm5lcikgcHVibGljIHtcbiAgICBpbm5lciA9IElubmVyQ29udHJhY3QoX2lubmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bigpIHB1YmxpYyB7XG4gICAgaW5uZXIucnVuKCk7XG5cbiAgICBPdXRlcigpO1xuICB9XG59XG5gO1xuXG5jb25zdCBfX0lOTkVSID0gYFxucHJhZ21hIHNvbGlkaXR5IF4wLjQuMTg7XG5cbmNvbnRyYWN0IElubmVyQ29udHJhY3Qge1xuICBldmVudCBJbm5lcigpO1xuXG4gIGZ1bmN0aW9uIHJ1bigpIHB1YmxpYyB7XG4gICAgSW5uZXIoKTtcbiAgfVxufVxuYDtcblxuY29uc3QgX19NSUdSQVRJT04gPSBgXG5sZXQgT3V0ZXJDb250cmFjdCA9IGFydGlmYWN0cy5yZXF1aXJlKFwiT3V0ZXJDb250cmFjdFwiKTtcbmxldCBJbm5lckNvbnRyYWN0ID0gYXJ0aWZhY3RzLnJlcXVpcmUoXCJJbm5lckNvbnRyYWN0XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRlcGxveWVyKSB7XG4gIHJldHVybiBkZXBsb3llclxuICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlcGxveWVyLmRlcGxveShJbm5lckNvbnRyYWN0KTtcbiAgICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIElubmVyQ29udHJhY3QuZGVwbG95ZWQoKTtcbiAgICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uKGlubmVyKSB7XG4gICAgICByZXR1cm4gZGVwbG95ZXIuZGVwbG95KE91dGVyQ29udHJhY3QsIGlubmVyLmFkZHJlc3MpO1xuICAgIH0pO1xufTtcbmA7XG5cbmxldCBtaWdyYXRpb25zID0ge1xuICBcIjJfZGVwbG95X2NvbnRyYWN0cy5qc1wiOiBfX01JR1JBVElPTixcbn07XG5cbmxldCBzb3VyY2VzID0ge1xuICBcIk91dGVyTGlicmFyeS5zb2xcIjogX19PVVRFUixcbiAgXCJJbm5lckNvbnRyYWN0LnNvbFwiOiBfX0lOTkVSLFxufTtcblxuXG5kZXNjcmliZShcIkNvbnRleHRzXCIsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByb3ZpZGVyO1xuICB2YXIgd2ViMztcblxuICB2YXIgYWJzdHJhY3Rpb25zO1xuICB2YXIgYXJ0aWZhY3RzO1xuXG4gIGJlZm9yZShcIkNyZWF0ZSBQcm92aWRlclwiLCBhc3luYyBmdW5jdGlvbigpIHtcbiAgICBwcm92aWRlciA9IEdhbmFjaGUucHJvdmlkZXIoe3NlZWQ6IFwiZGVidWdnZXJcIiwgZ2FzTGltaXQ6IDcwMDAwMDB9KTtcbiAgICB3ZWIzID0gbmV3IFdlYjMocHJvdmlkZXIpO1xuICB9KTtcblxuICBiZWZvcmUoXCJQcmVwYXJlIGNvbnRyYWN0cyBhbmQgYXJ0aWZhY3RzXCIsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGltZW91dCgzMDAwMCk7XG5cbiAgICBsZXQgcHJlcGFyZWQgPSBhd2FpdCBwcmVwYXJlQ29udHJhY3RzKHByb3ZpZGVyLCBzb3VyY2VzLCBtaWdyYXRpb25zKTtcbiAgICBhYnN0cmFjdGlvbnMgPSBwcmVwYXJlZC5hYnN0cmFjdGlvbnM7XG4gICAgYXJ0aWZhY3RzID0gcHJlcGFyZWQuYXJ0aWZhY3RzO1xuICB9KTtcblxuICBpdChcInJldHVybnMgdmlldyBvZiBhZGRyZXNzZXMgYWZmZWN0ZWRcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgIGxldCBvdXRlciA9IGF3YWl0IGFic3RyYWN0aW9ucy5PdXRlckNvbnRyYWN0LmRlcGxveWVkKCk7XG4gICAgbGV0IGlubmVyID0gYXdhaXQgYWJzdHJhY3Rpb25zLklubmVyQ29udHJhY3QuZGVwbG95ZWQoKTtcblxuICAgIC8vIHJ1biBvdXRlciBjb250cmFjdCBtZXRob2RcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgb3V0ZXIucnVuKCk7XG5cbiAgICBhc3NlcnQuZXF1YWwoMiwgcmVzdWx0LnJlY2VpcHQubG9ncy5sZW5ndGgsIFwiVGhlcmUgc2hvdWxkIGJlIHR3byBsb2dzXCIpO1xuXG4gICAgbGV0IHR4SGFzaCA9IHJlc3VsdC50eDtcblxuICAgIGxldCBidWdnZXIgPSBhd2FpdCBEZWJ1Z2dlci5mb3JUeCh0eEhhc2gsIHtcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgY29udHJhY3RzOiBhcnRpZmFjdHNcbiAgICB9KTtcbiAgICBkZWJ1ZyhcImRlYnVnZ2VyIHJlYWR5XCIpO1xuXG4gICAgbGV0IHNlc3Npb24gPSBidWdnZXIuY29ubmVjdCgpO1xuXG4gICAgbGV0IGFmZmVjdGVkSW5zdGFuY2VzID0gc2Vzc2lvbi52aWV3KHNlc3Npb25TZWxlY3Rvci5pbmZvLmFmZmVjdGVkSW5zdGFuY2VzKTtcbiAgICBkZWJ1ZyhcImFmZmVjdGVkSW5zdGFuY2VzOiAlb1wiLCBhZmZlY3RlZEluc3RhbmNlcyk7XG5cbiAgICBsZXQgYWZmZWN0ZWRBZGRyZXNzZXMgPSBPYmplY3Qua2V5cyhhZmZlY3RlZEluc3RhbmNlcyk7XG5cbiAgICBhc3NlcnQuZXF1YWwoMiwgYWZmZWN0ZWRBZGRyZXNzZXMubGVuZ3RoKTtcblxuICAgIGFzc2VydC5pbmNsdWRlKFxuICAgICAgYWZmZWN0ZWRBZGRyZXNzZXMsIG91dGVyLmFkZHJlc3MsXG4gICAgICBcIk91dGVyQ29udHJhY3Qgc2hvdWxkIGJlIGFuIGFmZmVjdGVkIGFkZHJlc3NcIlxuICAgICk7XG5cbiAgICBhc3NlcnQuaW5jbHVkZShcbiAgICAgIGFmZmVjdGVkQWRkcmVzc2VzLCBpbm5lci5hZGRyZXNzLFxuICAgICAgXCJJbm5lckNvbnRyYWN0IHNob3VsZCBiZSBhbiBhZmZlY3RlZCBhZGRyZXNzXCJcbiAgICApO1xuICB9KTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHRlc3QvY29udGV4dC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJ0ZXN0OmRhdGE6ZGVjb2RlXCIpO1xuXG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3NlbGVjdG9yc1wiO1xuXG5pbXBvcnQge1xuICBnZW5lcmF0ZVVpbnRzLCBkZXNjcmliZURlY29kaW5nXG59IGZyb20gXCIuL2hlbHBlcnNcIjtcblxuY29uc3QgdWludHMgPSBnZW5lcmF0ZVVpbnRzKCk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQXJyYXkobGVuZ3RoKSB7XG4gIHJldHVybiBbLi4uQXJyYXkobGVuZ3RoKV1cbiAgICAubWFwKCgpID0+IHVpbnRzLm5leHQoKS52YWx1ZSlcbn1cblxuY29uc3QgZml4dHVyZXMgPSBbe1xuICBuYW1lOiBcIm11bHRpcGxlRnVsbFdvcmRBcnJheVwiLFxuICB0eXBlOiBcInVpbnRbXVwiLFxuICB2YWx1ZTogZ2VuZXJhdGVBcnJheSgzKSAgLy8gdGFrZXMgdXAgMyB3aG9sZSB3b3Jkc1xufSwge1xuICBuYW1lOiBcIndpdGhpbldvcmRBcnJheVwiLFxuICB0eXBlOiBcInVpbnQxNltdXCIsXG4gIHZhbHVlOiBnZW5lcmF0ZUFycmF5KDEwKSAgLy8gdGFrZXMgdXAgPjEvMiB3b3JkXG59LCB7XG4gIG5hbWU6IFwibXVsdGlwbGVQYXJ0V29yZEFycmF5XCIsXG4gIHR5cGU6IFwidWludDY0W11cIixcbiAgdmFsdWU6IGdlbmVyYXRlQXJyYXkoOSkgIC8vIHRha2VzIHVwIDIuMjUgd29yZHNcbn0sIHtcbiAgbmFtZTogXCJpbmNvbnZlbmllbnRseVdvcmRPZmZzZXRBcnJheVwiLFxuICB0eXBlOiBcInVpbnQyNDBbXVwiLFxuICB2YWx1ZTogZ2VuZXJhdGVBcnJheSgzKSAgLy8gdGFrZXMgdXAgfjIuOCB3b3Jkc1xufSwge1xuICBuYW1lOiBcInNob3J0U3RyaW5nXCIsXG4gIHR5cGU6IFwic3RyaW5nXCIsXG4gIHZhbHVlOiBcImhlbGxvIHdvcmxkXCJcbn0sIHtcbiAgbmFtZTogXCJsb25nU3RyaW5nXCIsXG4gIHR5cGU6IFwic3RyaW5nXCIsXG4gIHZhbHVlOiBcInNvbGlkaXR5IGFsbG9jYXRpb24gaXMgYSBmdW4gbGVzc29uIGluIGVuZGlhbm5lc3NcIlxufV07XG5cblxuZGVzY3JpYmUoXCJEZWNvZGluZ1wiLCBmdW5jdGlvbigpIHtcblxuICAvKlxuICAgKiBTdG9yYWdlIFRlc3RzXG4gICAqL1xuICBkZXNjcmliZURlY29kaW5nKFxuICAgIFwiU3RvcmFnZSBWYXJpYWJsZXNcIiwgZml4dHVyZXMsIGV2bS5jdXJyZW50LnN0YXRlLnN0b3JhZ2UsXG5cbiAgICAoY29udHJhY3ROYW1lKSA9PiB7XG4gICAgICByZXR1cm4gYHByYWdtYSBzb2xpZGl0eSBeMC40LjIzO1xuXG5jb250cmFjdCAke2NvbnRyYWN0TmFtZX0ge1xuXG4gIGV2ZW50IERvbmUoKTtcblxuICAvLyBkZWNsYXJhdGlvbnNcbiAgJHtmaXh0dXJlc1xuICAgIC5tYXAoICh7dHlwZSwgbmFtZX0pID0+IGAke3R5cGV9ICR7bmFtZX07YCApXG4gICAgLmpvaW4oXCJcXG4gIFwiKX1cblxuICBmdW5jdGlvbiBydW4oKSBwdWJsaWMge1xuICAgICR7Zml4dHVyZXNcbiAgICAgIC5tYXAoICh7bmFtZSwgdmFsdWV9KSA9PiBgJHtuYW1lfSA9ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfTtgIClcbiAgICAgIC5qb2luKFwiXFxuICAgIFwiKX1cblxuICAgIGVtaXQgRG9uZSgpO1xuICB9XG59XG5gICAgfVxuICApO1xuXG4gIC8qXG4gICAqIE1lbW9yeSBUZXN0c1xuICAgKi9cbiAgZGVzY3JpYmVEZWNvZGluZyhcbiAgICBcIk1lbW9yeSBWYXJpYWJsZXNcIiwgZml4dHVyZXMsIGV2bS5jdXJyZW50LnN0YXRlLm1lbW9yeSxcblxuICAgIChjb250cmFjdE5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHNlcGFyYXRvciA9IFwiO1xcbiAgICBcIjtcblxuICAgICAgZnVuY3Rpb24gZGVjbGFyZUFzc2lnbih7bmFtZSwgdHlwZSwgdmFsdWV9KSB7XG4gICAgICAgIGlmICh0eXBlLmluZGV4T2YoXCJbXVwiKSAhPSAtMSkge1xuICAgICAgICAgIC8vIGFycmF5LCBtdXN0IGBuZXdgXG4gICAgICAgICAgbGV0IGRlY2xhcmUgPSBgJHt0eXBlfSBtZW1vcnkgJHtuYW1lfSA9IG5ldyAke3R5cGV9KCR7dmFsdWUubGVuZ3RofSlgXG4gICAgICAgICAgbGV0IGFzc2lnbnMgPSB2YWx1ZS5tYXAoKGssIGkpID0+IGAke25hbWV9WyR7aX1dID0gJHtrfWApO1xuICAgICAgICAgIHJldHVybiBgJHtkZWNsYXJlfSR7c2VwYXJhdG9yfSR7YXNzaWducy5qb2luKHNlcGFyYXRvcil9YFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgJHt0eXBlfSBtZW1vcnkgJHtuYW1lfSA9ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYHByYWdtYSBzb2xpZGl0eSBeMC40LjIzO1xuXG5jb250cmFjdCAke2NvbnRyYWN0TmFtZX0ge1xuXG4gIGV2ZW50IERvbmUoKTtcblxuICBmdW5jdGlvbiBydW4oKSBwdWJsaWMge1xuICAgIHVpbnQgaTtcbiAgICAvLyBkZWNsYXJhdGlvbnNcbiAgICAke2ZpeHR1cmVzLm1hcChkZWNsYXJlQXNzaWduKS5qb2luKHNlcGFyYXRvcil9O1xuXG4gICAgZW1pdCBEb25lKCk7XG4gIH1cbn1cbmBcbiAgICB9XG4gICk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB0ZXN0L2RhdGEvZGVjb2RlL2RlY29kaW5nLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5XCJcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwidGVzdDpkYXRhOmRlY29kZTp1dGlsc1wiKTtcblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcImNoYWlcIjtcblxuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcImJpZ251bWJlci5qc1wiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcImxpYi9kYXRhL2RlY29kZS91dGlsc1wiO1xuXG5kZXNjcmliZShcIlV0aWxzXCIsIGZ1bmN0aW9uKCkge1xuICBkZXNjcmliZShcInRvQmlnTnVtYmVyKClcIiwgZnVuY3Rpb24oKSB7XG4gICAgaXQoXCJyZXR1cm5zIGNvcnJlY3QgdmFsdWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgYnl0ZXMgPSBbMHhmNSwgMHhlMiwgMHhjNSwgMHgxN107XG4gICAgICBsZXQgZXhwZWN0ZWRWYWx1ZSA9IG5ldyBCaWdOdW1iZXIoXCJmNWUyYzUxN1wiLCAxNik7XG5cbiAgICAgIGxldCByZXN1bHQgPSB1dGlscy50b0JpZ051bWJlcihieXRlcyk7XG5cbiAgICAgIGFzc2VydC5lcXVhbChyZXN1bHQudG9TdHJpbmcoKSwgZXhwZWN0ZWRWYWx1ZS50b1N0cmluZygpKTtcbiAgICB9KVxuICB9KTtcblxuICBkZXNjcmliZShcInRvU2lnbmVkQmlnTnVtYmVyKClcIiwgZnVuY3Rpb24oKSB7XG4gICAgaXQoXCJyZXR1cm5zIGNvcnJlY3QgbmVnYXRpdmUgdmFsdWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgYnl0ZXMgPSBbMHhmNSwgMHhlMiwgMHhjNSwgMHgxN107ICAvLyBzdGFydHMgd2l0aCAwYjFcbiAgICAgIGxldCByYXcgPSBuZXcgQmlnTnVtYmVyKFwiZjVlMmM1MTdcIiwgMTYpO1xuICAgICAgbGV0IGJpdGZpcHBlZCA9IG5ldyBCaWdOdW1iZXIoXG4gICAgICAgIHJhdy50b1N0cmluZygyKVxuICAgICAgICAgIC5yZXBsYWNlKC8wL2csIFwieFwiKVxuICAgICAgICAgIC5yZXBsYWNlKC8xL2csIFwiMFwiKVxuICAgICAgICAgIC5yZXBsYWNlKC94L2csIFwiMVwiKSxcbiAgICAgICAgMlxuICAgICAgKTtcblxuICAgICAgbGV0IGV4cGVjdGVkVmFsdWUgPSBiaXRmaXBwZWQucGx1cygxKS5uZWdhdGVkKCk7XG5cbiAgICAgIGxldCByZXN1bHQgPSB1dGlscy50b1NpZ25lZEJpZ051bWJlcihieXRlcyk7XG5cbiAgICAgIGFzc2VydC5lcXVhbChyZXN1bHQudG9TdHJpbmcoKSwgZXhwZWN0ZWRWYWx1ZS50b1N0cmluZygpKTtcbiAgICB9KTtcblxuICAgIGl0KFwicmV0dXJucyBjb3JyZWN0IHBvc2l0aXZlIHZhbHVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGJ5dGVzID0gWzB4MDUsIDB4ZTIsIDB4YzUsIDB4MTddOyAvLyBzdGFydHMgd2l0aCAwYjBcbiAgICAgIGxldCByYXcgPSBuZXcgQmlnTnVtYmVyKFwiMDVlMmM1MTdcIiwgMTYpO1xuICAgICAgbGV0IGV4cGVjdGVkVmFsdWUgPSByYXc7XG5cbiAgICAgIGxldCByZXN1bHQgPSB1dGlscy50b1NpZ25lZEJpZ051bWJlcihieXRlcyk7XG5cbiAgICAgIGFzc2VydC5lcXVhbChyZXN1bHQudG9TdHJpbmcoKSwgZXhwZWN0ZWRWYWx1ZS50b1N0cmluZygpKTtcbiAgICB9KVxuICB9KTtcblxuICBkZXNjcmliZShcInRvSGV4U3RyaW5nKClcIiwgZnVuY3Rpb24oKSB7XG4gICAgaXQoXCJyZXR1cm5zIGNvcnJlY3QgcmVwcmVzZW50YXRpb24gd2l0aCBmdWxsIGJ5dGVzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaWUsIDB4MDAgaW5zdGVhZCBvZiAweDBcbiAgICAgIGFzc2VydC5lcXVhbCh1dGlscy50b0hleFN0cmluZyhbMHgwNSwgMHgxMV0pLCBcIjB4MDUxMVwiKTtcbiAgICAgIGFzc2VydC5lcXVhbCh1dGlscy50b0hleFN0cmluZyhbMHhmZiwgMHgwMCwgMHhmZl0pLCBcIjB4ZmYwMGZmXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJhbGxvd3MgcmVtb3ZpbmcgbGVhZGluZyB6ZXJvZXNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBhc3NlcnQuZXF1YWwodXRpbHMudG9IZXhTdHJpbmcoWzB4MDAsIDB4MDAsIDB4Y2NdLCB0cnVlKSwgXCIweGNjXCIpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHRlc3QvZGF0YS9kZWNvZGUvdXRpbHMuanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwidGVzdDpzb2xpZGl0eVwiKTtcblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcImNoYWlcIjtcblxuaW1wb3J0IEdhbmFjaGUgZnJvbSBcImdhbmFjaGUtY2xpXCI7XG5pbXBvcnQgV2ViMyBmcm9tIFwid2ViM1wiO1xuXG5pbXBvcnQgeyBwcmVwYXJlQ29udHJhY3RzIH0gZnJvbSBcIi4vaGVscGVyc1wiO1xuaW1wb3J0IERlYnVnZ2VyIGZyb20gXCJsaWIvZGVidWdnZXJcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcblxuXG5jb25zdCBfX09VVEVSID0gYFxucHJhZ21hIHNvbGlkaXR5IF4wLjQuMTg7XG5cbmltcG9ydCBcIi4vSW5uZXIuc29sXCI7XG5cbmNvbnRyYWN0IE91dGVyIHtcbiAgZXZlbnQgQ2FsbGVkKCk7XG5cbiAgSW5uZXIgaW5uZXI7XG5cbiAgZnVuY3Rpb24gT3V0ZXIoYWRkcmVzcyBfaW5uZXIpIHtcbiAgICBpbm5lciA9IElubmVyKF9pbm5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBydW5TaW5nbGUoKSBwdWJsaWMge1xuICB9XG5cbiAgZnVuY3Rpb24gcnVuKCkgcHVibGljIHtcbiAgICBpbm5lci5ydW4oKTtcbiAgfVxufVxuYDtcblxuXG5jb25zdCBfX0lOTkVSID0gYFxucHJhZ21hIHNvbGlkaXR5IF4wLjQuMTg7XG5cbmNvbnRyYWN0IElubmVyIHtcbiAgZnVuY3Rpb24gcnVuKCkgcHVibGljIHtcbiAgfVxufVxuYDtcblxuY29uc3QgX19NSUdSQVRJT04gPSBgXG5sZXQgT3V0ZXIgPSBhcnRpZmFjdHMucmVxdWlyZShcIk91dGVyXCIpO1xubGV0IElubmVyID0gYXJ0aWZhY3RzLnJlcXVpcmUoXCJJbm5lclwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkZXBsb3llcikge1xuICByZXR1cm4gZGVwbG95ZXJcbiAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkZXBsb3llci5kZXBsb3koSW5uZXIpO1xuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSW5uZXIuZGVwbG95ZWQoKTtcbiAgICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uKGlubmVyKSB7XG4gICAgICByZXR1cm4gZGVwbG95ZXIuZGVwbG95KE91dGVyLCBpbm5lci5hZGRyZXNzKTtcbiAgICB9KTtcbn07XG5gO1xuXG5sZXQgc291cmNlcyA9IHtcbiAgXCJJbm5lci5zb2xcIjogX19JTk5FUixcbiAgXCJPdXRlci5zb2xcIjogX19PVVRFUixcbn1cblxubGV0IG1pZ3JhdGlvbnMgPSB7XG4gIFwiMl9kZXBsb3lfY29udHJhY3RzLmpzXCI6IF9fTUlHUkFUSU9OLFxufTtcblxuZGVzY3JpYmUoXCJFVk0gRGVidWdnaW5nXCIsIGZ1bmN0aW9uKCkge1xuICB2YXIgcHJvdmlkZXI7XG4gIHZhciB3ZWIzO1xuXG4gIHZhciBhYnN0cmFjdGlvbnM7XG4gIHZhciBhcnRpZmFjdHM7XG4gIHZhciBmaWxlcztcblxuICBiZWZvcmUoXCJDcmVhdGUgUHJvdmlkZXJcIiwgYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgcHJvdmlkZXIgPSBHYW5hY2hlLnByb3ZpZGVyKHtzZWVkOiBcImRlYnVnZ2VyXCIsIGdhc0xpbWl0OiA3MDAwMDAwfSk7XG4gICAgd2ViMyA9IG5ldyBXZWIzKHByb3ZpZGVyKTtcbiAgfSk7XG5cbiAgYmVmb3JlKFwiUHJlcGFyZSBjb250cmFjdHMgYW5kIGFydGlmYWN0c1wiLCBhc3luYyBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRpbWVvdXQoMzAwMDApO1xuXG4gICAgbGV0IHByZXBhcmVkID0gYXdhaXQgcHJlcGFyZUNvbnRyYWN0cyhwcm92aWRlciwgc291cmNlcywgbWlncmF0aW9ucylcbiAgICBhYnN0cmFjdGlvbnMgPSBwcmVwYXJlZC5hYnN0cmFjdGlvbnM7XG4gICAgYXJ0aWZhY3RzID0gcHJlcGFyZWQuYXJ0aWZhY3RzO1xuICAgIGZpbGVzID0gcHJlcGFyZWQuZmlsZXM7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRnVuY3Rpb24gRGVwdGhcIiwgZnVuY3Rpb24oKSB7XG4gICAgaXQoXCJyZW1haW5zIGF0IDEgaW4gYWJzZW5jZSBvZiBjcm9zcy1jb250cmFjdCBjYWxsc1wiLCBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1heEV4cGVjdGVkID0gMTtcblxuICAgICAgbGV0IGluc3RhbmNlID0gYXdhaXQgYWJzdHJhY3Rpb25zLklubmVyLmRlcGxveWVkKCk7XG4gICAgICBsZXQgcmVjZWlwdCA9IGF3YWl0IGluc3RhbmNlLnJ1bigpO1xuICAgICAgbGV0IHR4SGFzaCA9IHJlY2VpcHQudHg7XG5cbiAgICAgIGxldCBidWdnZXIgPSBhd2FpdCBEZWJ1Z2dlci5mb3JUeCh0eEhhc2gsIHtcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIGZpbGVzLFxuICAgICAgICBjb250cmFjdHM6IGFydGlmYWN0c1xuICAgICAgfSk7XG5cbiAgICAgIGxldCBzZXNzaW9uID0gYnVnZ2VyLmNvbm5lY3QoKTtcbiAgICAgIHZhciBzdGVwcGVkOyAgLy8gc2Vzc2lvbiBzdGVwcGVycyByZXR1cm4gZmFsc2Ugd2hlbiBkb25lXG5cbiAgICAgIGRvIHtcbiAgICAgICAgc3RlcHBlZCA9IHNlc3Npb24uc3RlcE5leHQoKTtcblxuICAgICAgICBsZXQgYWN0dWFsID0gc2Vzc2lvbi52aWV3KGV2bS5jdXJyZW50LmNhbGxzdGFjaykubGVuZ3RoO1xuXG4gICAgICAgIGFzc2VydC5pc0F0TW9zdChhY3R1YWwsIG1heEV4cGVjdGVkKTtcblxuICAgICAgfSB3aGlsZShzdGVwcGVkKTtcblxuICAgIH0pO1xuXG4gICAgaXQoXCJ0cmFja3MgY2FsbHN0YWNrIGNvcnJlY3RseVwiLCBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgIC8vIHByZXBhcmVcbiAgICAgIGxldCBpbnN0YW5jZSA9IGF3YWl0IGFic3RyYWN0aW9ucy5PdXRlci5kZXBsb3llZCgpO1xuICAgICAgbGV0IHJlY2VpcHQgPSBhd2FpdCBpbnN0YW5jZS5ydW4oKTtcbiAgICAgIGxldCB0eEhhc2ggPSByZWNlaXB0LnR4O1xuXG4gICAgICBsZXQgYnVnZ2VyID0gYXdhaXQgRGVidWdnZXIuZm9yVHgodHhIYXNoLCB7XG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBmaWxlcyxcbiAgICAgICAgY29udHJhY3RzOiBhcnRpZmFjdHNcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgc2Vzc2lvbiA9IGJ1Z2dlci5jb25uZWN0KCk7XG5cbiAgICAgIC8vIGZvbGxvdyBjYWxsc3RhY2sgbGVuZ3RoIHZhbHVlcyBpbiBsaXN0XG4gICAgICAvLyBzZWUgc291cmNlIGFib3ZlXG4gICAgICBsZXQgZXhwZWN0ZWREZXB0aFNlcXVlbmNlID0gWzEsMiwxLDBdO1xuICAgICAgbGV0IGFjdHVhbFNlcXVlbmNlID0gW3Nlc3Npb24udmlldyhldm0uY3VycmVudC5jYWxsc3RhY2spLmxlbmd0aF07XG5cbiAgICAgIHZhciBzdGVwcGVkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIHN0ZXBwZWQgPSBzZXNzaW9uLnN0ZXBOZXh0KCk7XG5cbiAgICAgICAgbGV0IGN1cnJlbnREZXB0aCA9IHNlc3Npb24udmlldyhldm0uY3VycmVudC5jYWxsc3RhY2spLmxlbmd0aDtcbiAgICAgICAgbGV0IGxhc3RLbm93biA9IGFjdHVhbFNlcXVlbmNlW2FjdHVhbFNlcXVlbmNlLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChjdXJyZW50RGVwdGggIT09IGxhc3RLbm93bikge1xuICAgICAgICAgIGFjdHVhbFNlcXVlbmNlLnB1c2goY3VycmVudERlcHRoKTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZShzdGVwcGVkKTtcblxuICAgICAgYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWxTZXF1ZW5jZSwgZXhwZWN0ZWREZXB0aFNlcXVlbmNlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB0ZXN0L2V2bS5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJ0ZXN0OnNvbGlkaXR5XCIpO1xuXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiY2hhaVwiO1xuXG5pbXBvcnQgR2FuYWNoZSBmcm9tIFwiZ2FuYWNoZS1jbGlcIjtcbmltcG9ydCBXZWIzIGZyb20gXCJ3ZWIzXCI7XG5cbmltcG9ydCB7IHByZXBhcmVDb250cmFjdHMgfSBmcm9tIFwiLi9oZWxwZXJzXCI7XG5pbXBvcnQgRGVidWdnZXIgZnJvbSBcImxpYi9kZWJ1Z2dlclwiO1xuXG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcblxuXG5jb25zdCBfX1NJTkdMRV9DQUxMID0gYFxucHJhZ21hIHNvbGlkaXR5IF4wLjQuMTg7XG5cbmNvbnRyYWN0IFNpbmdsZUNhbGwge1xuICBldmVudCBDYWxsZWQoKTtcblxuICBmdW5jdGlvbiBydW4oKSBwdWJsaWMge1xuICAgIENhbGxlZCgpO1xuICB9XG59XG5gO1xuXG5cbmNvbnN0IF9fTkVTVEVEX0NBTEwgPSBgcHJhZ21hIHNvbGlkaXR5IF4wLjQuMTg7XG5cbmNvbnRyYWN0IE5lc3RlZENhbGwge1xuICBldmVudCBGaXJzdCgpO1xuICBldmVudCBTZWNvbmQoKTtcblxuICAvLyBydW4oKVxuICAvLyAgIGZpcnN0KCkgICAgMVxuICAvLyAgICAgaW5uZXIoKSAgMlxuICAvLyAgICAgICBldmVudCAgM1xuICAvLyAgICAgICAgICAgICAgMlxuICAvLyAgIHNlY29uZCAgICAgMVxuICAvLyAgICAgZXZlbnQgICAgMlxuICAvLyAgICAgICAgICAgICAgMVxuICBmdW5jdGlvbiBydW4oKSBwdWJsaWMge1xuICAgIGZpcnN0KCk7XG4gICAgc2Vjb25kKCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJzdCgpIHB1YmxpYyB7XG4gICAgaW5uZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlubmVyKCkgcHVibGljIHtcbiAgICBGaXJzdCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2Vjb25kKCkgcHVibGljIHtcbiAgICBTZWNvbmQoKTtcbiAgfVxuXG59XG5gO1xuXG5cbmxldCBzb3VyY2VzID0ge1xuICBcIlNpbmdsZUNhbGwuc29sXCI6IF9fU0lOR0xFX0NBTEwsXG4gIFwiTmVzdGVkQ2FsbC5zb2xcIjogX19ORVNURURfQ0FMTCxcbn1cblxuXG5kZXNjcmliZShcIlNvbGlkaXR5IERlYnVnZ2luZ1wiLCBmdW5jdGlvbigpIHtcbiAgdmFyIHByb3ZpZGVyO1xuICB2YXIgd2ViMztcblxuICB2YXIgYWJzdHJhY3Rpb25zO1xuICB2YXIgYXJ0aWZhY3RzO1xuICB2YXIgZmlsZXM7XG5cbiAgYmVmb3JlKFwiQ3JlYXRlIFByb3ZpZGVyXCIsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgIHByb3ZpZGVyID0gR2FuYWNoZS5wcm92aWRlcih7c2VlZDogXCJkZWJ1Z2dlclwiLCBnYXNMaW1pdDogNzAwMDAwMH0pO1xuICAgIHdlYjMgPSBuZXcgV2ViMyhwcm92aWRlcik7XG4gIH0pO1xuXG4gIGJlZm9yZShcIlByZXBhcmUgY29udHJhY3RzIGFuZCBhcnRpZmFjdHNcIiwgYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50aW1lb3V0KDMwMDAwKTtcblxuICAgIGxldCBwcmVwYXJlZCA9IGF3YWl0IHByZXBhcmVDb250cmFjdHMocHJvdmlkZXIsIHNvdXJjZXMpXG4gICAgYWJzdHJhY3Rpb25zID0gcHJlcGFyZWQuYWJzdHJhY3Rpb25zO1xuICAgIGFydGlmYWN0cyA9IHByZXBhcmVkLmFydGlmYWN0cztcbiAgICBmaWxlcyA9IHByZXBhcmVkLmZpbGVzO1xuICB9KTtcblxuICBpdChcImV4cG9zZXMgZnVuY3Rpb25hbGl0eSB0byBzdG9wIGF0IGJyZWFrcG9pbnRzXCIsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgIC8vIHByZXBhcmVcbiAgICBsZXQgaW5zdGFuY2UgPSBhd2FpdCBhYnN0cmFjdGlvbnMuTmVzdGVkQ2FsbC5kZXBsb3llZCgpO1xuICAgIGxldCByZWNlaXB0ID0gYXdhaXQgaW5zdGFuY2UucnVuKCk7XG4gICAgbGV0IHR4SGFzaCA9IHJlY2VpcHQudHg7XG5cbiAgICBsZXQgYnVnZ2VyID0gYXdhaXQgRGVidWdnZXIuZm9yVHgodHhIYXNoLCB7XG4gICAgICBwcm92aWRlcixcbiAgICAgIGZpbGVzLFxuICAgICAgY29udHJhY3RzOiBhcnRpZmFjdHNcbiAgICB9KTtcblxuICAgIGxldCBzZXNzaW9uID0gYnVnZ2VyLmNvbm5lY3QoKTtcblxuICAgIC8vIGF0IGBzZWNvbmQoKTtgXG4gICAgbGV0IGJyZWFrcG9pbnQgPSB7IFwiYWRkcmVzc1wiOiBpbnN0YW5jZS5hZGRyZXNzLCBsaW5lOiAxNiB9XG4gICAgbGV0IGJyZWFrcG9pbnRTdG9wcGVkID0gZmFsc2U7XG5cbiAgICBkbyB7XG4gICAgICBzZXNzaW9uLmNvbnRpbnVlVW50aWwoYnJlYWtwb2ludCk7XG5cbiAgICAgIGlmICghc2Vzc2lvbi5maW5pc2hlZCkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBhd2FpdCBzZXNzaW9uLnZpZXcoc29saWRpdHkuY3VycmVudC5zb3VyY2VSYW5nZSk7XG4gICAgICAgIGFzc2VydC5lcXVhbChyYW5nZS5saW5lcy5zdGFydC5saW5lLCAxNik7XG5cbiAgICAgICAgYnJlYWtwb2ludFN0b3BwZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgfSB3aGlsZSghc2Vzc2lvbi5maW5pc2hlZCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRnVuY3Rpb24gRGVwdGhcIiwgZnVuY3Rpb24oKSB7XG4gICAgaXQoXCJyZW1haW5zIGF0IDEgaW4gYWJzZW5jZSBvZiBpbm5lciBmdW5jdGlvbiBjYWxsc1wiLCBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1heEV4cGVjdGVkID0gMTtcblxuICAgICAgbGV0IGluc3RhbmNlID0gYXdhaXQgYWJzdHJhY3Rpb25zLlNpbmdsZUNhbGwuZGVwbG95ZWQoKTtcbiAgICAgIGxldCByZWNlaXB0ID0gYXdhaXQgaW5zdGFuY2UucnVuKCk7XG4gICAgICBsZXQgdHhIYXNoID0gcmVjZWlwdC50eDtcblxuICAgICAgbGV0IGJ1Z2dlciA9IGF3YWl0IERlYnVnZ2VyLmZvclR4KHR4SGFzaCwge1xuICAgICAgICBwcm92aWRlcixcbiAgICAgICAgZmlsZXMsXG4gICAgICAgIGNvbnRyYWN0czogYXJ0aWZhY3RzXG4gICAgICB9KTtcblxuICAgICAgbGV0IHNlc3Npb24gPSBidWdnZXIuY29ubmVjdCgpO1xuICAgICAgdmFyIHN0ZXBwZWQ7ICAvLyBzZXNzaW9uIHN0ZXBwZXJzIHJldHVybiBmYWxzZSB3aGVuIGRvbmVcblxuICAgICAgZG8ge1xuICAgICAgICBzdGVwcGVkID0gc2Vzc2lvbi5zdGVwTmV4dCgpO1xuXG4gICAgICAgIGxldCBhY3R1YWwgPSBzZXNzaW9uLnZpZXcoc29saWRpdHkuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcblxuICAgICAgICBhc3NlcnQuaXNBdE1vc3QoYWN0dWFsLCBtYXhFeHBlY3RlZCk7XG5cbiAgICAgIH0gd2hpbGUoc3RlcHBlZCk7XG5cbiAgICB9KTtcblxuICAgIGl0KFwic3BlbHVua3MgY29ycmVjdGx5XCIsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gcHJlcGFyZVxuICAgICAgbGV0IGluc3RhbmNlID0gYXdhaXQgYWJzdHJhY3Rpb25zLk5lc3RlZENhbGwuZGVwbG95ZWQoKTtcbiAgICAgIGxldCByZWNlaXB0ID0gYXdhaXQgaW5zdGFuY2UucnVuKCk7XG4gICAgICBsZXQgdHhIYXNoID0gcmVjZWlwdC50eDtcblxuICAgICAgbGV0IGJ1Z2dlciA9IGF3YWl0IERlYnVnZ2VyLmZvclR4KHR4SGFzaCwge1xuICAgICAgICBwcm92aWRlcixcbiAgICAgICAgZmlsZXMsXG4gICAgICAgIGNvbnRyYWN0czogYXJ0aWZhY3RzXG4gICAgICB9KTtcblxuICAgICAgbGV0IHNlc3Npb24gPSBidWdnZXIuY29ubmVjdCgpO1xuXG4gICAgICAvLyBmb2xsb3cgZnVuY3Rpb25EZXB0aCB2YWx1ZXMgaW4gbGlzdFxuICAgICAgLy8gc2VlIHNvdXJjZSBhYm92ZVxuICAgICAgbGV0IGV4cGVjdGVkRGVwdGhTZXF1ZW5jZSA9IFsxLDIsMywyLDEsMiwxLDBdO1xuICAgICAgbGV0IGFjdHVhbFNlcXVlbmNlID0gW3Nlc3Npb24udmlldyhzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpXTtcblxuICAgICAgdmFyIHN0ZXBwZWQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgc3RlcHBlZCA9IHNlc3Npb24uc3RlcE5leHQoKTtcblxuICAgICAgICBsZXQgY3VycmVudERlcHRoID0gc2Vzc2lvbi52aWV3KHNvbGlkaXR5LmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gICAgICAgIGxldCBsYXN0S25vd24gPSBhY3R1YWxTZXF1ZW5jZVthY3R1YWxTZXF1ZW5jZS5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoY3VycmVudERlcHRoICE9PSBsYXN0S25vd24pIHtcbiAgICAgICAgICBhY3R1YWxTZXF1ZW5jZS5wdXNoKGN1cnJlbnREZXB0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUoc3RlcHBlZCk7XG5cbiAgICAgIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsU2VxdWVuY2UsIGV4cGVjdGVkRGVwdGhTZXF1ZW5jZSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gdGVzdC9zb2xpZGl0eS5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3REE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7O0FDRUE7QUFZQTtBQUNBO0FBZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFMQTtBQUNBO0FBS0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBUEE7QUFDQTtBQVNBOzs7QUFHQTtBQUNBO0FBZEE7QUFDQTtBQWdCQTs7O0FBR0E7QUFDQTtBQXJCQTtBQUNBO0FBeUJBOzs7OztBQUtBO0FBQ0E7QUFoQ0E7QUFDQTtBQWtDQTs7O0FBR0E7QUFDQTtBQXZDQTtBQUNBO0FBeUNBOzs7OztBQUtBO0FBQ0E7QUFEQTtBQS9DQTtBQUNBO0FBbURBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBQ0E7QUFpQkE7Ozs7O0FBS0E7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUF2QkE7QUFzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQUE7QUFKQTtBQUNBO0FBS0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQUE7QUFKQTtBQUNBO0FBS0E7OztBQUdBO0FBQUE7QUFUQTtBQUNBO0FBVUE7OztBQUdBO0FBQ0E7QUFBQTtBQURBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBQ0E7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFFQTtBQUFBO0FBRkE7QUFBQTtBQWZBO0FBUkE7QUFkQTtBQUNBO0FBNENBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQUE7QUFMQTtBQUNBO0FBTUE7OztBQUdBO0FBR0E7QUFiQTtBQUNBO0FBZUE7OztBQUdBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRkE7QUFqQ0E7QUFDQTtBQXVDQTs7Ozs7QUFLQTtBQVFBO0FBQ0E7QUFEQTtBQXJEQTtBQUNBO0FBeURBOzs7QUFHQTtBQTdEQTtBQUNBO0FBK0RBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFRQTtBQUNBO0FBREE7QUFmQTtBQUNBO0FBbUJBO0FBcEJBO0FBNUhBO0FBQ0E7QUFtSkE7Ozs7OztBQzVRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7Ozs7OztBQVBBO0FBQ0E7QUFPQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUpBO0FBSEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTtBQUpBO0FBQ0E7QUFLQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFBQTtBQUpBO0FBQ0E7QUFLQTs7O0FBR0E7QUFBQTtBQUFBO0FBVEE7QUFDQTtBQVdBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBR0E7QUFBQTtBQVJBO0FBQ0E7QUFVQTs7O0FBR0E7QUFBQTtBQWRBO0FBQ0E7QUFlQTs7O0FBR0E7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUZBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFSQTtBQWFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUhBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUE5QkE7QUFuREE7QUFDQTtBQTZGQTs7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQVBBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFRQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBZEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBY0E7QUFuSEE7QUFDQTtBQXNIQTs7O0FBR0E7QUFHQTtBQTdIQTtBQUNBO0FBK0hBOzs7QUFHQTtBQUdBO0FBQUE7QUF0SUE7QUFDQTtBQXdJQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoS0E7QUFDQTtBQXVLQTs7O0FBR0E7QUFHQTtBQUFBO0FBOUtBO0FBQ0E7QUFnTEE7OztBQUdBO0FBQUE7QUFwTEE7QUFDQTtBQXFMQTs7O0FBR0E7QUFDQTtBQUFBO0FBREE7QUF6TEE7QUF4QkE7QUFDQTtBQXNOQTs7Ozs7O0FDL09BOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWUE7QUFrQkE7QUFVQTtBQVNBO0FBOEVBO0FBc0JBO0FBb0JBO0FBSUE7QUFJQTtBQXFCQTtBQWVBO0FBYUE7QUEwQ0E7QUF3QkE7QUFDQTtBQXJTQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQUpBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUFBO0FBQUE7QUFEQTtBQUlBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUZBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVVBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNwVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaENBOzs7Ozs7QUNBQTs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2Q0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQVhBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQWFBO0FBQUE7QUFDQTtBQUNBO0FBZkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBaUJBO0FBQ0E7QUFsQkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUF1QkE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBOUJBO0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQWhDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7Ozs7OztBQWlEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTs7Ozs7O0FBbUJBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBUkE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7Ozs7OztBQVlBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBUkE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7Ozs7OztBQVlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQWxCQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBOzs7Ozs7QUFzQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBOzs7Ozs7QUFZQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBOzs7Ozs7QUFXQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTs7Ozs7QUFsR0E7QUFDQTtBQXZEQTtBQUNBOzs7QUFFQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQWJBO0FBQ0E7QUFvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOURBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOzs7OztBQVJBO0FBQ0E7QUFTQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFBQTtBQUFBO0FBSkE7QUFDQTtBQU1BOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBUkE7QUFDQTtBQVVBOzs7OztBQUtBO0FBQ0E7QUFBQTtBQWpCQTtBQUNBO0FBbUJBOzs7OztBQUtBO0FBR0E7QUE1QkE7QUFDQTtBQThCQTs7Ozs7QUFLQTtBQUNBO0FBREE7QUFDQTtBQXJDQTtBQWRBO0FBQ0E7QUEyREE7Ozs7OztBQzFFQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTs7OztBQUlBO0FBQUE7QUFDQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUE0QkE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOUJBO0FBQUE7Ozs7OztBQUNBO0FBQ0E7QUFJQTs7O0FBTUE7QUFDQTs7Ozs7Ozs7Ozs7QUFJQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTs7Ozs7QUFHQTs7Ozs7Ozs7Ozs7O0FBM0VBOzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQUE7QUFOQTtBQUNBO0FBT0E7Ozs7O0FBS0E7QUFBQTtBQWJBO0FBQ0E7QUFjQTs7Ozs7QUFLQTtBQUNBO0FBckJBO0FBQ0E7QUF1QkE7Ozs7O0FBS0E7QUFDQTtBQTlCQTtBQUNBO0FBZ0NBOzs7OztBQUtBO0FBQ0E7QUFEQTtBQXRDQTtBQUNBO0FBMkNBOzs7Ozs7QUM5Q0E7Ozs7Ozs7Ozs7OztBQ0NBO0FBUUE7QUFRQTtBQUtBO0FBS0E7QUFLQTtBQWhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNsQ0E7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDOVVBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7QUNDQTtBQVFBO0FBT0E7QUFRQTtBQU9BO0FBL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBYkE7QUFDQTtBQWFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7QUFHQTtBQUdBO0FBQ0E7QUFEQTtBQVBBO0FBQ0E7QUFXQTs7O0FBR0E7QUFHQTtBQUVBO0FBRkE7QUFsQkE7QUFDQTtBQXVCQTs7O0FBR0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFJQTtBQUpBO0FBREE7QUFIQTtBQTNCQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBREE7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQU5BO0FBQ0E7QUFRQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUdBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFKQTtBQUZBO0FBSEE7QUFMQTtBQUNBO0FBdUJBOzs7OztBQUtBO0FBSUE7QUFBQTtBQUFBO0FBSkE7QUF6Q0E7QUFDQTtBQWlEQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUFBO0FBQUE7QUFMQTtBQUNBO0FBT0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTtBQUFBO0FBTEE7QUFDQTtBQU9BOzs7QUFHQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBREE7QUFMQTtBQUNBO0FBU0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBREE7QUFFQTtBQUpBO0FBQ0E7QUFNQTtBQVJBO0FBQ0E7QUFVQTtBQTVCQTtBQUNBO0FBK0JBOzs7OztBQUtBO0FBTUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFFQTtBQUxBO0FBM0NBO0FBQ0E7QUFvREE7Ozs7O0FBS0E7QUFNQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQU5BO0FBaEVBO0FBQ0E7QUE0RUE7QUFPQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFGQTtBQXBGQTtBQUNBO0FBMkZBO0FBNUZBO0FBdkJBO0FBQ0E7QUFzSEE7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFMQTtBQTNNQTtBQUNBO0FBbU5BOzs7Ozs7QUNoUkE7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvREE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDU0E7QUFjQTtBQXlCQTtBQUNBO0FBakRBO0FBQ0E7OztBQUVBO0FBQ0E7Ozs7Ozs7QUFIQTtBQUNBO0FBSUE7OztBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBTUE7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBUEE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFEQTtBQUVBO0FBQUE7QUFGQTtBQUdBO0FBSEE7QUFJQTs7Ozs7Ozs7Ozs7O0FDbkVBO0FBUUE7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBTUE7QUF4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3QkE7QUFJQTtBQWlGQTtBQUNBO0FBdEdBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFJQTtBQUlBO0FBNkVBO0FBQ0E7QUFyR0E7QUFDQTtBQWNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBb0NBO0FBQ0E7QUFEQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFFQTtBQUZBO0FBR0E7QUFIQTtBQUNBO0FBNUNBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFzREE7QUFDQTtBQXhEQTtBQUNBO0FBeURBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUZBO0FBSUE7QUFDQTtBQS9EQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUE0RUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBTEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFTQTs7Ozs7Ozs7Ozs7O0FDOUdBO0FBUUE7QUFRQTtBQWpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRUE7QUFpQ0E7QUFJQTtBQVNBO0FBQ0E7QUF2RUE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQWNBO0FBTUE7QUEyQkE7QUFJQTtBQVNBO0FBQ0E7QUF0RUE7QUFDQTtBQVFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUFBO0FBREE7QUFFQTtBQUFBO0FBUEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBYUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBUkE7QUFBQTtBQUNBO0FBREE7QUFVQTtBQUNBO0FBWEE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWVBO0FBQ0E7QUFqQkE7QUFBQTtBQUNBO0FBREE7QUFtQkE7QUFDQTtBQXBCQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUEwQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBTEE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BOzs7Ozs7Ozs7Ozs7QUM1RUE7QUFRQTtBQVNBO0FBbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7Ozs7Ozs7OztBQ3RCQTtBQVFBO0FBUUE7QUFRQTtBQVFBO0FBakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7OztBQU5BO0FBQ0E7QUFNQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBR0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUtBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFFQTtBQURBO0FBWkE7QUFIQTtBQUxBO0FBSkE7QUFDQTtBQWtDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUlBO0FBQUE7QUFBQTtBQUpBO0FBQUE7QUFDQTtBQURBO0FBT0E7QUFQQTtBQUFBO0FBQ0E7QUFEQTtBQVFBO0FBQ0E7QUFUQTtBQUFBO0FBQ0E7QUFEQTtBQVdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBckJBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7Ozs7OztBQXlCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFKQTtBQUtBO0FBQUE7QUFDQTtBQU5BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTs7Ozs7QUE3REE7QUF1RUE7QUFDQTtBQXZGQTtBQUNBOzs7QUFFQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFmQTtBQUNBO0FBYUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBSUE7QUFKQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSEE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBTEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBUUE7QUFDQTtBQUNBOzs7Ozs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7O0FBZEE7QUFDQTtBQWNBO0FBQ0E7QUE2QkE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBUUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUZBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUpBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBUEE7QUFNQTtBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFKQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBckNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBdUNBO0FBQ0E7Ozs7OztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDekJBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hRQTs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDN0lBOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuMERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVtREE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7OztBQUVBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZEE7QUFDQTtBQWNBOzs7QUFHQTtBQUNBOzs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBQUE7OztBQUdBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBTEE7QUFEQTtBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBNkRBO0FBQ0E7QUFDQTs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUF0REE7QUFDQTtBQUNBOzs7QUFNQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBM0RBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFsQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBbUNBO0FBQ0E7QUFEQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQXpGQTs7Ozs7O0FDbkJBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7Ozs7QUNBQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDT0E7QUF5Q0E7QUFDQTtBQWxEQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7OztBQU5BO0FBQ0E7QUFDQTtBQUtBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBVEE7QUFZQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFGQTtBQURBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBRkE7QUFNQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQy9FQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNpQkE7QUFDQTtBQWxCQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFxREE7QUFPQTtBQXFCQTtBQVVBO0FBTUE7QUFJQTtBQUlBO0FBQ0E7QUExSEE7QUFDQTtBQWVBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUxBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQVJBO0FBQ0E7QUFEQTtBQUNBO0FBVUE7QUFYQTtBQUNBO0FBREE7QUFDQTtBQWFBO0FBQ0E7QUFmQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBc0JBO0FBdkJBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBMkJBO0FBQ0E7QUE1QkE7QUFDQTtBQURBO0FBQ0E7QUE4QkE7QUFDQTtBQWhDQTtBQUNBO0FBREE7QUFDQTtBQWtDQTtBQUNBO0FBcENBO0FBQ0E7QUFEQTtBQUNBO0FBc0NBO0FBQ0E7QUF4Q0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQTJDQTtBQTVDQTtBQUFBO0FBOENBO0FBOUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBaURBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBSEE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQWlCQTtBQWpCQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQW9CQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNURBO0FBZ0JBO0FBQ0E7QUEvRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBO0FBa0JBO0FBb0JBO0FBTUE7QUFJQTtBQWdCQTtBQUNBO0FBOUVBO0FBQ0E7QUFZQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWlCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBSUE7QUFDQTtBQU5BO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQVJBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFjQTtBQWRBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBbUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFEQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBTkE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFlQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFGQTtBQUNBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0VBO0FBYUE7QUFrQ0E7QUE4RUE7QUFrSEE7QUFDQTtBQTFQQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQVBBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhCQTtBQTBCQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQURBO0FBRkE7QUFDQTtBQU1BO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBSEE7QUFIQTtBQUNBO0FBV0E7QUF2QkE7QUFDQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQXJFQTtBQXdFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFkQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBbEJBO0FBQ0E7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFSQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUZBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUF0R0E7QUF3R0E7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBOzs7Ozs7Ozs7Ozs7QUN2UEE7QUFTQTtBQStCQTtBQUNBO0FBekRBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFMQTtBQUNBO0FBTUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BEQTtBQXFDQTtBQUNBO0FBbkRBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQUpBO0FBQ0E7QUFLQTs7Ozs7O0FBTUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQU9BO0FBRUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDMUZBO0FBUUE7QUFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZUE7QUFDQTtBQTdCQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBcUJBO0FBWUE7QUFrQ0E7QUEwQ0E7QUF3QkE7QUErQkE7QUFDQTtBQWhNQTtBQUNBO0FBV0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBR0E7QUFKQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQVVBO0FBQ0E7QUFGQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBZUE7QUFDQTtBQUNBOzs7O0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7Ozs7Ozs7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFxQkE7Ozs7Ozs7Ozs7OztBQVlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBb0NBOzs7OztBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWlCQTs7Ozs7O0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBeUJBOzs7OztBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQVdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBQ0E7QUFiQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7OztBQ2hNQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7OztBQVBBO0FBQ0E7QUFPQTs7O0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFkQTtBQW5CQTtBQUxBO0FBQ0E7QUEwQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakRBO0FBSUE7QUFvQkE7QUFDQTtBQXBDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUlBO0FBSUE7QUFnQkE7QUFDQTtBQW5DQTtBQUNBO0FBU0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQU5BO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFlQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQVdBO0FBU0E7QUFRQTtBQXdCQTtBQUNBO0FBckVBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1BO0FBV0E7QUFTQTtBQVFBO0FBd0JBO0FBQ0E7QUFwRUE7QUFDQTtBQVNBOzs7OztBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7Ozs7O0FBS0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBSkE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFOQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVdBO0FBWkE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFpQkE7QUFsQkE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBdUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckJBO0FBdUJBO0FBOEJBO0FBQ0E7QUF6R0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQWlDQTtBQVFBO0FBdUJBO0FBb0JBO0FBVUE7QUFDQTtBQXhHQTtBQUNBO0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFOQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBVUE7QUFYQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBZ0NBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFHQTtBQUpBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBSUE7QUFBQTtBQUpBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVVBO0FBQ0E7QUFaQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFpQkE7QUFDQTtBQW5CQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXNCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFGQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBSUE7QUFMQTtBQUFBO0FBT0E7QUFQQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFZQTtBQVpBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFjQTtBQUNBO0FBaEJBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBbUJBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQU5BO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBU0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVFBOzs7Ozs7Ozs7Ozs7QUNoSEE7QUFRQTtBQVFBO0FBUUE7QUFRQTtBQVFBO0FBUUE7QUFqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3REQTtBQUNBOzs7QUFDQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7O0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFEQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVFBOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBUUE7Ozs7OztBQUtBOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQURBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFqREE7Ozs7Ozs7Ozs7Ozs7QUNRQTtBQUNBO0FBZkE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTEE7QUFDQTtBQUtBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQURBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBTkE7QUFEQTtBQUNBO0FBZUE7QUFDQTtBQXhDQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUxBO0FBREE7QUFDQTtBQWdCQTtBQUNBO0FBcEJBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBOUZBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQVBBO0FBQ0E7QUFhQTs7O0FBR0E7QUFDQTtBQS9CQTtBQWlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUtBO0FBTEE7QUFQQTtBQUNBO0FBZUE7OztBQUdBO0FBQ0E7QUEvQkE7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTs7Ozs7O0FDeEhBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDK0VBO0FBQ0E7QUFoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBUUE7OztBQWJBO0FBaUJBO0FBMUJBO0FBNEJBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFGQTtBQUpBO0FBQ0E7QUFVQTs7O0FBR0E7QUFDQTtBQXZCQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7OztBQ3ZHQTtBQVFBO0FBQ0E7QUFiQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBWkE7QUFDQTtBQVlBO0FBQ0E7QUFxQkE7QUFDQTtBQVdBO0FBQ0E7QUFpQkE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFGQTtBQUFBO0FBQ0E7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQVRBO0FBQUE7QUFZQTtBQUNBO0FBRkE7QUFDQTtBQVpBO0FBV0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBaENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBb0NBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BJQTtBQUNBOzs7QUFFQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7OztBQUdBO0FBSUE7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFDQTtBQUVBOzs7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFlQTtBQUVBOzs7Ozs7QUMvR0E7Ozs7Ozs7OztBQ0FBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBTkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3REE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7OztBQVhBO0FBQ0E7QUFZQTtBQUNBO0FBdUJBO0FBQ0E7QUFRQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBQUE7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUxBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBUkE7QUFPQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQXhCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBMEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFGQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFKQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQVBBO0FBTUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBa0NBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0pBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7Ozs7QUFYQTtBQUNBO0FBWUE7QUFDQTtBQVlBO0FBQ0E7QUFrQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBRkE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBSkE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFQQTtBQU1BO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFqQkE7QUFtQkE7QUFDQTtBQXBCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFzQkE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUE4QkE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFMQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQVJBO0FBT0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUF4QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQTBCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBRkE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBSkE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFQQTtBQU1BO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWtDQTtBQUNBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=