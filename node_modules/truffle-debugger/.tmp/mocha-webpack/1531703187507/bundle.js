(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Debugger", [], factory);
	else if(typeof exports === 'object')
		exports["Debugger"] = factory();
	else
		root["Debugger"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 37);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("debug");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/entries");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(3);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(4);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(9);

var _selectors = __webpack_require__(19);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:evm:selectors");

const WORD_SIZE = 0x20;

/**
 * create EVM-level selectors for a given trace step selector
 * may specify additional selectors to include
 */
function createStepSelectors(step, state = null) {
  let base = {
    /**
     * .trace
     *
     * trace step info related to operation
     */
    trace: (0, _reselectTree.createLeaf)([step], ({ gasCost, op, pc }) => ({ gasCost, op, pc })),

    /**
     * .programCounter
     */
    programCounter: (0, _reselectTree.createLeaf)(["./trace"], step => step.pc),

    /**
     * .isJump
     */
    isJump: (0, _reselectTree.createLeaf)(["./trace"], step => step.op != "JUMPDEST" && step.op.indexOf("JUMP") == 0),

    /**
     * .isCall
     *
     * whether the opcode will switch to another calling context
     */
    isCall: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "CALL" || step.op == "DELEGATECALL"),

    /**
     * .isCreate
     */
    isCreate: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "CREATE"),

    /**
     * .isHalting
     *
     * whether the instruction halts or returns from a calling context
     */
    isHalting: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "STOP" || step.op == "RETURN")
  };

  if (state) {
    const isRelative = path => typeof path == "string" && (path.startsWith("./") || path.startsWith("../"));

    if (isRelative(state)) {
      state = `../${state}`;
    }

    (0, _assign2.default)(base, {
      /**
       * .callAddress
       *
       * address transferred to by call operation
       */
      callAddress: (0, _reselectTree.createLeaf)(["./isCall", "./trace", state], (matches, step, { stack }) => {
        if (!matches) return null;

        let address = stack[stack.length - 2];
        address = "0x" + address.substring(24);
        return address;
      }),

      /**
       * .createBinary
       *
       * binary code to execute via create operation
       */
      createBinary: (0, _reselectTree.createLeaf)(["./isCreate", "./trace", state], (matches, step, { stack, memory }) => {
        if (!matches) return null;

        // Get the code that's going to be created from memory.
        // Note we multiply by 2 because these offsets are in bytes.
        const offset = parseInt(stack[stack.length - 2], 16) * 2;
        const length = parseInt(stack[stack.length - 3], 16) * 2;

        return "0x" + memory.join("").substring(offset, offset + length);
      })
    });
  }

  return base;
}

const evm = (0, _reselectTree.createSelectorTree)({
  /**
   * evm.state
   */
  state: state => state.evm,

  /**
   * evm.info
   */
  info: {
    /**
     * evm.info.contexts
     */
    contexts: (0, _reselectTree.createLeaf)(['/state'], state => state.info.contexts.byContext),

    /**
     * evm.info.instances
     */
    instances: (0, _reselectTree.createLeaf)(['/state'], state => state.info.instances.byAddress),

    /**
     * evm.info.binaries
     */
    binaries: {
      _: (0, _reselectTree.createLeaf)(['/state'], state => state.info.contexts.byBinary),

      /**
       * evm.info.binaries.search
       *
       * returns function (binary) => context
       */
      search: (0, _reselectTree.createLeaf)(['./_'], binaries => {
        // HACK ignore link references for search
        // link references come in two forms: with underscores or all zeroes
        // the underscore format is used by Truffle to reference links by name
        // zeroes are used by solc directly, as libraries inject their own
        // address at CREATE-time
        const toRegExp = binary => new RegExp(`^${binary.replace(/__.{38}|0{40}/g, ".{40}")}`);

        let matchers = (0, _entries2.default)(binaries).map(([binary, { context }]) => ({
          context,
          regex: toRegExp(binary)
        }));

        return binary => matchers.filter(({ context, regex }) => binary.match(regex)).map(({ context }) => ({ context }))[0] || null;
      })
    }
  },

  /**
   * evm.current
   */
  current: {

    /**
     * evm.current.callstack
     */
    callstack: state => state.evm.proc.callstack,

    /**
     * evm.current.call
     */
    call: (0, _reselectTree.createLeaf)(["./callstack"], stack => stack.length ? stack[stack.length - 1] : {}),

    /**
     * evm.current.context
     */
    context: (0, _reselectTree.createLeaf)(["./call", "/info/instances", "/info/binaries/search", "/info/contexts"], ({ address, binary }, instances, search, contexts) => {
      let record;
      if (address) {
        record = instances[address];
        binary = record.binary;
      } else {
        record = search(binary);
      }

      let context = contexts[(record || {}).context];

      return (0, _extends3.default)({}, context, {
        binary
      });
    }),

    /**
     * evm.current.state
     *
     * evm state info: as of last operation, before op defined in step
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.step], step => step[param])
    }))),

    /**
     * evm.current.step
     */
    step: createStepSelectors(_selectors2.default.step, "./state")
  },

  /**
   * evm.next
   */
  next: {

    /**
     * evm.next.state
     *
     * evm state as a result of next step operation
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.next], step => step[param])
    }))),

    step: createStepSelectors(_selectors2.default.next, "./state")
  }
});

exports.default = evm;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/extends");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/assign");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prefixName = prefixName;
exports.keccak256 = keccak256;

var _utils = __webpack_require__(11);

function prefixName(prefix, fn) {
  Object.defineProperty(fn, 'name', {
    value: `${prefix}.${fn.name}`,
    configurable: true
  });

  return fn;
}

/**
 * @return 0x-prefix string of keccak256 hash
 */
function keccak256(...args) {
  return (0, _utils.toHexString)((0, _utils.keccak256)(...args));
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(3);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(4);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(9);

var _truffleSolidityUtils = __webpack_require__(50);

var _truffleSolidityUtils2 = _interopRequireDefault(_truffleSolidityUtils);

var _truffleCodeUtils = __webpack_require__(51);

var _truffleCodeUtils2 = _interopRequireDefault(_truffleCodeUtils);

var _selectors = __webpack_require__(2);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:solidity:selectors");

function getSourceRange(instruction = {}) {
  return {
    start: instruction.start || 0,
    length: instruction.length || 0,
    lines: instruction.range || {
      start: {
        line: 0, column: 0
      },
      end: {
        line: 0, column: 0
      }
    }
  };
}

let solidity = (0, _reselectTree.createSelectorTree)({
  /**
   * solidity.state
   */
  state: state => state.solidity,

  /**
   * solidity.info
   */
  info: {
    /**
     * solidity.info.sources
     */
    sources: (0, _reselectTree.createLeaf)(['/state'], state => state.info.sources.byId),

    /**
     * solidity.info.sourceMaps
     */
    sourceMaps: (0, _reselectTree.createLeaf)(['/state'], state => state.info.sourceMaps.byContext)
  },

  /**
   * solidity.current
   */
  current: {

    /**
     * solidity.current.sourceMap
     */
    sourceMap: (0, _reselectTree.createLeaf)([_selectors2.default.current.context, "/info/sourceMaps"], ({ context }, sourceMaps) => sourceMaps[context] || {}),

    /**
     * solidity.current.functionDepth
     */
    functionDepth: state => state.solidity.proc.functionDepth,

    /**
     * solidity.current.instructions
     */
    instructions: (0, _reselectTree.createLeaf)(["/info/sources", _selectors2.default.current.context, "./sourceMap"], (sources, { binary }, { sourceMap }) => {
      let instructions = _truffleCodeUtils2.default.parseCode(binary);

      if (!sourceMap) {
        // Let's create a source map to use since none exists. This source map
        // maps just as many ranges as there are instructions, and ensures every
        // instruction is marked as "jumping out". This will ensure all
        // available debugger commands step one instruction at a time.
        //
        // This is kindof a hack; perhaps this should be broken out into separate
        // context types. TODO
        sourceMap = "";
        for (var i = 0; i < instructions.length; i++) {
          sourceMap += i + ":" + i + ":1:-1;";
        }
      }

      var lineAndColumnMappings = (0, _assign2.default)({}, ...(0, _entries2.default)(sources).map(([id, { source }]) => ({
        [id]: _truffleSolidityUtils2.default.getCharacterOffsetToLineAndColumnMapping(source || "")
      })));
      var humanReadableSourceMap = _truffleSolidityUtils2.default.getHumanReadableSourceMap(sourceMap);

      let primaryFile = humanReadableSourceMap[0].file;
      debug("primaryFile %o", primaryFile);

      return instructions.map((instruction, index) => {
        // lookup source map by index and add `index` property to
        // instruction
        //

        const sourceMap = humanReadableSourceMap[index] || {};

        return {
          instruction: (0, _extends3.default)({}, instruction, { index }),
          sourceMap
        };
      }).map(({ instruction, sourceMap }) => {
        // add source map information to instruction, or defaults
        //

        const { jump, start = 0, length = 0, file = primaryFile } = sourceMap;
        const lineAndColumnMapping = lineAndColumnMappings[file] || {};
        const range = {
          start: lineAndColumnMapping[start] || { line: null, column: null },
          end: lineAndColumnMapping[start + length] || { line: null, column: null }
        };

        if (range.start.line === null) {
          debug("sourceMap %o", sourceMap);
        }

        return (0, _extends3.default)({}, instruction, {

          jump,
          start,
          length,
          file,
          range
        });
      });
    }),

    /**
     * solidity.current.instructionAtProgramCounter
     */
    instructionAtProgramCounter: (0, _reselectTree.createLeaf)(["./instructions"], instructions => {
      let map = [];
      instructions.forEach(function (instruction) {
        map[instruction.pc] = instruction;
      });

      // fill in gaps in map by defaulting to the last known instruction
      let lastSeen = null;
      for (let [pc, instruction] of map.entries()) {
        if (instruction) {
          lastSeen = instruction;
        } else {
          map[pc] = lastSeen;
        }
      }
      return map;
    }),

    /**
     * solidity.current.instruction
     */
    instruction: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors2.default.current.step.programCounter], (map, pc) => map[pc] || {}),

    /**
     * solidity.current.source
     */
    source: (0, _reselectTree.createLeaf)(["/info/sources", "./instruction"], (sources, { file: id }) => sources[id] || {}),

    /**
     * solidity.current.sourceRange
     */
    sourceRange: (0, _reselectTree.createLeaf)(["./instruction"], getSourceRange),

    /**
     * solidity.current.isSourceRangeFinal
     */
    isSourceRangeFinal: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors2.default.current.step.programCounter, _selectors2.default.next.step.programCounter], (map, current, next) => {
      if (!map[next]) {
        return true;
      }

      current = map[current];
      next = map[next];

      return current.start != next.start || current.length != next.length || current.file != next.file;
    }),

    /**
     * solidity.current.isMultiline
     */
    isMultiline: (0, _reselectTree.createLeaf)(["./sourceRange"], ({ lines }) => lines.start.line != lines.end.line),

    /**
     * solidity.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], isJump => isJump),

    /**
     * solidity.current.jumpDirection
     */
    jumpDirection: (0, _reselectTree.createLeaf)(["./instruction"], (i = {}) => i.jump || "-")
  }
});

exports.default = solidity;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/asyncToGenerator");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("web3");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("reselect-tree");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("redux-saga/effects");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MAX_WORD = exports.WORD_SIZE = undefined;

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(4);

var _assign2 = _interopRequireDefault(_assign);

exports.cleanBigNumbers = cleanBigNumbers;
exports.typeIdentifier = typeIdentifier;
exports.typeClass = typeClass;
exports.allocateDeclarations = allocateDeclarations;
exports.specifiedSize = specifiedSize;
exports.storageSize = storageSize;
exports.isMapping = isMapping;
exports.isReference = isReference;
exports.referenceType = referenceType;
exports.baseDefinition = baseDefinition;
exports.toBigNumber = toBigNumber;
exports.toSignedBigNumber = toSignedBigNumber;
exports.toHexString = toHexString;
exports.toBytes = toBytes;
exports.keccak256 = keccak256;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _bignumber = __webpack_require__(20);

var _web = __webpack_require__(8);

var _web2 = _interopRequireDefault(_web);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:data:decode:utils");

const WORD_SIZE = exports.WORD_SIZE = 0x20;
const MAX_WORD = exports.MAX_WORD = new _bignumber.BigNumber(2).pow(256).minus(1);

/**
 * recursively converts big numbers into something nicer to look at
 */
function cleanBigNumbers(value) {
  if (_bignumber.BigNumber.isBigNumber(value)) {
    return value.toNumber();
  } else if (value && value.map != undefined) {
    return value.map(inner => cleanBigNumbers(inner));
  } else if (value && typeof value == "object") {
    return (0, _assign2.default)({}, ...(0, _entries2.default)(value).map(([key, inner]) => ({ [key]: cleanBigNumbers(inner) })));
  } else {
    return value;
  }
}

function typeIdentifier(definition) {
  return definition.typeDescriptions.typeIdentifier;
}

/**
 * returns basic type class for a variable definition node
 * e.g.:
 *  `t_uint256` becomes `uint`
 *  `t_struct$_Thing_$20_memory_ptr` becomes `struct`
 */
function typeClass(definition) {
  return typeIdentifier(definition).match(/t_([^$_0-9]+)/)[1];
}

/**
 * Allocate storage for given variable declarations
 *
 * Postcondition: starts a new slot and occupies whole slots
 */
function allocateDeclarations(declarations, refs, slot = 0, index = WORD_SIZE - 1, path = []) {
  if (index < WORD_SIZE - 1) {
    // starts a new slot
    slot++;
    index = WORD_SIZE - 1;
  }

  let parentFrom = { slot, index: 0 };
  var parentTo = { slot, index: WORD_SIZE - 1 };
  let mapping = {};

  for (let declaration of declarations) {
    let { from, to, next, children } = allocateDeclaration(declaration, refs, slot, index);

    mapping[declaration.id] = { from, to, name: declaration.name };
    if (children !== undefined) {
      mapping[declaration.id].children = children;
    }

    slot = next.slot;
    index = next.index;

    parentTo = { slot: to.slot, index: WORD_SIZE - 1 };
  }

  if (index < WORD_SIZE - 1) {
    slot++;
    index = WORD_SIZE - 1;
  }

  return {
    from: parentFrom,
    to: parentTo,
    next: { slot, index },
    children: mapping
  };
}

function allocateValue(slot, index, bytes) {
  let from = index - bytes + 1 >= 0 ? { slot, index: index - bytes + 1 } : { slot: slot + 1, index: WORD_SIZE - bytes };

  let to = { slot: from.slot, index: from.index + bytes - 1 };

  let next = from.index == 0 ? { slot: from.slot + 1, index: WORD_SIZE - 1 } : { slot: from.slot, index: from.index - 1 };

  return { from, to, next };
}

function allocateDeclaration(declaration, refs, slot, index) {
  let definition = refs[declaration.id].definition;
  var byteSize = storageSize(definition); // yum

  if (typeClass(definition) == "struct") {
    let struct = refs[definition.typeName.referencedDeclaration];
    debug("struct: %O", struct);

    let result = allocateDeclarations(struct.variables || [], refs, slot, index);
    debug("struct result %o", result);
    return result;
  }

  if (typeClass(definition) == "mapping") {}

  return allocateValue(slot, index, byteSize);
}

/**
 * e.g. uint48 -> 6
 * @return size in bytes for explicit type size, or `null` if not stated
 */
function specifiedSize(definition) {
  let specified = typeIdentifier(definition).match(/t_[a-z]+([0-9]+)/);

  if (!specified) {
    return null;
  }

  let num = specified[1];

  switch (typeClass(definition)) {
    case "int":
    case "uint":
      return num / 8;

    case "bytes":
      return num;

    default:
      debug("Unknown type for size specification: %s", typeIdentifier(definition));
  }
}

function storageSize(definition) {
  switch (typeClass(definition)) {
    case "bool":
      return 1;

    case "address":
      return 20;

    case "int":
    case "uint":
      // is this a HACK? ("256" / 8)
      return typeIdentifier(definition).match(/t_[a-z]+([0-9]+)/)[1] / 8;

    case "string":
    case "bytes":
    case "array":
      return WORD_SIZE;

    case "mapping":
      // HACK just to reserve slot. mappings have no size as such
      return WORD_SIZE;
  }
}

function isMapping(definition) {
  return typeIdentifier(definition).match(/^t_mapping/) != null;
}

function isReference(definition) {
  return typeIdentifier(definition).match(/_(memory|storage)(_ptr)?$/) != null;
}

function referenceType(definition) {
  return typeIdentifier(definition).match(/_([^_]+)(_ptr)?$/)[1];
}

function baseDefinition(definition) {
  let baseIdentifier = typeIdentifier(definition)
  // first dollar sign     last dollar sign
  //   `---------.       ,---'
  .match(/^[^$]+\$_(.+)_\$[^$]+$/)[1];
  //              `----' greedy match

  // HACK - internal types for memory or storage also seem to be pointers
  if (baseIdentifier.match(/_(memory|storage)$/) != null) {
    baseIdentifier = `${baseIdentifier}_ptr`;
  }

  // another HACK - we get away with it becausewe're only using that one property
  return {
    typeDescriptions: {
      typeIdentifier: baseIdentifier
    }
  };
}

function toBigNumber(bytes) {
  if (bytes == undefined) {
    return undefined;
  } else if (typeof bytes == "string") {
    return new _bignumber.BigNumber(bytes, 16);
  } else if (typeof bytes == "number" || _bignumber.BigNumber.isBigNumber(bytes)) {
    return new _bignumber.BigNumber(bytes);
  } else if (bytes.reduce) {
    return bytes.reduce((num, byte) => num.times(0x100).plus(byte), new _bignumber.BigNumber(0));
  }
}

function toSignedBigNumber(bytes) {
  if (bytes[0] < 0b10000000) {
    // first bit is 0
    return toBigNumber(bytes);
  } else {
    return toBigNumber(bytes.map(b => 0xff - b)).plus(1).negated();
  }
}

/**
 * @param bytes - Uint8Array
 * @param length - desired byte length (pad with zeroes)
 * @param trim - omit leading zeroes
 */
function toHexString(bytes, length = 0, trim = false) {
  if (typeof length == "boolean") {
    trim = length;
    length = 0;
  }

  if (_bignumber.BigNumber.isBigNumber(bytes)) {
    bytes = toBytes(bytes);
  }

  const pad = s => `${"00".slice(0, 2 - s.length)}${s}`;

  //                                          0  1  2  3  4
  //                                 0  1  2  3  4  5  6  7
  // bytes.length:        5  -  0x(          e5 c2 aa 09 11 )
  // length (preferred):  8  -  0x( 00 00 00 e5 c2 aa 09 11 )
  //                                `--.---'
  //                                     offset 3
  if (bytes.length < length) {
    let prior = bytes;
    bytes = new Uint8Array(length);

    bytes.set(prior, length - prior.length);
  }

  debug("bytes: %o", bytes);

  let string = bytes.reduce((str, byte) => `${str}${pad(byte.toString(16))}`, "");

  if (trim) {
    string = string.replace(/^(00)+/, "");
  }

  if (string.length == 0) {
    string = "00";
  }

  return `0x${string}`;
}

function toBytes(number, length = 0) {
  if (number < 0) {
    return [];
  }

  let hex = number.toString(16);
  if (hex.length % 2 == 1) {
    hex = `0${hex}`;
  }

  let bytes = new Uint8Array(hex.match(/.{2}/g).map(byte => parseInt(byte, 16)));

  if (bytes.length < length) {
    let prior = bytes;
    bytes = new Uint8Array(length);
    bytes.set(prior, length - prior.length);
  }

  return bytes;
}

function keccak256(...args) {
  let web3 = new _web2.default();

  debug("args %o", args);

  // args = args.map( (arg) => {
  //   if (typeof arg == "number" || BigNumber.isBigNumber(arg)) {
  //     return toHexString(toBytes(arg, WORD_SIZE)).slice(2)
  //   } else if (typeof arg == "string") {
  //     return web3.utils.toHex(arg).slice(2);
  //   } else {
  //     return "";
  //   }
  // });

  // debug("processed args %o", args);

  let sha = web3.utils.soliditySha3(...args);
  debug("sha %o", sha);
  return toBigNumber(sha);
}

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("chai");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gatherArtifacts = exports.migrate = exports.compile = exports.defaultMigrations = exports.addMigrations = exports.addContracts = exports.createSandbox = exports.prepareContracts = undefined;

var _promise = __webpack_require__(23);

var _promise2 = _interopRequireDefault(_promise);

var _keys = __webpack_require__(17);

var _keys2 = _interopRequireDefault(_keys);

var _asyncToGenerator2 = __webpack_require__(7);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

let prepareContracts = exports.prepareContracts = (() => {
  var _ref = (0, _asyncToGenerator3.default)(function* (provider, sources = {}, migrations) {
    let config = yield createSandbox();

    let accounts = yield getAccounts(provider);

    config.networks["debugger"] = {
      provider: provider,
      network_id: "*",
      from: accounts[0]
    };
    config.network = "debugger";

    yield addContracts(config, sources);
    let { contracts, files } = yield compile(config);
    let contractNames = (0, _keys2.default)(contracts);

    if (!migrations) {
      migrations = yield defaultMigrations(contractNames);
    }

    yield addMigrations(config, migrations);
    yield migrate(config);

    let artifacts = yield gatherArtifacts(config);
    debug("artifacts: %o", artifacts.map(function (a) {
      return a.contractName;
    }));

    let abstractions = {};
    contractNames.forEach(function (name) {
      abstractions[name] = config.resolver.require(name);
    });

    return {
      files,
      abstractions,
      artifacts,
      config
    };
  });

  return function prepareContracts(_x) {
    return _ref.apply(this, arguments);
  };
})();

let createSandbox = exports.createSandbox = (() => {
  var _ref2 = (0, _asyncToGenerator3.default)(function* () {
    let config = yield new _promise2.default(function (accept, reject) {
      _truffleBox2.default.sandbox(function (err, result) {
        if (err) return reject(err);
        result.resolver = new _truffleResolver2.default(result);
        result.artifactor = new _truffleArtifactor2.default(result.contracts_build_directory);
        result.networks = {};

        accept(result);
      });
    });

    yield _fsExtra2.default.remove(_path2.default.join(config.contracts_directory, "MetaCoin.sol"));
    yield _fsExtra2.default.remove(_path2.default.join(config.contracts_directory, "ConvertLib.sol"));
    yield _fsExtra2.default.remove(_path2.default.join(config.migrations_directory, "2_deploy_contracts.js"));

    return config;
  });

  return function createSandbox() {
    return _ref2.apply(this, arguments);
  };
})();

let addContracts = exports.addContracts = (() => {
  var _ref3 = (0, _asyncToGenerator3.default)(function* (config, sources = {}) {
    let promises = [];
    for (let filename of (0, _keys2.default)(sources)) {
      let source = sources[filename];
      promises.push(_fsExtra2.default.outputFile(_path2.default.join(config.contracts_directory, filename), source));
    }

    return yield _promise2.default.all(promises);
  });

  return function addContracts(_x2) {
    return _ref3.apply(this, arguments);
  };
})();

let addMigrations = exports.addMigrations = (() => {
  var _ref4 = (0, _asyncToGenerator3.default)(function* (config, migrations = {}) {
    let promises = [];
    for (let filename of (0, _keys2.default)(migrations)) {
      let source = migrations[filename];
      promises.push(_fsExtra2.default.outputFile(_path2.default.join(config.migrations_directory, filename), source));
    }

    return yield _promise2.default.all(promises);
  });

  return function addMigrations(_x3) {
    return _ref4.apply(this, arguments);
  };
})();

let defaultMigrations = exports.defaultMigrations = (() => {
  var _ref5 = (0, _asyncToGenerator3.default)(function* (contractNames) {
    contractNames = contractNames.filter(function (name) {
      return name != "Migrations";
    });

    let migrations = {};

    contractNames.forEach(function (contractName, i) {
      let index = i + 2; // start at 2 cause Migrations migration
      let filename = `${index}_migrate_${contractName}.js`;
      let source = `
      var ${contractName} = artifacts.require("${contractName}");

      module.exports = function(deployer) {
        deployer.deploy(${contractName});
      };
    `;

      migrations[filename] = source;
    });

    return migrations;
  });

  return function defaultMigrations(_x4) {
    return _ref5.apply(this, arguments);
  };
})();

let compile = exports.compile = (() => {
  var _ref6 = (0, _asyncToGenerator3.default)(function* (config) {
    return new _promise2.default(function (accept, reject) {
      _truffleWorkflowCompile2.default.compile(config.with({
        all: true,
        quiet: true
      }), function (err, contracts, files) {
        if (err) return reject(err);
        return accept({ contracts, files });
      });
    });
  });

  return function compile(_x5) {
    return _ref6.apply(this, arguments);
  };
})();

let migrate = exports.migrate = (() => {
  var _ref7 = (0, _asyncToGenerator3.default)(function* (config) {
    return new _promise2.default(function (accept, reject) {
      _truffleMigrate2.default.run(config.with({
        quiet: true
      }), function (err, contracts) {
        if (err) return reject(err);
        accept(contracts);
      });
    });
  });

  return function migrate(_x6) {
    return _ref7.apply(this, arguments);
  };
})();

let gatherArtifacts = exports.gatherArtifacts = (() => {
  var _ref8 = (0, _asyncToGenerator3.default)(function* (config) {
    return _truffleDebugUtils2.default.gatherArtifacts(config);
  });

  return function gatherArtifacts(_x7) {
    return _ref8.apply(this, arguments);
  };
})();

exports.getAccounts = getAccounts;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _path = __webpack_require__(39);

var _path2 = _interopRequireDefault(_path);

var _fsExtra = __webpack_require__(40);

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _async = __webpack_require__(41);

var _async2 = _interopRequireDefault(_async);

var _truffleWorkflowCompile = __webpack_require__(42);

var _truffleWorkflowCompile2 = _interopRequireDefault(_truffleWorkflowCompile);

var _truffleDebugUtils = __webpack_require__(43);

var _truffleDebugUtils2 = _interopRequireDefault(_truffleDebugUtils);

var _truffleArtifactor = __webpack_require__(44);

var _truffleArtifactor2 = _interopRequireDefault(_truffleArtifactor);

var _web = __webpack_require__(8);

var _web2 = _interopRequireDefault(_web);

var _truffleMigrate = __webpack_require__(45);

var _truffleMigrate2 = _interopRequireDefault(_truffleMigrate);

var _truffleBox = __webpack_require__(46);

var _truffleBox2 = _interopRequireDefault(_truffleBox);

var _truffleResolver = __webpack_require__(47);

var _truffleResolver2 = _interopRequireDefault(_truffleResolver);

var _truffleExpect = __webpack_require__(27);

var _truffleExpect2 = _interopRequireDefault(_truffleExpect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("test:helpers");

function getAccounts(provider) {
  let web3 = new _web2.default(provider);
  return new _promise2.default(function (accept, reject) {
    web3.eth.getAccounts(function (err, accounts) {
      if (err) return reject(err);
      accept(accounts);
    });
  });
}

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(9);

var _jsonPointer = __webpack_require__(24);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _selectors = __webpack_require__(6);

var _selectors2 = _interopRequireDefault(_selectors);

var _map = __webpack_require__(28);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:ast:selectors");

/**
 * ast
 */
const ast = (0, _reselectTree.createSelectorTree)({
  /**
   * ast.views
   */
  views: {
    /**
     * ast.views.sources
     */
    sources: (0, _reselectTree.createLeaf)([_selectors2.default.info.sources], sources => sources)
  },

  /**
   * ast.current
   */
  current: {

    /**
     * ast.current.tree
     *
     * ast for current source
     */
    tree: (0, _reselectTree.createLeaf)([_selectors2.default.current.source], ({ ast }) => ast),

    /**
     * ast.current.index
     *
     * source ID
     */
    index: (0, _reselectTree.createLeaf)([_selectors2.default.current.source], ({ id }) => id),

    /**
     * ast.current.pointer
     *
     * jsonpointer for current ast node
     */
    pointer: (0, _reselectTree.createLeaf)(["./tree", _selectors2.default.current.sourceRange], (ast, range) => (0, _map.findRange)(ast, range.start, range.length)),

    /**
     * ast.current.node
     *
     * current ast node to execute
     */
    node: (0, _reselectTree.createLeaf)(["./tree", "./pointer"], (ast, pointer) => pointer ? _jsonPointer2.default.get(ast, pointer) : _jsonPointer2.default.get(ast, ""))

  }
});

exports.default = ast;

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("redux");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("ganache-cli");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/keys");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator2 = __webpack_require__(7);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _truffleExpect = __webpack_require__(27);

var _truffleExpect2 = _interopRequireDefault(_truffleExpect);

var _session = __webpack_require__(48);

var _session2 = _interopRequireDefault(_session);

var _reselectTree = __webpack_require__(9);

var _selectors = __webpack_require__(26);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(14);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(19);

var _selectors6 = _interopRequireDefault(_selectors5);

var _selectors7 = __webpack_require__(2);

var _selectors8 = _interopRequireDefault(_selectors7);

var _selectors9 = __webpack_require__(6);

var _selectors10 = _interopRequireDefault(_selectors9);

var _selectors11 = __webpack_require__(35);

var _selectors12 = _interopRequireDefault(_selectors11);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger");

/**
 * @example
 * let session = Debugger
 *   .forTx(<txHash>, {
 *     contracts: [<contract obj>, ...],
 *     provider: <provider instance>
 *   })
 *   .connect();
 */
class Debugger {
  /**
   * @param {Session} session - debugger session
   * @private
   */
  constructor(session) {
    /**
     * @private
     */
    this._session = session;
  }

  /**
   * Instantiates a Debugger for a given transaction hash.
   *
   * @param {String} txHash - transaction hash with leading "0x"
   * @param {{contracts: Array<Contract>, files: Array<String>, provider: Web3Provider}} options -
   * @return {Debugger} instance
   */
  static forTx(txHash, options = {}) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _truffleExpect2.default.options(options, ["contracts", "provider"]);

      let session = new _session2.default(options.contracts, options.files, txHash, options.provider);

      try {
        yield session.ready();
      } catch (e) {
        throw e;
      }

      return new _this(session);
    })();
  }

  /**
   * Connects to the instantiated Debugger.
   *
   * @return {Session} session instance
   */
  connect() {
    return this._session;
  }

  /**
   * Exported selectors
   *
   * See individual selector docs for full listing
   *
   * @example
   * Debugger.selectors.ast.current.tree
   *
   * @example
   * Debugger.selectors.solidity.current.instruction
   *
   * @example
   * Debugger.selectors.trace.steps
   */
  static get selectors() {
    return (0, _reselectTree.createNestedSelector)({
      ast: _selectors4.default,
      data: _selectors2.default,
      trace: _selectors6.default,
      evm: _selectors8.default,
      solidity: _selectors10.default,
      session: _selectors12.default
    });
  }
}

exports.default = Debugger; /**
                             * @typedef {Object} Contract
                             * @property {string} contractName contract name
                             * @property {string} source solidity source code
                             * @property {string} sourcePath path to source file
                             * @property {string} binary 0x-prefixed hex string with create bytecode
                             * @property {string} sourceMap solidity source map for create bytecode
                             * @property {Object} ast Abstract Syntax Tree from Solidity
                             * @property {string} deployedBinary 0x-prefixed compiled binary (on chain)
                             * @property {string} deployedSourceMap solidity source map for on-chain bytecode
                             */

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reselectTree = __webpack_require__(9);

let trace = (0, _reselectTree.createSelectorTree)({
  /**
   * trace.index
   *
   * current step index
   */
  index: state => state.trace.proc.index,

  /**
   * trace.steps
   *
   * all trace steps
   */
  steps: state => state.trace.info.steps,

  /**
   * trace.stepsRemaining
   *
   * number of steps remaining in trace
   */
  stepsRemaining: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps.length - index),

  /**
   * trace.step
   *
   * current trace step
   */
  step: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps[index]),

  /**
   * trace.next
   *
   * next trace step or {}
   */
  next: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => index < steps.length - 1 ? steps[index + 1] : {})
});

exports.default = trace;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("bignumber.js");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saveSteps = saveSteps;
exports.receiveAddresses = receiveAddresses;
exports.next = next;
exports.tick = tick;
exports.tock = tock;
exports.endTrace = endTrace;
const SAVE_STEPS = exports.SAVE_STEPS = "SAVE_STEPS";
function saveSteps(steps) {
  return {
    type: SAVE_STEPS,
    steps
  };
}

const RECEIVE_ADDRESSES = exports.RECEIVE_ADDRESSES = "RECEIVE_ADDRESSES";
function receiveAddresses(addresses) {
  return {
    type: RECEIVE_ADDRESSES,
    addresses
  };
}

const NEXT = exports.NEXT = "NEXT";
function next() {
  return { type: NEXT };
}

const TICK = exports.TICK = "TICK";
function tick() {
  return { type: TICK };
}

const TOCK = exports.TOCK = "TOCK";
function tock() {
  return { type: TOCK };
}

const END_OF_TRACE = exports.END_OF_TRACE = "EOT";
function endTrace() {
  return { type: END_OF_TRACE };
}

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/set");

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/promise");

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = require("json-pointer");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.start = start;
exports.ready = ready;
exports.error = error;
exports.finish = finish;
exports.recordContracts = recordContracts;
const START = exports.START = "SESSION_START";
function start(txHash, provider) {
  return {
    type: START,
    txHash, provider
  };
}

const READY = exports.READY = "SESSION_READY";
function ready() {
  return {
    type: READY
  };
}

const ERROR = exports.ERROR = "SESSION_ERROR";
function error(error) {
  return {
    type: ERROR,
    error
  };
}

const FINISH = exports.FINISH = "SESSION_FINISH";
function finish() {
  return {
    type: FINISH
  };
}

const RECORD_CONTRACTS = exports.RECORD_CONTRACTS = "RECORD_CONTRACTS";
function recordContracts(contexts, sources) {
  return {
    type: RECORD_CONTRACTS,
    contexts, sources
  };
}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(3);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(4);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(9);

var _jsonPointer = __webpack_require__(24);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _selectors = __webpack_require__(14);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(2);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(6);

var _selectors6 = _interopRequireDefault(_selectors5);

var _decode = __webpack_require__(61);

var _decode2 = _interopRequireDefault(_decode);

var _utils = __webpack_require__(11);

var decodeUtils = _interopRequireWildcard(_utils);

var _bignumber = __webpack_require__(20);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:data:selectors");

function createStateSelectors({ stack, memory, storage }) {
  return {
    /**
     * .stack
     */
    stack: (0, _reselectTree.createLeaf)([stack], words => (words || []).map(word => decodeUtils.toBytes(decodeUtils.toBigNumber(word, decodeUtils.WORD_SIZE)))),

    /**
     * .memory
     */
    memory: (0, _reselectTree.createLeaf)([memory], words => new Uint8Array((words.join("").match(/.{1,2}/g) || []).map(byte => parseInt(byte, 16)))),

    /**
     * .storage
     */
    storage: (0, _reselectTree.createLeaf)([storage], mapping => (0, _assign2.default)({}, ...(0, _entries2.default)(mapping).map(([address, word]) => ({
      [`0x${address}`]: new Uint8Array((word.match(/.{1,2}/g) || []).map(byte => parseInt(byte, 16)))
    }))))
  };
}

const data = (0, _reselectTree.createSelectorTree)({
  state: state => state.data,

  /**
   * data.views
   */
  views: {
    ast: (0, _reselectTree.createLeaf)([_selectors2.default.current], tree => tree),

    atLastInstructionForSourceRange: (0, _reselectTree.createLeaf)([_selectors6.default.current.isSourceRangeFinal], final => final),

    /**
     * data.views.scopes
     */
    scopes: {

      /**
       * data.views.scopes.inlined
       */
      inlined: (0, _reselectTree.createLeaf)(["/info/scopes", _selectors6.default.info.sources], (scopes, sources) => (0, _assign2.default)({}, ...(0, _entries2.default)(scopes).map(([id, entry]) => ({
        [id]: (0, _extends3.default)({}, entry, {

          definition: _jsonPointer2.default.get(sources[entry.sourceId].ast, entry.pointer)
        })
      }))))
    },

    /**
     * data.views.decoder
     *
     * selector returns (ast node definition, data reference) => value
     */
    decoder: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "/next/state"], (scopes, state) => {
      return (definition, ref) => (0, _decode2.default)(definition, ref, state, scopes);
    })
  },

  /**
   * data.info
   */
  info: {

    /**
     * data.info.scopes
     */
    scopes: (0, _reselectTree.createLeaf)(["/state"], state => state.info.scopes.byId)
  },

  /**
   * data.proc
   */
  proc: {

    /**
     * data.proc.assignments
     */
    assignments: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.assignments.byId)
  },

  /**
   * data.current
   */
  current: {
    /**
     *
     * data.current.scope
     */
    scope: {

      /**
       * data.current.scope.id
       */
      id: (0, _reselectTree.createLeaf)([_selectors2.default.current.node], node => node.id)
    },

    /**
     * data.current.state
     */
    state: createStateSelectors(_selectors4.default.current.state),

    /**
     * data.current.identifiers (namespace)
     */
    identifiers: {

      /**
       * data.current.identifiers (selector)
       *
       * returns identifers and corresponding definition node ID
       */
      _: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "/current/scope"], (scopes, scope) => {
        let cur = scope.id;
        let variables = {};

        do {
          variables = (0, _assign2.default)(variables, ...(scopes[cur].variables || []).filter(v => variables[v.name] == undefined).map(v => ({ [v.name]: v.id })));

          cur = scopes[cur].parentId;
        } while (cur != null);

        return variables;
      }),

      /**
       * data.current.identifiers.definitions
       *
       * current variable definitions
       */
      definitions: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "./_"], (scopes, identifiers) => (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, id]) => {
        let { definition } = scopes[id];

        return { [identifier]: definition };
      }))),

      /**
       * data.current.identifiers.refs
       *
       * current variables' value refs
       */
      refs: (0, _reselectTree.createLeaf)(["/proc/assignments", "./_"], (assignments, identifiers) => (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, id]) => {
        let { ref } = assignments[id] || {};
        if (!ref) {
          return undefined;
        };

        return {
          [identifier]: ref
        };
      }))),

      decoded: (0, _reselectTree.createLeaf)(["/views/decoder", "./definitions", "./refs"], (decode, definitions, refs) => (0, _assign2.default)({}, ...(0, _entries2.default)(refs).map(([identifier, ref]) => ({
        [identifier]: decode(definitions[identifier], ref)
      })))),

      native: (0, _reselectTree.createLeaf)(['./decoded'], decodeUtils.cleanBigNumbers)
    }
  },

  /**
   * data.next
   */
  next: {

    /**
     * data.next.state
     */
    state: createStateSelectors(_selectors4.default.next.state)
  }
});

exports.default = data;

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = require("truffle-expect");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(17);

var _keys2 = _interopRequireDefault(_keys);

exports.getRange = getRange;
exports.rangeNodes = rangeNodes;
exports.findRange = findRange;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _nodeIntervalTree = __webpack_require__(52);

var _nodeIntervalTree2 = _interopRequireDefault(_nodeIntervalTree);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:ast:map");

/**
 * @private
 */
function getRange(node) {
  // src: "<start>:<length>:<_>"
  // returns [start, end]
  let [start, length] = node.src.split(":").slice(0, 2).map(i => parseInt(i));

  return [start, start + length];
}

/**
 * @private
 */
function rangeNodes(node, pointer = "") {
  if (node instanceof Array) {
    return [].concat(...node.map((sub, i) => rangeNodes(sub, `${pointer}/${i}`)));
  } else if (node instanceof Object) {
    let results = [];

    if (node.src) {
      results.push({ pointer, range: getRange(node) });
    }

    return results.concat(...(0, _keys2.default)(node).map(key => rangeNodes(node[key], `${pointer}/${key}`)));
  } else {
    return [];
  }
}

/**
 * @private
 */
function findRange(node, sourceStart, sourceLength) {
  let ranges = rangeNodes(node);
  let tree = new _nodeIntervalTree2.default();

  ranges.forEach(({ range, pointer }) => {
    let [start, end] = range;

    tree.insert(start, end, { range, pointer });
  });

  let sourceEnd = sourceStart + sourceLength;

  let overlapping = tree.search(sourceStart, sourceEnd);

  // find nodes that fully contain requested range,
  // return longest pointer
  return overlapping.filter(({ range }) => sourceStart >= range[0] && sourceEnd <= range[1]).map(({ pointer }) => pointer).reduce((a, b) => a.length > b.length ? a : b, "");
}

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.beginStep = beginStep;
exports.advance = advance;
exports.stepNext = stepNext;
exports.stepOver = stepOver;
exports.stepInto = stepInto;
exports.stepOut = stepOut;
exports.interrupt = interrupt;
exports.continueUntil = continueUntil;
const BEGIN_STEP = exports.BEGIN_STEP = "BEGIN_STEP";
function beginStep(type) {
  return {
    type: BEGIN_STEP,
    stepType: type
  };
}

const ADVANCE = exports.ADVANCE = "ADVANCE";
function advance() {
  return { type: ADVANCE };
}

const STEP_NEXT = exports.STEP_NEXT = "STEP_NEXT";
function stepNext() {
  return { type: STEP_NEXT };
}

const STEP_OVER = exports.STEP_OVER = "STEP_OVER";
function stepOver() {
  return { type: STEP_OVER };
}

const STEP_INTO = exports.STEP_INTO = "STEP_INTO";
function stepInto() {
  return { type: STEP_INTO };
}

const STEP_OUT = exports.STEP_OUT = "STEP_OUT";
function stepOut() {
  return { type: STEP_OUT };
}

const INTERRUPT = exports.INTERRUPT = "INTERRUPT";
function interrupt() {
  return { type: INTERRUPT };
}

const CONTINUE_UNTIL = exports.CONTINUE_UNTIL = "CONTINUE_UNTIL";
function continueUntil(...breakpoints) {
  return {
    type: CONTINUE_UNTIL,
    breakpoints
  };
}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(22);

var _set2 = _interopRequireDefault(_set);

var _extends2 = __webpack_require__(3);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(4);

var _assign2 = _interopRequireDefault(_assign);

exports.scope = scope;
exports.declare = declare;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(10);

var _jsonPointer = __webpack_require__(24);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _helpers = __webpack_require__(5);

var _actions = __webpack_require__(21);

var _actions2 = __webpack_require__(31);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(26);

var _selectors2 = _interopRequireDefault(_selectors);

var _utils = __webpack_require__(11);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:data:sagas");

function* scope(nodeId, pointer, parentId, sourceId) {
  yield (0, _effects.put)(actions.scope(nodeId, pointer, parentId, sourceId));
}

function* declare(node) {
  yield (0, _effects.put)(actions.declare(node));
}

function* tickSaga() {
  let {
    tree,
    id: treeId,
    node,
    pointer
  } = yield (0, _effects.select)(_selectors2.default.views.ast);

  let decode = yield (0, _effects.select)(_selectors2.default.views.decoder);
  let scopes = yield (0, _effects.select)(_selectors2.default.info.scopes);
  let definitions = yield (0, _effects.select)(_selectors2.default.views.scopes.inlined);
  let currentAssignments = yield (0, _effects.select)(_selectors2.default.proc.assignments);

  let stack = yield (0, _effects.select)(_selectors2.default.next.state.stack);
  if (!stack) {
    return;
  }

  let top = stack.length - 1;
  var parameters, returnParameters, assignments, storageVars;

  if (!node) {
    return;
  }

  // stack is only ready for interpretation after the last step of each
  // source range
  //
  // the data module always looks at the result of a particular opcode
  // (i.e., the following trace step's stack/memory/storage), so this
  // asserts that the _current_ operation is the final one before
  // proceeding
  if (!(yield (0, _effects.select)(_selectors2.default.views.atLastInstructionForSourceRange))) {
    return;
  }

  switch (node.nodeType) {

    case "FunctionDefinition":
      parameters = node.parameters.parameters.map((p, i) => `${pointer}/parameters/parameters/${i}`);

      returnParameters = node.returnParameters.parameters.map((p, i) => `${pointer}/returnParameters/parameters/${i}`);

      assignments = returnParameters.concat(parameters).reverse().map(pointer => _jsonPointer2.default.get(tree, pointer).id).map((id, i) => ({ [id]: { "stack": top - i } })).reduce((acc, assignment) => (0, _assign2.default)(acc, assignment), {});

      yield (0, _effects.put)(actions.assign(treeId, assignments));
      break;

    case "ContractDefinition":
      let storageVars = scopes[node.id].variables || [];
      let slot = 0;
      let index = _utils.WORD_SIZE - 1; // cause lower-order
      debug("storage vars %o", storageVars);

      let allocation = utils.allocateDeclarations(storageVars, definitions);
      assignments = (0, _assign2.default)({}, ...(0, _entries2.default)(allocation.children).map(([id, storage]) => ({
        [id]: (0, _extends3.default)({}, (currentAssignments[id] || { ref: {} }).ref, {
          storage
        })
      })));
      debug("assignments %O", assignments);

      yield (0, _effects.put)(actions.assign(treeId, assignments));
      break;

    case "VariableDeclaration":
      yield (0, _effects.put)(actions.assign(treeId, {
        [_jsonPointer2.default.get(tree, pointer).id]: { "stack": top }
      }));
      break;

    case "IndexAccess":
      // to track `mapping` types known indexes
      let {
        baseExpression: {
          id: baseId,
          referencedDeclaration: baseDeclarationId
        },
        indexExpression: {
          id: indexId
        }
      } = node;

      let baseAssignment = (currentAssignments[baseDeclarationId] || {
        ref: {}
      }).ref;
      debug("baseAssignment %O", baseAssignment);

      let baseDefinition = definitions[baseDeclarationId].definition;
      if (utils.typeClass(baseDefinition) !== "mapping") {
        break;
      }

      const indexAssignment = (currentAssignments[indexId] || {}).ref;
      const indexValue = indexAssignment ? decode(node.indexExpression, indexAssignment) : utils.toBytes(node.indexExpression.hexValue);

      debug("index value %O", indexValue);
      if (indexValue == undefined) {
        break;
      }

      assignments = {
        [baseDeclarationId]: (0, _extends3.default)({}, baseAssignment, {
          keys: [...new _set2.default([...(baseAssignment.keys || []), indexValue])]
        })
      };

      debug("mapping assignments %O", assignments);
      yield (0, _effects.put)(actions.assign(treeId, assignments));
      debug("new assignments %O", (yield (0, _effects.select)(_selectors2.default.proc.assignments)));
      break;

    case "Assignment":
      break;

    default:
      if (node.typeDescriptions == undefined) {
        break;
      }

      debug("decoding expression value %O", node.typeDescriptions);
      let literal = decode(node, { "stack": top });

      yield (0, _effects.put)(actions.assign(treeId, {
        [node.id]: { literal }
      }));
      break;
  }
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions.TICK, function* () {
    try {
      yield* tickSaga();
    } catch (e) {
      debug(e);
    }
  });
}

exports.default = (0, _helpers.prefixName)("data", saga);

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scope = scope;
exports.declare = declare;
exports.assign = assign;
const SCOPE = exports.SCOPE = "SCOPE";
function scope(id, pointer, parentId, sourceId) {
  return {
    type: SCOPE,
    id, pointer, parentId, sourceId
  };
}

const DECLARE = exports.DECLARE = "DECLARE_VARIABLE";
function declare(node) {
  return {
    type: DECLARE,
    node
  };
}

const ASSIGN = exports.ASSIGN = "ASSIGN";
function assign(context, assignments) {
  return {
    type: ASSIGN,
    context, assignments
  };
}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(22);

var _set2 = _interopRequireDefault(_set);

exports.advance = advance;
exports.wait = wait;
exports.processTrace = processTrace;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(10);

var _helpers = __webpack_require__(5);

var _actions = __webpack_require__(21);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(19);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:trace:sagas");

function* waitForTrace() {
  let { steps } = yield (0, _effects.take)(actions.SAVE_STEPS);

  let addresses = [...new _set2.default(steps.filter(({ op }) => op == "CALL" || op == "DELEGATECALL").map(({ stack }) => "0x" + stack[stack.length - 2].substring(24)))];

  yield (0, _effects.put)(actions.receiveAddresses(addresses));
}

function* advance() {
  yield (0, _effects.put)(actions.next());

  yield (0, _effects.take)(actions.TOCK);
}

function* next() {
  let remaining = yield (0, _effects.select)(_selectors2.default.stepsRemaining);
  debug("remaining: %o", remaining);
  let steps = yield (0, _effects.select)(_selectors2.default.steps);
  debug("total steps: %o", steps.length);

  if (remaining > 0) {
    debug("putting TICK");
    // updates state for current step
    yield (0, _effects.put)(actions.tick());
    debug("put TICK");

    remaining--; // local update, just for convenience
  }

  if (remaining) {
    debug("putting TOCK");
    // updates step to next step in trace
    yield (0, _effects.put)(actions.tock());
    debug("put TOCK");
  } else {

    yield (0, _effects.put)(actions.endTrace());
  }
}

function* wait() {
  yield (0, _effects.take)(actions.END_OF_TRACE);
}

function* processTrace(trace) {
  yield (0, _effects.put)(actions.saveSteps(trace));

  let { addresses } = yield (0, _effects.take)(actions.RECEIVE_ADDRESSES);
  debug("received addresses");

  return addresses;
}

function* saga() {
  // wait for trace to be defined
  yield* waitForTrace();

  yield (0, _effects.takeEvery)(actions.NEXT, next);
}

exports.default = (0, _helpers.prefixName)("trace", saga);

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.addSourceMap = addSourceMap;
exports.jump = jump;
const ADD_SOURCE = exports.ADD_SOURCE = "SOLIDITY_ADD_SOURCE";
function addSource(source, sourcePath, ast) {
  return {
    type: ADD_SOURCE,
    source, sourcePath, ast
  };
}

const ADD_SOURCEMAP = exports.ADD_SOURCEMAP = "SOLIDITY_ADD_SOURCEMAP";
function addSourceMap(binary, sourceMap) {
  return {
    type: ADD_SOURCEMAP,
    binary, sourceMap
  };
}

const JUMP = exports.JUMP = "JUMP";
function jump(jumpDirection) {
  return {
    type: JUMP,
    jumpDirection
  };
}

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.addInstance = addInstance;
exports.call = call;
exports.create = create;
exports.returnCall = returnCall;
const ADD_CONTEXT = exports.ADD_CONTEXT = "EVM_ADD_CONTEXT";
function addContext(contractName, binary) {
  return {
    type: ADD_CONTEXT,
    contractName, binary
  };
}

const ADD_INSTANCE = exports.ADD_INSTANCE = "EVM_ADD_INSTANCE";
function addInstance(address, context, binary) {
  return {
    type: ADD_INSTANCE,
    address, context, binary
  };
}

const CALL = exports.CALL = "CALL";
function call(address) {
  return {
    type: CALL,
    address
  };
}

const CREATE = exports.CREATE = "CREATE";
function create(binary) {
  return {
    type: CREATE,
    binary
  };
}

const RETURN = exports.RETURN = "RETURN";
function returnCall() {
  return {
    type: RETURN
  };
}

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(4);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(9);

var _selectors = __webpack_require__(2);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(6);

var _selectors4 = _interopRequireDefault(_selectors3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:session:selectors");

const session = (0, _reselectTree.createSelectorTree)({
  /**
   * session.info
   */
  info: {

    /**
     * session.info.affectedInstances
     */
    affectedInstances: (0, _reselectTree.createLeaf)([_selectors2.default.info.instances, _selectors2.default.info.contexts, _selectors4.default.info.sources, _selectors4.default.info.sourceMaps], (instances, contexts, sources, sourceMaps) => (0, _assign2.default)({}, ...(0, _entries2.default)(instances).map(([address, { context }]) => {
      let { contractName, binary } = contexts[context];
      let { sourceMap } = sourceMaps[context];

      let { source } = sourceMap ?
      // look for source ID between second and third colons (HACK)
      sources[sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]] : {};

      return {
        [address]: {
          contractName, source, binary
        }
      };
    })))
  }
});

exports.default = session;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator2 = __webpack_require__(7);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

let prepareDebugger = (() => {
  var _ref2 = (0, _asyncToGenerator3.default)(function* (testName, sources) {
    const provider = _ganacheCli2.default.provider({ seed: "debugger", gasLimit: 7000000 });
    const web3 = new _web2.default(provider);

    let { abstractions, artifacts: contracts, files } = yield (0, _helpers.prepareContracts)(provider, sources);

    let instance = yield abstractions[contractName(testName)].deployed();
    let receipt = yield instance.run();
    let txHash = receipt.tx;

    let bugger = yield _debugger2.default.forTx(txHash, { provider, files, contracts });

    let session = bugger.connect();

    let breakpoint = {
      address: instance.address,
      line: lastStatementLine(sources[fileName(testName)])
    };

    session.continueUntil(breakpoint);

    return session;
  });

  return function prepareDebugger(_x, _x2) {
    return _ref2.apply(this, arguments);
  };
})();

let getDecode = (() => {
  var _ref3 = (0, _asyncToGenerator3.default)(function* (session) {
    const definitions = session.view(_selectors2.default.current.identifiers.definitions);
    const refs = session.view(_selectors2.default.current.identifiers.refs);

    const decode = session.view(_selectors2.default.views.decoder);
    return function (name) {
      return (0, _utils.cleanBigNumbers)(decode(definitions[name], refs[name]));
    };
  });

  return function getDecode(_x3) {
    return _ref3.apply(this, arguments);
  };
})();

exports.generateUints = generateUints;
exports.describeDecoding = describeDecoding;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _ganacheCli = __webpack_require__(16);

var _ganacheCli2 = _interopRequireDefault(_ganacheCli);

var _web = __webpack_require__(8);

var _web2 = _interopRequireDefault(_web);

var _chai = __webpack_require__(12);

var _changeCase = __webpack_require__(82);

var _changeCase2 = _interopRequireDefault(_changeCase);

var _helpers = __webpack_require__(13);

var _debugger = __webpack_require__(18);

var _debugger2 = _interopRequireDefault(_debugger);

var _utils = __webpack_require__(11);

var _selectors = __webpack_require__(26);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(2);

var _selectors4 = _interopRequireDefault(_selectors3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("test:data:decode");

function* generateUints() {
  let x = 0;
  while (true) {
    yield x;
    x++;
  }
}

function contractName(testName) {
  return testName.replace(/ /g, "");
}

function fileName(testName) {
  return `${contractName(testName)}.sol`;
}

function generateTests(fixtures) {
  for (let _ref of fixtures) {
    let { name, value: expected } = _ref;

    it(`correctly decodes ${name}`, () => {
      _chai.assert.deepEqual(this.decode(name), expected);
    });
  }
}

function lastStatementLine(source) {
  const lines = source.split("\n");
  for (let i = lines.length - 1; i >= 0; i--) {
    let line = lines[i];
    if (line.indexOf(";") != -1) {
      return i;
    }
  }
}

function describeDecoding(testName, fixtures, selector, generateSource) {
  const sources = {
    [fileName(testName)]: generateSource(contractName(testName), fixtures)
  };

  describe(testName, function () {
    var _this = this;

    const testDebug = (0, _debug2.default)(`test:data:decode:${_changeCase2.default.paramCase(testName)}`);

    this.timeout(30000);

    before("runs and observes debugger", (0, _asyncToGenerator3.default)(function* () {
      const session = yield prepareDebugger(testName, sources);
      _this.decode = yield getDecode(session);

      testDebug("storage %O", session.view(_selectors4.default.current.state.storage));

      if (selector) {
        debug("selector %O", session.view(selector));
      }
    }));

    generateTests.bind(this)(fixtures);
  });
}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

// runtime helper
function inManifest(id) { return global.__webpackManifest__.indexOf(id) >= 0;}
function run(id) { __webpack_require__(id);}

// modules to execute goes here
var ids = [
/*require.resolve*/(38),/*require.resolve*/(78),/*require.resolve*/(79),/*require.resolve*/(36),/*require.resolve*/(83),/*require.resolve*/(84),/*require.resolve*/(13),/*require.resolve*/(85)
];

ids.filter(inManifest).forEach(run)

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _asyncToGenerator2 = __webpack_require__(7);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _chai = __webpack_require__(12);

var _ganacheCli = __webpack_require__(16);

var _ganacheCli2 = _interopRequireDefault(_ganacheCli);

var _web = __webpack_require__(8);

var _web2 = _interopRequireDefault(_web);

var _helpers = __webpack_require__(13);

var _debugger = __webpack_require__(18);

var _debugger2 = _interopRequireDefault(_debugger);

var _selectors = __webpack_require__(14);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(6);

var _selectors4 = _interopRequireDefault(_selectors3);

var _map = __webpack_require__(28);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("test:ast");

const __VARIABLES = `
pragma solidity ^0.4.18;

contract Variables {
  event Result(uint256 result);

  uint256 qux;
  string quux;

  function stack(uint256 foo) public returns (uint256) {
    uint256 bar = foo + 1;
    uint256 baz = innerStack(bar);

    baz += 4;

    qux = baz;

    Result(baz);

    return baz;
  }

  function innerStack(uint256 baz) public returns (uint256) {
    uint256 bar = baz + 2;
    return bar;
  }
}
`;

let sources = {
  "Variables.sol": __VARIABLES
};

describe("AST", function () {
  var provider;
  var web3;

  var abstractions;
  var artifacts;
  var files;

  before("Create Provider", (0, _asyncToGenerator3.default)(function* () {
    provider = _ganacheCli2.default.provider({ seed: "debugger", gasLimit: 7000000 });
    web3 = new _web2.default(provider);
  }));

  before("Prepare contracts and artifacts", (0, _asyncToGenerator3.default)(function* () {
    this.timeout(30000);

    let prepared = yield (0, _helpers.prepareContracts)(provider, sources);
    abstractions = prepared.abstractions;
    artifacts = prepared.artifacts;
    files = prepared.files;
  }));

  describe("Node pointer", function () {
    it("traverses", (0, _asyncToGenerator3.default)(function* () {
      this.timeout(0);
      let instance = yield abstractions.Variables.deployed();
      let receipt = yield instance.stack(4);
      let txHash = receipt.tx;

      let bugger = yield _debugger2.default.forTx(txHash, {
        provider,
        files,
        contracts: artifacts
      });

      let session = bugger.connect();
      debug("ast: %O", session.view(_selectors2.default.current.tree));

      do {
        let { start, length } = session.view(_selectors4.default.current.sourceRange);
        let end = start + length;

        let node = session.view(_selectors2.default.current.node);

        let [nodeStart, nodeLength] = (0, _map.getRange)(node);
        let nodeEnd = nodeStart + nodeLength;

        let pointer = session.view(_selectors2.default.current.pointer);

        _chai.assert.isAtMost(nodeStart, start, `Node ${pointer} at should not begin after instruction source range`);
        _chai.assert.isAtLeast(nodeEnd, end, `Node ${pointer} should not end after source`);

        session.stepNext();
      } while (!session.finished);
    }));
  });
});

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = require("fs-extra");

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("async");

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = require("truffle-workflow-compile");

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = require("truffle-debug-utils");

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = require("truffle-artifactor");

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = require("truffle-migrate");

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = require("truffle-box");

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = require("truffle-resolver");

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = __webpack_require__(49);

var _values2 = _interopRequireDefault(_values);

var _promise = __webpack_require__(23);

var _promise2 = _interopRequireDefault(_promise);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _selectors = __webpack_require__(19);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(2);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(14);

var _selectors6 = _interopRequireDefault(_selectors5);

var _selectors7 = __webpack_require__(6);

var _selectors8 = _interopRequireDefault(_selectors7);

var _store = __webpack_require__(54);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(29);

var controller = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(25);

var actions = _interopRequireWildcard(_actions2);

var _sagas = __webpack_require__(59);

var _sagas2 = _interopRequireDefault(_sagas);

var _reducers = __webpack_require__(72);

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:session");

/**
 * Debugger Session
 */
class Session {
  /**
   * @param {Array<Contract>} contracts - contract definitions
   * @param {Array<String>} files - array of filenames for sourceMap indexes
   * @param {string} txHash - transaction hash
   * @param {Web3Provider} provider - web3 provider
   * @private
   */
  constructor(contracts, files, txHash, provider) {
    /**
     * @private
     */
    this._store = (0, _store2.default)(_reducers2.default, _sagas2.default);

    let { contexts, sources } = Session.normalize(contracts, files);

    // record contracts
    this._store.dispatch(actions.recordContracts(contexts, sources));

    this._store.dispatch(actions.start(txHash, provider));
  }

  ready() {
    return new _promise2.default((accept, reject) => {
      this._store.subscribe(() => {
        if (this.state.session == "ACTIVE") {
          accept();
        } else if (typeof this.state.session == "object") {
          reject(this.state.session.error);
        }
      });
    });
  }

  /**
   * Split up artifacts into "contexts" and "sources", dividing artifact
   * data into appropriate buckets.
   *
   * Multiple contracts can be defined in the same source file, but have
   * different bytecodes.
   *
   * This iterates over the contracts and collects binaries separately
   * from sources, using the optional `files` argument to force
   * source ordering.
   * @private
   */
  static normalize(contracts, files = null) {
    let sourcesByPath = {};
    let contexts = [];
    let sources;

    for (let contract of contracts) {
      let {
        contractName,
        binary,
        sourceMap,
        deployedBinary,
        deployedSourceMap,
        sourcePath,
        source,
        ast
      } = contract;

      sourcesByPath[sourcePath] = { sourcePath, source, ast };

      if (binary && binary != "0x") {
        contexts.push({
          contractName,
          binary,
          sourceMap
        });
      }

      if (deployedBinary && deployedBinary != "0x") {
        contexts.push({
          contractName,
          binary: deployedBinary,
          sourceMap: deployedSourceMap
        });
      }
    }

    if (!files) {
      sources = (0, _values2.default)(sourcesByPath);
    } else {
      sources = files.map(file => sourcesByPath[file]);
    }

    return { contexts, sources };
  }

  get state() {
    return this._store.getState();
  }

  view(selector) {
    return selector(this.state);
  }

  get finished() {
    return this.state.session == "FINISHED";
  }

  get failed() {
    return this.finished && this.view(_selectors4.default.current.callstack).length;
  }

  dispatch(action) {
    if (this.finished) {
      debug("finished: intercepting action %o", action);

      return false;
    }

    this._store.dispatch(action);

    return true;
  }

  interrupt() {
    return this.dispatch(controller.interrupt());
  }

  advance() {
    return this.dispatch(controller.advance());
  }

  stepNext() {
    return this.dispatch(controller.stepNext());
  }

  stepOver() {
    return this.dispatch(controller.stepOver());
  }

  stepInto() {
    return this.dispatch(controller.stepInto());
  }

  stepOut() {
    return this.dispatch(controller.stepOut());
  }

  continueUntil(...breakpoints) {
    return this.dispatch(controller.continueUntil(...breakpoints));
  }
}
exports.default = Session;

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/values");

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = require("truffle-solidity-utils");

/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = require("truffle-code-utils");

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// An augmented AVL Tree where each node maintains a list of records and their search intervals.
// Record is composed of an interval and its underlying data, sent by a client. This allows the
// interval tree to have the same interval inserted multiple times, as long its data is different.
// Both insertion and deletion require O(log n) time. Searching requires O(k*logn) time, where `k`
// is the number of intervals in the output list.
Object.defineProperty(exports, "__esModule", { value: true });
var isSame = __webpack_require__(53);
function height(node) {
    if (node === undefined) {
        return -1;
    }
    else {
        return node.height;
    }
}
var Node = /** @class */ (function () {
    function Node(intervalTree, record) {
        this.intervalTree = intervalTree;
        this.records = [];
        this.height = 0;
        this.key = record.low;
        this.max = record.high;
        // Save the array of all records with the same key for this node
        this.records.push(record);
    }
    // Gets the highest record.high value for this node
    Node.prototype.getNodeHigh = function () {
        var high = this.records[0].high;
        for (var i = 1; i < this.records.length; i++) {
            if (this.records[i].high > high) {
                high = this.records[i].high;
            }
        }
        return high;
    };
    // Updates height value of the node. Called during insertion, rebalance, removal
    Node.prototype.updateHeight = function () {
        this.height = Math.max(height(this.left), height(this.right)) + 1;
    };
    // Updates the max value of all the parents after inserting into already existing node, as well as
    // removing the node completely or removing the record of an already existing node. Starts with
    // the parent of an affected node and bubbles up to root
    Node.prototype.updateMaxOfParents = function () {
        if (this === undefined) {
            return;
        }
        var thisHigh = this.getNodeHigh();
        if (this.left !== undefined && this.right !== undefined) {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(this.left.max, thisHigh);
        }
        else if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(this.right.max, thisHigh);
        }
        else {
            this.max = thisHigh;
        }
        if (this.parent) {
            this.parent.updateMaxOfParents();
        }
    };
    /*
    Left-Left case:
  
           z                                      y
          / \                                   /   \
         y   T4      Right Rotate (z)          x     z
        / \          - - - - - - - - ->       / \   / \
       x   T3                                T1 T2 T3 T4
      / \
    T1   T2
  
    Left-Right case:
  
         z                               z                           x
        / \                             / \                        /   \
       y   T4  Left Rotate (y)         x  T4  Right Rotate(z)     y     z
      / \      - - - - - - - - ->     / \      - - - - - - - ->  / \   / \
    T1   x                           y  T3                      T1 T2 T3 T4
        / \                         / \
      T2   T3                      T1 T2
    */
    // Handles Left-Left case and Left-Right case after rebalancing AVL tree
    Node.prototype._updateMaxAfterRightRotate = function () {
        var parent = this.parent;
        var left = parent.left;
        // Update max of left sibling (x in first case, y in second)
        var thisParentLeftHigh = left.getNodeHigh();
        if (left.left === undefined && left.right !== undefined) {
            left.max = Math.max(thisParentLeftHigh, left.right.max);
        }
        else if (left.left !== undefined && left.right === undefined) {
            left.max = Math.max(thisParentLeftHigh, left.left.max);
        }
        else if (left.left === undefined && left.right === undefined) {
            left.max = thisParentLeftHigh;
        }
        else {
            left.max = Math.max(Math.max(left.left.max, left.right.max), thisParentLeftHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, parent.right.max), parent.getNodeHigh());
    };
    /*
    Right-Right case:
  
      z                               y
     / \                            /   \
    T1  y     Left Rotate(z)       z     x
       / \   - - - - - - - ->     / \   / \
      T2  x                      T1 T2 T3 T4
         / \
        T3 T4
  
    Right-Left case:
  
       z                            z                            x
      / \                          / \                         /   \
     T1  y   Right Rotate (y)     T1  x      Left Rotate(z)   z     y
        / \  - - - - - - - - ->      / \   - - - - - - - ->  / \   / \
       x  T4                        T2  y                   T1 T2 T3 T4
      / \                              / \
    T2   T3                           T3 T4
    */
    // Handles Right-Right case and Right-Left case in rebalancing AVL tree
    Node.prototype._updateMaxAfterLeftRotate = function () {
        var parent = this.parent;
        var right = parent.right;
        // Update max of right sibling (x in first case, y in second)
        var thisParentRightHigh = right.getNodeHigh();
        if (right.left === undefined && right.right !== undefined) {
            right.max = Math.max(thisParentRightHigh, right.right.max);
        }
        else if (right.left !== undefined && right.right === undefined) {
            right.max = Math.max(thisParentRightHigh, right.left.max);
        }
        else if (right.left === undefined && right.right === undefined) {
            right.max = thisParentRightHigh;
        }
        else {
            right.max = Math.max(Math.max(right.left.max, right.right.max), thisParentRightHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, right.max), parent.getNodeHigh());
    };
    Node.prototype._leftRotate = function () {
        var rightChild = this.right;
        rightChild.parent = this.parent;
        if (rightChild.parent === undefined) {
            this.intervalTree.root = rightChild;
        }
        else {
            if (rightChild.parent.left === this) {
                rightChild.parent.left = rightChild;
            }
            else if (rightChild.parent.right === this) {
                rightChild.parent.right = rightChild;
            }
        }
        this.right = rightChild.left;
        if (this.right !== undefined) {
            this.right.parent = this;
        }
        rightChild.left = this;
        this.parent = rightChild;
        this.updateHeight();
        rightChild.updateHeight();
    };
    Node.prototype._rightRotate = function () {
        var leftChild = this.left;
        leftChild.parent = this.parent;
        if (leftChild.parent === undefined) {
            this.intervalTree.root = leftChild;
        }
        else {
            if (leftChild.parent.left === this) {
                leftChild.parent.left = leftChild;
            }
            else if (leftChild.parent.right === this) {
                leftChild.parent.right = leftChild;
            }
        }
        this.left = leftChild.right;
        if (this.left !== undefined) {
            this.left.parent = this;
        }
        leftChild.right = this;
        this.parent = leftChild;
        this.updateHeight();
        leftChild.updateHeight();
    };
    // Rebalances the tree if the height value between two nodes of the same parent is greater than
    // two. There are 4 cases that can happen which are outlined in the graphics above
    Node.prototype._rebalance = function () {
        if (height(this.left) >= 2 + height(this.right)) {
            var left = this.left;
            if (height(left.left) >= height(left.right)) {
                // Left-Left case
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
            else {
                // Left-Right case
                left._leftRotate();
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
        }
        else if (height(this.right) >= 2 + height(this.left)) {
            var right = this.right;
            if (height(right.right) >= height(right.left)) {
                // Right-Right case
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
            else {
                // Right-Left case
                right._rightRotate();
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
        }
    };
    Node.prototype.insert = function (record) {
        if (record.low < this.key) {
            // Insert into left subtree
            if (this.left === undefined) {
                this.left = new Node(this.intervalTree, record);
                this.left.parent = this;
            }
            else {
                this.left.insert(record);
            }
        }
        else {
            // Insert into right subtree
            if (this.right === undefined) {
                this.right = new Node(this.intervalTree, record);
                this.right.parent = this;
            }
            else {
                this.right.insert(record);
            }
        }
        // Update the max value of this ancestor if needed
        if (this.max < record.high) {
            this.max = record.high;
        }
        // Update height of each node
        this.updateHeight();
        // Rebalance the tree to ensure all operations are executed in O(logn) time. This is especially
        // important in searching, as the tree has a high chance of degenerating without the rebalancing
        this._rebalance();
    };
    Node.prototype._getOverlappingRecords = function (currentNode, low, high) {
        if (currentNode.key <= high && low <= currentNode.getNodeHigh()) {
            // Nodes are overlapping, check if individual records in the node are overlapping
            var tempResults = [];
            for (var i = 0; i < currentNode.records.length; i++) {
                if (currentNode.records[i].high >= low) {
                    tempResults.push(currentNode.records[i]);
                }
            }
            return tempResults;
        }
        return [];
    };
    Node.prototype.search = function (low, high) {
        // Don't search nodes that don't exist
        if (this === undefined) {
            return [];
        }
        var leftSearch = [];
        var ownSearch = [];
        var rightSearch = [];
        // If interval is to the right of the rightmost point of any interval in this node and all its
        // children, there won't be any matches
        if (low > this.max) {
            return [];
        }
        // Search left children
        if (this.left !== undefined && this.left.max >= low) {
            leftSearch = this.left.search(low, high);
        }
        // Check this node
        ownSearch = this._getOverlappingRecords(this, low, high);
        // If interval is to the left of the start of this interval, then it can't be in any child to
        // the right
        if (high < this.key) {
            return leftSearch.concat(ownSearch);
        }
        // Otherwise, search right children
        if (this.right !== undefined) {
            rightSearch = this.right.search(low, high);
        }
        // Return accumulated results, if any
        return leftSearch.concat(ownSearch, rightSearch);
    };
    // Searches for a node by a `key` value
    Node.prototype.searchExisting = function (low) {
        if (this === undefined) {
            return undefined;
        }
        if (this.key === low) {
            return this;
        }
        else if (low < this.key) {
            if (this.left !== undefined) {
                return this.left.searchExisting(low);
            }
        }
        else {
            if (this.right !== undefined) {
                return this.right.searchExisting(low);
            }
        }
        return undefined;
    };
    // Returns the smallest node of the subtree
    Node.prototype._minValue = function () {
        if (this.left === undefined) {
            return this;
        }
        else {
            return this.left._minValue();
        }
    };
    Node.prototype.remove = function (node) {
        var parent = this.parent;
        if (node.key < this.key) {
            // Node to be removed is on the left side
            if (this.left !== undefined) {
                return this.left.remove(node);
            }
            else {
                return undefined;
            }
        }
        else if (node.key > this.key) {
            // Node to be removed is on the right side
            if (this.right !== undefined) {
                return this.right.remove(node);
            }
            else {
                return undefined;
            }
        }
        else {
            if (this.left !== undefined && this.right !== undefined) {
                // Node has two children
                var minValue = this.right._minValue();
                this.key = minValue.key;
                this.records = minValue.records;
                return this.right.remove(this);
            }
            else if (parent.left === this) {
                // One child or no child case on left side
                if (this.right !== undefined) {
                    parent.left = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.left = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
            else if (parent.right === this) {
                // One child or no child case on right side
                if (this.right !== undefined) {
                    parent.right = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.right = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
        }
    };
    return Node;
}());
exports.Node = Node;
var IntervalTree = /** @class */ (function () {
    function IntervalTree() {
        this.count = 0;
    }
    IntervalTree.prototype.insert = function (record) {
        if (record.low > record.high) {
            throw new Error('`low` value must be lower or equal to `high` value');
        }
        if (this.root === undefined) {
            // Base case: Tree is empty, new node becomes root
            this.root = new Node(this, record);
            this.count++;
            return true;
        }
        else {
            // Otherwise, check if node already exists with the same key
            var node = this.root.searchExisting(record.low);
            if (node !== undefined) {
                // Check the records in this node if there already is the one with same low, high, data
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        // This record is same as the one we're trying to insert; return false to indicate
                        // nothing has been inserted
                        return false;
                    }
                }
                // Add the record to the node
                node.records.push(record);
                // Update max of the node and its parents if necessary
                if (record.high > node.max) {
                    node.max = record.high;
                    if (node.parent) {
                        node.parent.updateMaxOfParents();
                    }
                }
                this.count++;
                return true;
            }
            else {
                // Node with this key doesn't already exist. Call insert function on root's node
                this.root.insert(record);
                this.count++;
                return true;
            }
        }
    };
    IntervalTree.prototype.search = function (low, high) {
        if (this.root === undefined) {
            // Tree is empty; return empty array
            return [];
        }
        else {
            return this.root.search(low, high);
        }
    };
    IntervalTree.prototype.remove = function (record) {
        if (this.root === undefined) {
            // Tree is empty; nothing to remove
            return false;
        }
        else {
            var node = this.root.searchExisting(record.low);
            if (node === undefined) {
                return false;
            }
            else if (node.records.length > 1) {
                var removedRecord = void 0;
                // Node with this key has 2 or more records. Find the one we need and remove it
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        removedRecord = node.records[i];
                        node.records.splice(i, 1);
                        break;
                    }
                }
                if (removedRecord) {
                    removedRecord = undefined;
                    // Update max of that node and its parents if necessary
                    if (record.high === node.max) {
                        var nodeHigh = node.getNodeHigh();
                        if (node.left !== undefined && node.right !== undefined) {
                            node.max = Math.max(Math.max(node.left.max, node.right.max), nodeHigh);
                        }
                        else if (node.left !== undefined && node.right === undefined) {
                            node.max = Math.max(node.left.max, nodeHigh);
                        }
                        else if (node.left === undefined && node.right !== undefined) {
                            node.max = Math.max(node.right.max, nodeHigh);
                        }
                        else {
                            node.max = nodeHigh;
                        }
                        if (node.parent) {
                            node.parent.updateMaxOfParents();
                        }
                    }
                    this.count--;
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (node.records.length === 1) {
                // Node with this key has only 1 record. Check if the remaining record in this node is
                // actually the one we want to remove
                if (isSame(node.records[0], record)) {
                    // The remaining record is the one we want to remove. Remove the whole node from the tree
                    if (this.root.key === node.key) {
                        // We're removing the root element. Create a dummy node that will temporarily take
                        // root's parent role
                        var rootParent = new Node(this, { low: record.low, high: record.low });
                        rootParent.left = this.root;
                        this.root.parent = rootParent;
                        var removedNode = this.root.remove(node);
                        this.root = rootParent.left;
                        if (this.root !== undefined) {
                            this.root.parent = undefined;
                        }
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        var removedNode = this.root.remove(node);
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    // The remaining record is not the one we want to remove
                    return false;
                }
            }
            else {
                // No records at all in this node?! Shouldn't happen
                return false;
            }
        }
    };
    IntervalTree.prototype.inOrder = function () {
        return new InOrder(this.root);
    };
    IntervalTree.prototype.preOrder = function () {
        return new PreOrder(this.root);
    };
    return IntervalTree;
}());
exports.IntervalTree = IntervalTree;
var DataIntervalTree = /** @class */ (function () {
    function DataIntervalTree() {
        this.tree = new IntervalTree();
    }
    DataIntervalTree.prototype.insert = function (low, high, data) {
        return this.tree.insert({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.remove = function (low, high, data) {
        return this.tree.remove({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.search = function (low, high) {
        return this.tree.search(low, high).map(function (v) { return v.data; });
    };
    DataIntervalTree.prototype.inOrder = function () {
        return this.tree.inOrder();
    };
    DataIntervalTree.prototype.preOrder = function () {
        return this.tree.preOrder();
    };
    Object.defineProperty(DataIntervalTree.prototype, "count", {
        get: function () {
            return this.tree.count;
        },
        enumerable: true,
        configurable: true
    });
    return DataIntervalTree;
}());
exports.default = DataIntervalTree;
var InOrder = /** @class */ (function () {
    function InOrder(startNode) {
        this.stack = [];
        if (startNode !== undefined) {
            this.push(startNode);
        }
    }
    InOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        else {
            // Might pop the last and set this.currentNode = undefined
            this.pop();
        }
        return this.next();
    };
    InOrder.prototype.push = function (node) {
        this.currentNode = node;
        this.i = 0;
        while (this.currentNode.left !== undefined) {
            this.stack.push(this.currentNode);
            this.currentNode = this.currentNode.left;
        }
    };
    InOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return InOrder;
}());
exports.InOrder = InOrder;
if (typeof Symbol === 'function') {
    InOrder.prototype[Symbol.iterator] = function () { return this; };
}
var PreOrder = /** @class */ (function () {
    function PreOrder(startNode) {
        this.stack = [];
        this.i = 0;
        this.currentNode = startNode;
    }
    PreOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called,
        // which only happens if there is no right node (i.e we are done)
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        if (this.currentNode.left !== undefined) {
            this.push(this.currentNode.left);
        }
        this.pop();
        return this.next();
    };
    PreOrder.prototype.push = function (node) {
        this.stack.push(node);
    };
    PreOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return PreOrder;
}());
exports.PreOrder = PreOrder;
if (typeof Symbol === 'function') {
    PreOrder.prototype[Symbol.iterator] = function () { return this; };
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 53 */
/***/ (function(module, exports) {

//

module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {
  module.exports = require("./production");
} else if (true) {
  module.exports = __webpack_require__(55);
} else {
  module.exports = require("./development");
}

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(56);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = _common2.default;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(4);

var _assign2 = _interopRequireDefault(_assign);

exports.abbreviateValues = abbreviateValues;
exports.default = configureStore;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(15);

var _reduxSaga = __webpack_require__(57);

var _reduxSaga2 = _interopRequireDefault(_reduxSaga);

var _reduxCliLogger = __webpack_require__(58);

var _reduxCliLogger2 = _interopRequireDefault(_reduxCliLogger);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:store:common");
const reduxDebug = (0, _debug2.default)("debugger:redux");

function abbreviateValues(value, options = {}, depth = 0) {
  options.stringLimit = options.stringLimit || 66;
  options.arrayLimit = options.arrayLimit || 8;
  options.recurseLimit = options.recurseLimit || 4;

  if (depth > options.recurseLimit) {
    return "...";
  }

  const recurse = child => abbreviateValues(child, options, depth + 1);

  if (value instanceof Array) {
    if (value.length > options.arrayLimit) {
      value = [...value.slice(0, options.arrayLimit / 2), "...", ...value.slice(value.length - options.arrayLimit / 2 + 1)];
    }

    return value.map(recurse);
  } else if (value instanceof Object) {
    return (0, _assign2.default)({}, ...(0, _entries2.default)(value).map(([k, v]) => ({ [recurse(k)]: recurse(v) })));
  } else if (typeof value === "string" && value.length > options.stringLimit) {
    let inner = "...";
    let extractAmount = (options.stringLimit - inner.length) / 2;
    let leading = value.slice(0, Math.ceil(extractAmount));
    let trailing = value.slice(value.length - Math.floor(extractAmount));
    return `${leading}${inner}${trailing}`;
  } else {
    return value;
  }
}

function configureStore(reducer, saga, initialState, composeEnhancers) {
  const sagaMiddleware = (0, _reduxSaga2.default)();

  if (!composeEnhancers) {
    composeEnhancers = _redux.compose;
  }

  const loggerMiddleware = (0, _reduxCliLogger2.default)({
    log: reduxDebug,
    stateTransformer: state => abbreviateValues(state, {
      arrayLimit: 4,
      recurseLimit: 3
    }),
    actionTransformer: abbreviateValues
  });

  let store = (0, _redux.createStore)(reducer, initialState, composeEnhancers((0, _redux.applyMiddleware)(sagaMiddleware, loggerMiddleware)));

  sagaMiddleware.run(saga);

  return store;
}

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = require("redux-saga");

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = require("redux-cli-logger");

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(10);

var _helpers = __webpack_require__(5);

var _sagas = __webpack_require__(60);

var ast = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(65);

var controller = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(67);

var solidity = _interopRequireWildcard(_sagas3);

var _sagas4 = __webpack_require__(68);

var evm = _interopRequireWildcard(_sagas4);

var _sagas5 = __webpack_require__(32);

var trace = _interopRequireWildcard(_sagas5);

var _sagas6 = __webpack_require__(30);

var data = _interopRequireWildcard(_sagas6);

var _sagas7 = __webpack_require__(69);

var web3 = _interopRequireWildcard(_sagas7);

var _actions = __webpack_require__(25);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:session:sagas");

function* saga() {
  debug("starting listeners");
  let listeners = yield* forkListeners();

  // receiving & saving contracts into state
  debug("waiting for contract information");
  let { contexts, sources } = yield (0, _effects.take)(actions.RECORD_CONTRACTS);

  debug("recording contract binaries");
  yield* recordContexts(...contexts);

  debug("recording contract sources");
  yield* recordSources(...sources);

  debug("waiting for start");
  // wait for start signal
  let { txHash, provider } = yield (0, _effects.take)(actions.START);
  debug("starting");

  // process transaction
  debug("fetching transaction info");
  let err = yield* fetchTx(txHash, provider);
  if (err) {
    debug("error %o", err);
    yield* error(err);
  } else {
    debug("visiting ASTs");
    // visit asts
    yield* ast.visitAll();

    debug("readying");
    // signal that stepping can begin
    yield* ready();

    debug("waiting for trace EOT");
    // wait until trace hits EOT
    yield* trace.wait();

    debug("finishing");
    // finish
    yield (0, _effects.put)(actions.finish());
  }

  debug("stopping listeners");
  yield (0, _effects.all)(listeners.map(task => (0, _effects.cancel)(task)));
}

exports.default = (0, _helpers.prefixName)("session", saga);

function* forkListeners() {
  return yield (0, _effects.all)([ast, controller, data, evm, solidity, trace, web3].map(app => (0, _effects.fork)(app.saga)));
}

function* fetchTx(txHash, provider) {
  let result = yield* web3.inspectTransaction(txHash, provider);

  if (result.error) {
    return result.error;
  }

  yield* evm.begin(result);

  let addresses = yield* trace.processTrace(result.trace);
  if (result.address && addresses.indexOf(result.address) == -1) {
    addresses.push(result.address);
  }

  let binaries = yield* web3.obtainBinaries(addresses);

  yield (0, _effects.all)(addresses.map((address, i) => (0, _effects.call)(recordInstance, address, binaries[i])));
}

function* recordContexts(...contexts) {
  for (let _ref of contexts) {
    let { contractName, binary, sourceMap } = _ref;

    yield* evm.addContext(contractName, binary);

    if (sourceMap) {
      yield* solidity.addSourceMap(binary, sourceMap);
    }
  }
}

function* recordSources(...sources) {
  for (let _ref2 of sources) {
    let { sourcePath, source, ast } = _ref2;

    yield* solidity.addSource(source, sourcePath, ast);
  }
}

function* recordInstance(address, binary) {
  yield* evm.addInstance(address, binary);
}

function* ready() {
  yield (0, _effects.put)(actions.ready());
}

function* error(err) {
  yield (0, _effects.put)(actions.error(err));
}

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

exports.visitAll = visitAll;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(10);

var _helpers = __webpack_require__(5);

var _sagas = __webpack_require__(30);

var data = _interopRequireWildcard(_sagas);

var _actions = __webpack_require__(64);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(14);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:ast:sagas");

function* walk(sourceId, node, pointer = "", parentId = null) {
  debug("walking %o %o", pointer, node);

  yield* handleEnter(sourceId, node, pointer, parentId);

  if (node instanceof Array) {
    for (let [i, child] of node.entries()) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${i}`, parentId);
    }
  } else if (node instanceof Object) {
    for (let [key, child] of (0, _entries2.default)(node)) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${key}`, node.id);
    }
  }

  yield* handleExit(sourceId, node, pointer);
}

function* handleEnter(sourceId, node, pointer, parentId) {
  if (!(node instanceof Object)) {
    return;
  }

  debug("entering %s", pointer);

  if (node.id !== undefined) {
    debug("%s recording scope %s", pointer, node.id);
    yield* data.scope(node.id, pointer, parentId, sourceId);
  }

  switch (node.nodeType) {
    case "VariableDeclaration":
      debug("%s recording variable %o", pointer, node);
      yield* data.declare(node);
      break;
  }
}

function* handleExit(sourceId, node, pointer) {
  debug("exiting %s", pointer);

  // no-op right now
}

function* walkSaga({ sourceId, ast }) {
  yield walk(sourceId, ast);
}

function* visitAll(idx) {
  let sources = yield (0, _effects.select)(_selectors2.default.views.sources);

  let tasks = yield (0, _effects.all)((0, _entries2.default)(sources).filter(([id, { ast }]) => !!ast).map(([id, { ast }]) => (0, _effects.fork)(() => (0, _effects.put)(actions.visit(id, ast)))));

  if (tasks.length > 0) {
    yield (0, _effects.join)(...tasks);
  }

  yield (0, _effects.put)(actions.doneVisiting());
}

function* saga() {
  yield (0, _effects.race)({
    visitor: (0, _effects.takeEvery)(actions.VISIT, walkSaga),
    done: (0, _effects.take)(actions.DONE_VISITING)
  });
}

exports.default = (0, _helpers.prefixName)("ast", saga);

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _extends2 = __webpack_require__(3);

var _extends3 = _interopRequireDefault(_extends2);

var _assign = __webpack_require__(4);

var _assign2 = _interopRequireDefault(_assign);

exports.read = read;
exports.decodeValue = decodeValue;
exports.decodeMemoryReference = decodeMemoryReference;
exports.decodeStorageReference = decodeStorageReference;
exports.decodeMapping = decodeMapping;
exports.default = decode;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _bignumber = __webpack_require__(20);

var _memory = __webpack_require__(62);

var memory = _interopRequireWildcard(_memory);

var _storage = __webpack_require__(63);

var storage = _interopRequireWildcard(_storage);

var _utils = __webpack_require__(11);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:data:decode");

function read(pointer, state) {
  if (pointer.stack != undefined && state.stack && pointer.stack < state.stack.length) {
    return state.stack[pointer.stack];
  } else if (pointer.storage != undefined && state.storage) {
    return storage.readRange(state.storage, pointer.storage);
  } else if (pointer.memory != undefined && state.memory) {
    return memory.readBytes(state.memory, pointer.memory.start, pointer.memory.length);
  } else if (pointer.literal) {
    return pointer.literal;
  }
}

function decodeValue(definition, pointer, state, ...args) {
  debug("decoding value, pointer: %o, typeClass: %s", pointer, utils.typeClass(definition));
  let bytes = read(pointer, state);
  if (!bytes) {
    debug("segfault, state: %O", state);
    return undefined;
  }

  switch (utils.typeClass(definition)) {
    case "bool":
      return !utils.toBigNumber(bytes).isZero();

    case "uint":
      return utils.toBigNumber(bytes);

    case "int":
      return utils.toSignedBigNumber(bytes);

    case "address":
      return utils.toHexString(bytes, true);

    case "bytes":
      debug("typeIdentifier %s %o", utils.typeIdentifier(definition), bytes);
      let length = utils.specifiedSize(definition);
      return utils.toHexString(bytes, length);

    case "string":
      debug("typeIdentifier %s %o", utils.typeIdentifier(definition), bytes);
      return String.fromCharCode.apply(null, bytes);

    case "rational":
      debug("typeIdentifier %s %o", utils.typeIdentifier(definition), bytes);
      return utils.toBigNumber(bytes);

    default:
      debug("Unknown value type: %s", utils.typeIdentifier(definition));
      return null;
  }
}

function decodeMemoryReference(definition, pointer, state, ...args) {
  let rawValue = utils.toBigNumber(read(pointer, state)).toNumber();

  var bytes;
  switch (utils.typeClass(definition)) {

    case "bytes":
    case "string":
      bytes = read({
        memory: { start: rawValue, length: _utils.WORD_SIZE }
      }, state); // bytes contain length

      return decodeValue(definition, {
        memory: { start: rawValue + _utils.WORD_SIZE, length: bytes }
      }, state, ...args);

    case "array":
      bytes = utils.toBigNumber(read({
        memory: { start: rawValue, length: _utils.WORD_SIZE }
      }, state)).toNumber(); // bytes contain array length

      bytes = read({ memory: {
          start: rawValue + _utils.WORD_SIZE, length: bytes * _utils.WORD_SIZE
        } }, state); // now bytes contain items

      return memory.chunk(bytes, _utils.WORD_SIZE).map(chunk => decode(utils.baseDefinition(definition), {
        literal: chunk
      }, state, ...args));

    case "struct":
      let [refs] = args;
      let structDefinition = refs[definition.typeName.referencedDeclaration];
      let structVariables = structDefinition.variables || [];

      return (0, _assign2.default)({}, ...structVariables.map(({ name, id }, i) => {
        let memberDefinition = refs[id].definition;
        let memberPointer = {
          memory: { start: rawValue + i * _utils.WORD_SIZE, length: _utils.WORD_SIZE }
        };
        // let memberPointer = memory.read(state.memory, pointer + i * WORD_SIZE);

        // HACK
        memberDefinition = (0, _extends3.default)({}, memberDefinition, {

          typeDescriptions: (0, _extends3.default)({}, memberDefinition.typeDescriptions, {

            typeIdentifier: memberDefinition.typeDescriptions.typeIdentifier.replace(/_storage_/g, "_memory_")
          })
        });

        return {
          [name]: decode(memberDefinition, memberPointer, state, ...args)
        };
      }));

    default:
      debug("Unknown memory reference type: %s", utils.typeIdentifier(definition));
      return null;

  }
}

function decodeStorageReference(definition, pointer, state, ...args) {
  var data;
  var bytes;
  var length;
  var slot;

  switch (utils.typeClass(definition)) {
    case "array":
      debug("storage array! %o", pointer);
      data = read(pointer, state);
      if (!data) {
        return null;
      }

      length = utils.toBigNumber(data).toNumber();
      debug("length %o", length);

      const baseSize = utils.storageSize(utils.baseDefinition(definition));
      const perWord = Math.floor(_utils.WORD_SIZE / baseSize);
      debug("baseSize %o", baseSize);
      debug("perWord %d", perWord);

      const offset = i => {
        if (perWord == 1) {
          return i;
        }

        return Math.floor(i * baseSize / _utils.WORD_SIZE);
      };

      const index = i => {
        if (perWord == 1) {
          return _utils.WORD_SIZE - baseSize;
        }

        const position = perWord - i % perWord - 1;
        return position * baseSize;
      };

      debug("pointer: %o", pointer);
      return [...Array(length).keys()].map(i => {
        let childFrom = pointer.storage.from.offset != undefined ? {
          slot: ["0x" + utils.toBigNumber(utils.keccak256(...pointer.storage.from.slot)).plus(pointer.storage.from.offset).toString(16)],
          offset: offset(i),
          index: index(i)
        } : {
          slot: [pointer.storage.from.slot],
          offset: offset(i),
          index: index(i)
        };
        return childFrom;
      }).map((childFrom, idx) => {
        debug("childFrom %d, %o", idx, childFrom);
        return decode(utils.baseDefinition(definition), { storage: {
            from: childFrom,
            length: baseSize
          } }, state, ...args);
      });

    case "bytes":
    case "string":
      debug("string pointer %O", pointer);
      debug("storage %o", state.storage);
      data = read(pointer, state);
      if (!data) {
        return null;
      }

      debug("data %O", data);
      if (data[_utils.WORD_SIZE - 1] % 2 == 0) {
        // string lives in word, length is last byte / 2
        length = data[_utils.WORD_SIZE - 1] / 2;
        debug("in-word; length %o", length);
        if (length == 0) {
          return "";
        }

        return decodeValue(definition, { storage: {
            from: { slot: pointer.storage.from.slot, index: 0 },
            to: { slot: pointer.storage.from.slot, index: length - 1 }
          } }, state, ...args);
      } else {
        length = utils.toBigNumber(data).minus(1).div(2).toNumber();
        debug("new-word, length %o", length);

        return decodeValue(definition, { storage: {
            from: { slot: [pointer.storage.from.slot], index: 0 },
            length
          } }, state, ...args);
      }

    case "struct":
      let [refs] = args;

      return (0, _assign2.default)({}, ...(0, _entries2.default)(pointer.storage.children).map(([id, childPointer]) => ({
        [childPointer.name]: decode(refs[id].definition, { storage: childPointer }, state, ...args)
      })));

    default:
      debug("Unknown storage reference type: %s", utils.typeIdentifier(definition));
      return undefined;
  }
}

function decodeMapping(definition, pointer, ...args) {
  if (definition.referencedDeclaration) {
    // attempting to decode reference to mapping, thus missing valid pointer
    return undefined;
  }
  debug("mapping %O", pointer);
  debug("mapping definition %O", definition);
  let { keys } = pointer;
  keys = keys || [];
  debug("known keys %o", keys);

  let keyDefinition = definition.typeName.keyType;
  let valueDefinition = definition.typeName.valueType;

  let baseSlot = pointer.storage.from.slot;
  if (!Array.isArray(baseSlot)) {
    baseSlot = [baseSlot];
  }

  let mapping = {};
  debug("mapping %O", mapping);
  for (let key of keys) {
    let keyPointer = { "literal": key };
    let valuePointer = {
      storage: {
        from: {
          slot: [key, ...baseSlot],
          index: 0
        },
        to: {
          slot: [key, ...baseSlot],
          index: 31
        }
      }
    };

    // NOTE mapping keys are potentially lossy because JS only likes strings
    let keyValue = decode(keyDefinition, keyPointer, ...args);
    if (keyValue != undefined) {
      mapping[keyValue.toString()] = decode(valueDefinition, valuePointer, ...args);
    }
  }

  return mapping;
}

function decode(definition, pointer, ...args) {
  if (pointer.literal) {
    return pointer.literal;
  }

  const identifier = utils.typeIdentifier(definition);
  if (utils.isReference(definition)) {
    switch (utils.referenceType(definition)) {
      case "memory":
        debug("decoding memory reference, type: %s", identifier);
        return decodeMemoryReference(definition, pointer, ...args);
      case "storage":
        debug("decoding storage reference, type: %s", identifier);
        return decodeStorageReference(definition, pointer, ...args);
      default:
        debug("Unknown reference category: %s", utils.typeIdentifier(definition));
        return undefined;
    }
  }

  if (utils.isMapping(definition)) {
    debug("decoding mapping, type: %s", identifier);
    return decodeMapping(definition, pointer, ...args);
  }

  debug("decoding value, type: %s", identifier);
  return decodeValue(definition, pointer, ...args);
}

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.read = read;
exports.readBytes = readBytes;
exports.chunk = chunk;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _bignumber = __webpack_require__(20);

var _utils = __webpack_require__(11);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:data:decode:memory");

/**
 * read word from memory
 *
 * requires `byte` to be a multiple of WORD_SIZE (32)
 *
 * @param memory - Uint8Array
 * @return {BigNumber}
 */
function read(memory, byte) {
  return readBytes(memory, byte, _utils.WORD_SIZE);
}

/**
 * read <bytes> amount of bytes from memory, starting at byte <start>
 *
 * @param memory - Uint8Array
 */
function readBytes(memory, byte, length) {
  byte = utils.toBigNumber(byte);
  length = utils.toBigNumber(length);

  if (byte.toNumber() >= memory.length) {
    return new Uint8Array(length ? length.toNumber() : 0);
  }

  if (length == undefined) {
    return new Uint8Array(memory.buffer, byte.toNumber());
  }

  // grab `length` bytes no matter what, here fill this array
  var bytes = new Uint8Array(length.toNumber());

  // if we're reading past the end of memory, truncate the length to read
  let excess = byte.plus(length).minus(memory.length).toNumber();
  if (excess > 0) {
    length = new _bignumber.BigNumber(memory.length).minus(byte);
  }

  let existing = new Uint8Array(memory.buffer, byte.toNumber(), length.toNumber());

  bytes.set(existing);

  return bytes;
}

/**
 * Split memory into chunks
 */
function chunk(memory, size = _utils.WORD_SIZE) {
  let chunks = [];

  for (let i = 0; i < memory.length; i += size) {
    let chunk = readBytes(memory, i, size);
    chunks.push(chunk);
  }

  return chunks;
}

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(3);

var _extends3 = _interopRequireDefault(_extends2);

exports.slotAddress = slotAddress;
exports.read = read;
exports.readRange = readRange;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _utils = __webpack_require__(11);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:data:decode:storage");

/**
 * convert a slot to a word corresponding to actual storage address
 *
 * if `slot` is an array, return hash of array values.
 * if `slot` array is nested, recurse on sub-arrays
 *
 * @param slot - number or possibly-nested array of numbers
 */
function slotAddress(slot) {
  if (slot instanceof Array) {
    return utils.keccak256(...slot.map(slotAddress));
  } else {
    return utils.toBigNumber(slot);
  }
}

/**
 * read slot from storage
 *
 * @param slot - big number or array of regular numbers
 * @param offset - for array, offset from the keccak determined location
 */
function read(storage, slot, offset = 0) {
  const address = slotAddress(slot).plus(offset);

  debug("reading slot: %o", utils.toHexString(address));

  let word = storage[utils.toHexString(address, _utils.WORD_SIZE)] || new Uint8Array(_utils.WORD_SIZE);

  debug("word %o", word);
  return word;
}

/**
 * read all bytes in some range.
 *
 * parameters `from` and `to` are objects with the following properties:
 *
 *   slot - (required) either a bignumber or a "path" array of integer offsets
 *
 *     path array values get converted into keccak256 hash as per solidity
 *     storage allocation method
 *
 *     ref: https://solidity.readthedocs.io/en/v0.4.23/miscellaneous.html#layout-of-state-variables-in-storage
 *     (search "concatenation")
 *
 *  offset - (default: 0) slot offset
 *
 *  index - (default: 0) byte index in word
 *
 * @param from - location (see ^)
 * @param to - location (see ^). inclusive.
 * @param length - instead of `to`, number of bytes after `from`
 */
function readRange(storage, { from, to, length }) {
  if (!length && !to || length && to) {
    throw new Error("must specify exactly one `to`|`length`");
  }

  from = (0, _extends3.default)({}, from, {
    offset: from.offset || 0
  });

  if (length) {
    to = {
      slot: from.slot,
      offset: from.offset + Math.floor((from.index + length - 1) / _utils.WORD_SIZE),
      index: (from.index + length - 1) % _utils.WORD_SIZE
    };
  } else {
    to = (0, _extends3.default)({}, to, {
      offset: to.offset || 0
    });
  }

  debug("readRange %o", { from, to });

  const totalWords = to.offset - from.offset + 1;
  debug("totalWords %o", totalWords);

  let data = new Uint8Array(totalWords * _utils.WORD_SIZE);

  for (let i = 0; i < totalWords; i++) {
    let offset = i + from.offset;
    data.set(read(storage, from.slot, offset), i * _utils.WORD_SIZE);
  }
  debug("words %o", data);

  data = data.slice(from.index, (totalWords - 1) * _utils.WORD_SIZE + to.index + 1);

  debug("data: %o", data);

  return data;
}

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.visit = visit;
exports.doneVisiting = doneVisiting;
const VISIT = exports.VISIT = "VISIT";
function visit(sourceId, ast) {
  return {
    type: VISIT,
    sourceId, ast
  };
}

const DONE_VISITING = exports.DONE_VISITING = "DONE_VISITING";
function doneVisiting() {
  return {
    type: DONE_VISITING
  };
}

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(17);

var _keys2 = _interopRequireDefault(_keys);

var _set = __webpack_require__(22);

var _set2 = _interopRequireDefault(_set);

exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(10);

var _helpers = __webpack_require__(5);

var _sagas = __webpack_require__(32);

var trace = _interopRequireWildcard(_sagas);

var _actions = __webpack_require__(29);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(66);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:controller:sagas");

const CONTROL_SAGAS = {
  [actions.ADVANCE]: advance,
  [actions.STEP_NEXT]: stepNext,
  [actions.STEP_OVER]: stepOver,
  [actions.STEP_INTO]: stepInto,
  [actions.STEP_OUT]: stepOut,
  [actions.CONTINUE_UNTIL]: continueUntil
};

/** AST node types that are skipped to filter out some noise */
const SKIPPED_TYPES = new _set2.default(["ContractDefinition", "VariableDeclaration"]);

function* saga() {
  while (true) {
    debug("waiting for control action");
    let action = yield (0, _effects.take)((0, _keys2.default)(CONTROL_SAGAS));
    debug("got control action");
    let saga = CONTROL_SAGAS[action.type];

    yield (0, _effects.put)(actions.beginStep(action.type));

    yield (0, _effects.race)({
      exec: (0, _effects.call)(saga, action),
      interrupt: (0, _effects.take)(actions.INTERRUPT)
    });
  }
}

exports.default = (0, _helpers.prefixName)("controller", saga);

/**
 * Advance the state by one instruction
 */

function* advance() {
  // send action to advance trace
  yield* trace.advance();
}

/**
 * stepNext - step to the next logical code segment
 *
 * Note: It might take multiple instructions to express the same section of code.
 * "Stepping", then, is stepping to the next logical item, not stepping to the next
 * instruction. See advance() if you'd like to advance by one instruction.
 */
function* stepNext() {
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);

  var upcoming;

  do {
    // advance at least once step
    yield* advance();

    // and check the next source range
    upcoming = yield (0, _effects.select)(_selectors2.default.current.location);

    // if the next step's source range is still the same, keep going
  } while (!upcoming.node || SKIPPED_TYPES.has(upcoming.node.nodeType) || upcoming.sourceRange.start == startingRange.start && upcoming.sourceRange.length == startingRange.length);
}

/**
 * stepInto - step into the current function
 *
 * Conceptually this is easy, but from a programming standpoint it's hard.
 * Code like `getBalance(msg.sender)` might be highlighted, but there could
 * be a number of different intermediate steps (like evaluating `msg.sender`)
 * before `getBalance` is stepped into. This function will step into the first
 * function available (where instruction.jump == "i"), ignoring any intermediate
 * steps that fall within the same code range. If there's a step encountered
 * that exists outside of the range, then stepInto will only execute until that
 * step.
 */
function* stepInto() {
  if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
    yield* stepNext();

    return;
  }

  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();

    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  } while (
  // the function stack has not increased,
  currentDepth <= startingDepth &&

  // the current source range begins on or after the starting range
  currentRange.start >= startingRange.start &&

  // and the current range ends on or before the starting range ends
  currentRange.start + currentRange.length <= startingRange.start + startingRange.length);
}

/**
 * Step out of the current function
 *
 * This will run until the debugger encounters a decrease in function depth.
 */
function* stepOut() {
  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();

    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  var currentDepth;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  } while (currentDepth >= startingDepth);
}

/**
 * stepOver - step over the current line
 *
 * Step over the current line. This will step to the next instruction that
 * exists on a different line of code within the same function depth.
 */
function* stepOver() {
  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  } while (
  // keep stepping provided:
  //
  // we haven't jumped out
  !(currentDepth < startingDepth) && (

  // either: function depth is greater than starting (ignore function calls)
  // or, if we're at the same depth, keep stepping until we're on a new
  // line.
  currentDepth > startingDepth || currentRange.lines.start.line == startingRange.lines.start.line));
}

/**
 * continueUntil - step through execution until a breakpoint
 *
 * @param breakpoints - array of breakpoints ({ ...call, line })
 */
function* continueUntil({ breakpoints }) {
  var currentCall;
  var currentLocation;

  let breakpointHit = false;

  do {
    yield* stepNext();

    currentCall = yield (0, _effects.select)(_selectors2.default.current.executionContext);
    currentLocation = yield (0, _effects.select)(_selectors2.default.current.location);

    breakpointHit = breakpoints.filter(({ address, binary, line, node }) => (address == currentCall.address || binary == currentCall.binary) && (line == currentLocation.sourceRange.lines.start.line || node == currentLocation.node.id)).length > 0;
  } while (!breakpointHit);
}

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(9);

var _selectors = __webpack_require__(2);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(6);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(14);

var _selectors6 = _interopRequireDefault(_selectors5);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:controller:sagas");

/**
 * @private
 */
const identity = x => x;

/**
 * controller
 */
const controller = (0, _reselectTree.createSelectorTree)({

  /**
   * controller.current
   */
  current: {
    /**
     * controller.current.functionDepth
     */
    functionDepth: (0, _reselectTree.createLeaf)([_selectors4.default.current.functionDepth], identity),

    /**
     * controller.current.executionContext
     */
    executionContext: (0, _reselectTree.createLeaf)([_selectors2.default.current.call], identity),

    /**
     * controller.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], identity),

    /**
     * controller.current.location
     */
    location: {
      /**
       * controller.current.location.sourceRange
       */
      sourceRange: (0, _reselectTree.createLeaf)([_selectors4.default.current.sourceRange], identity),

      /**
       * controller.current.location.node
       */
      node: (0, _reselectTree.createLeaf)([_selectors6.default.current.node], identity),

      /**
       * controller.current.location.isMultiline
       */
      isMultiline: (0, _reselectTree.createLeaf)([_selectors4.default.current.isMultiline], identity)
    }
  }
});

exports.default = controller;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.addSourceMap = addSourceMap;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(10);

var _helpers = __webpack_require__(5);

var _actions = __webpack_require__(33);

var actions = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(21);

var _selectors = __webpack_require__(6);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:solidity:sagas");

function* addSource(source, sourcePath, ast) {
  yield (0, _effects.put)(actions.addSource(source, sourcePath, ast));
}

function* addSourceMap(binary, sourceMap) {
  yield (0, _effects.put)(actions.addSourceMap(binary, sourceMap));
}

function* functionDepthSaga() {
  while (true) {
    yield (0, _effects.take)(_actions2.TICK);
    debug("got TICK");
    let instruction = yield (0, _effects.select)(_selectors2.default.current.instruction);
    debug("instruction: %o", instruction);

    if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
      let jumpDirection = yield (0, _effects.select)(_selectors2.default.current.jumpDirection);

      yield (0, _effects.put)(actions.jump(jumpDirection));
    }
  }
}

function* saga() {
  yield (0, _effects.call)(functionDepthSaga);
}

exports.default = (0, _helpers.prefixName)("solidity", saga);

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.addInstance = addInstance;
exports.begin = begin;
exports.callstackSaga = callstackSaga;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(10);

var _helpers = __webpack_require__(5);

var _actions = __webpack_require__(21);

var _actions2 = __webpack_require__(34);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(2);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:evm:sagas");

/**
 * Adds EVM bytecode context
 *
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addContext(contractName, binary) {
  yield (0, _effects.put)(actions.addContext(contractName, binary));

  return (0, _helpers.keccak256)(binary);
}

/**
 * Adds known deployed instance of binary at address
 *
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addInstance(address, binary) {
  let search = yield (0, _effects.select)(_selectors2.default.info.binaries.search);
  if (binary != "0x0") {
    let { context } = search(binary);

    yield (0, _effects.put)(actions.addInstance(address, context, binary));

    return context;
  }
}

function* begin({ address, binary }) {
  if (address) {
    yield (0, _effects.put)(actions.call(address));
  } else {
    yield (0, _effects.put)(actions.create(binary));
  }
}

function* callstackSaga() {
  while (true) {
    yield (0, _effects.take)(_actions.TICK);
    debug("got TICK");

    if (yield (0, _effects.select)(_selectors2.default.current.step.isCall)) {
      debug("got call");
      let address = yield (0, _effects.select)(_selectors2.default.current.step.callAddress);

      yield (0, _effects.put)(actions.call(address));
    } else if (yield (0, _effects.select)(_selectors2.default.current.step.isCreate)) {
      debug("got create");
      let binary = yield (0, _effects.select)(_selectors2.default.current.step.createBinary);

      yield (0, _effects.put)(actions.create(binary));
    } else if (yield (0, _effects.select)(_selectors2.default.current.step.isHalting)) {
      debug("got return");
      yield (0, _effects.put)(actions.returnCall());
    }
  }
}

function* saga() {
  yield (0, _effects.call)(callstackSaga);
}

exports.default = (0, _helpers.prefixName)("evm", saga);

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inspectTransaction = inspectTransaction;
exports.obtainBinaries = obtainBinaries;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(10);

var _helpers = __webpack_require__(5);

var _actions = __webpack_require__(70);

var actions = _interopRequireWildcard(_actions);

var _adapter = __webpack_require__(71);

var _adapter2 = _interopRequireDefault(_adapter);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:web3:sagas");

function* fetchTransactionInfo(adapter, { txHash }) {
  debug("inspecting transaction");
  var trace;
  try {
    trace = yield (0, _effects.apply)(adapter, adapter.getTrace, [txHash]);
  } catch (e) {
    debug("putting error");
    yield (0, _effects.put)(actions.error(e));
    return;
  }

  debug("got trace");
  yield (0, _effects.put)(actions.receiveTrace(trace));

  let tx = yield (0, _effects.apply)(adapter, adapter.getTransaction, [txHash]);
  if (tx.to && tx.to != "0x0") {
    yield (0, _effects.put)(actions.receiveCall({ address: tx.to }));
    return;
  }

  let receipt = yield (0, _effects.apply)(adapter, adapter.getReceipt, [txHash]);
  if (receipt.contractAddress) {
    yield (0, _effects.put)(actions.receiveCall({ binary: tx.input }));
    return;
  }

  throw new Error("Could not find contract associated with transaction. " + "Please make sure you're debugging a transaction that executes a " + "contract function or creates a new contract.");
}

function* fetchBinary(adapter, { address }) {
  debug("fetching binary for %s", address);
  let binary = yield (0, _effects.apply)(adapter, adapter.getDeployedCode, [address]);

  debug("received binary for %s", address);
  yield (0, _effects.put)(actions.receiveBinary(address, binary));
}

function* inspectTransaction(txHash, provider) {
  yield (0, _effects.put)(actions.init(provider));
  yield (0, _effects.put)(actions.inspect(txHash));

  let action = yield (0, _effects.take)(({ type }) => type == actions.RECEIVE_TRACE || type == actions.ERROR_WEB3);
  debug("action %o", action);

  var trace;
  if (action.type == actions.RECEIVE_TRACE) {
    trace = action.trace;
    debug("received trace");
  } else {
    return { error: action.error };
  }

  let { address, binary } = yield (0, _effects.take)(actions.RECEIVE_CALL);
  debug("received call");

  return { trace, address, binary };
}

function* obtainBinaries(addresses) {
  let tasks = yield (0, _effects.all)(addresses.map(address => (0, _effects.fork)(receiveBinary, address)));

  debug("requesting binaries");
  yield (0, _effects.all)(addresses.map(address => (0, _effects.put)(actions.fetchBinary(address))));

  let binaries = [];
  binaries = yield (0, _effects.all)(tasks.map(task => (0, _effects.join)(task)));

  debug("binaries %o", binaries);

  return binaries;
}

function* receiveBinary(address) {
  let { binary } = yield (0, _effects.take)(action => action.type == actions.RECEIVE_BINARY && action.address == address);
  debug("got binary for %s", address);

  return binary;
}

function* saga() {
  // wait for web3 init signal
  let { provider } = yield (0, _effects.take)(actions.INIT_WEB3);
  let adapter = new _adapter2.default(provider);

  yield (0, _effects.takeEvery)(actions.INSPECT, fetchTransactionInfo, adapter);
  yield (0, _effects.takeEvery)(actions.FETCH_BINARY, fetchBinary, adapter);
}

exports.default = (0, _helpers.prefixName)("web3", saga);

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports.inspect = inspect;
exports.fetchBinary = fetchBinary;
exports.receiveBinary = receiveBinary;
exports.receiveTrace = receiveTrace;
exports.receiveCall = receiveCall;
exports.error = error;
const INIT_WEB3 = exports.INIT_WEB3 = "INIT_WEB3";
function init(provider) {
  return {
    type: INIT_WEB3,
    provider
  };
}

const INSPECT = exports.INSPECT = "INSPECT_TRANSACTION";
function inspect(txHash) {
  return {
    type: INSPECT,
    txHash
  };
}

const FETCH_BINARY = exports.FETCH_BINARY = "FETCH_BINARY";
function fetchBinary(address) {
  return {
    type: FETCH_BINARY,
    address
  };
}

const RECEIVE_BINARY = exports.RECEIVE_BINARY = "RECEIVE_BINARY";
function receiveBinary(address, binary) {
  return {
    type: RECEIVE_BINARY,
    address, binary
  };
}

const RECEIVE_TRACE = exports.RECEIVE_TRACE = "RECEIVE_TRACE";
function receiveTrace(trace) {
  return {
    type: RECEIVE_TRACE,
    trace
  };
}

const RECEIVE_CALL = exports.RECEIVE_CALL = "RECEIVE_CALL";
function receiveCall({ address, binary }) {
  return {
    type: RECEIVE_CALL,
    address, binary
  };
}

const ERROR_WEB3 = exports.ERROR_WEB3 = "ERROR_WEB3";
function error(error) {
  return {
    type: ERROR_WEB3,
    error
  };
}

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(23);

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = __webpack_require__(7);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _web = __webpack_require__(8);

var _web2 = _interopRequireDefault(_web);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:web3:adapter");

class Web3Adapter {
  constructor(provider) {
    this.web3 = new _web2.default(provider);
  }

  getTrace(txHash) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        _this.web3.currentProvider.send({
          jsonrpc: "2.0",
          method: "debug_traceTransaction",
          params: [txHash, {}],
          id: new Date().getTime()
        }, function (err, result) {
          if (err) return reject(err);
          if (result.error) return reject(new Error(result.error.message));
          debug("result: %o", result);
          accept(result.result.structLogs);
        });
      });
    })();
  }

  getTransaction(txHash) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        _this2.web3.eth.getTransaction(txHash, function (err, tx) {
          if (err) return reject(err);

          return accept(tx);
        });
      });
    })();
  }

  getReceipt(txHash) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        _this3.web3.eth.getTransactionReceipt(txHash, function (err, receipt) {
          if (err) return reject(err);

          return accept(receipt);
        });
      });
    })();
  }

  /**
   * getDeployedCode - get the deployed code for an address from the client
   * @param  {String} address
   * @return {String}         deployedBinary
   */
  getDeployedCode(address) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      debug("getting deployed code for %s", address);
      return new _promise2.default(function (accept, reject) {
        _this4.web3.eth.getCode(address, function (err, deployedBinary) {
          if (err) debug("error: %o", err);
          if (err) return reject(err);
          debug("got deployed code for %s", address);
          accept(deployedBinary);
        });
      });
    })();
  }
}
exports.default = Web3Adapter;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FINISHED = exports.ERROR = exports.ACTIVE = exports.WAITING = undefined;
exports.session = session;

var _redux = __webpack_require__(15);

var _reducers = __webpack_require__(73);

var _reducers2 = _interopRequireDefault(_reducers);

var _reducers3 = __webpack_require__(74);

var _reducers4 = _interopRequireDefault(_reducers3);

var _reducers5 = __webpack_require__(76);

var _reducers6 = _interopRequireDefault(_reducers5);

var _reducers7 = __webpack_require__(77);

var _reducers8 = _interopRequireDefault(_reducers7);

var _actions = __webpack_require__(25);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const WAITING = exports.WAITING = "WAITING";
const ACTIVE = exports.ACTIVE = "ACTIVE";
const ERROR = exports.ERROR = "ERROR";
const FINISHED = exports.FINISHED = "FINISHED";

function session(state = WAITING, action) {
  switch (action.type) {
    case actions.READY:
      return ACTIVE;

    case actions.ERROR:
      return { error: action.error };

    case actions.FINISH:
      return FINISHED;

    default:
      return state;
  }
}

const reduceState = (0, _redux.combineReducers)({
  session,
  data: _reducers2.default,
  evm: _reducers4.default,
  solidity: _reducers6.default,
  trace: _reducers8.default
});

exports.default = reduceState;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(4);

var _assign2 = _interopRequireDefault(_assign);

var _extends2 = __webpack_require__(3);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(15);

var _actions = __webpack_require__(31);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("debugger:data:reducers");

const DEFAULT_SCOPES = {
  byId: {}
};

function scopes(state = DEFAULT_SCOPES, action) {
  var context;
  var scope;
  var variables;

  switch (action.type) {
    case actions.SCOPE:
      scope = state.byId[action.id] || {};

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.id]: (0, _extends3.default)({}, scope, {

            id: action.id,
            sourceId: action.sourceId,
            parentId: action.parentId,
            pointer: action.pointer
          })
        })
      };

    case actions.DECLARE:
      scope = state.byId[action.node.scope] || {};
      variables = scope.variables || [];

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.node.scope]: (0, _extends3.default)({}, scope, {

            variables: [...variables, { name: action.node.name, id: action.node.id }]
          })
        })
      };

    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  scopes
});

const DEFAULT_ASSIGNMENTS = {
  byId: {}
};

function assignments(state = DEFAULT_ASSIGNMENTS, action) {
  switch (action.type) {
    case actions.ASSIGN:
      return {
        byId: (0, _extends3.default)({}, state.byId, (0, _assign2.default)({}, ...(0, _entries2.default)(action.assignments).map(([id, ref]) => ({
          [id]: (0, _extends3.default)({}, state.byId[id], {
            ref
          })
        }))))
      };

    default:
      return state;
  }
};

const proc = (0, _redux.combineReducers)({
  assignments
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(22);

var _set2 = _interopRequireDefault(_set);

var _from = __webpack_require__(75);

var _from2 = _interopRequireDefault(_from);

var _extends2 = __webpack_require__(3);

var _extends3 = _interopRequireDefault(_extends2);

exports.callstack = callstack;

var _redux = __webpack_require__(15);

var _actions = __webpack_require__(34);

var actions = _interopRequireWildcard(_actions);

var _helpers = __webpack_require__(5);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const DEFAULT_CONTEXTS = {
  byContext: {},
  byBinary: {}
};

function contexts(state = DEFAULT_CONTEXTS, action) {
  switch (action.type) {
    /*
     * Adding a new context
     */
    case actions.ADD_CONTEXT:
      let { contractName, binary } = action;

      if (state.byBinary[binary]) {
        return state;
      }

      let context = (0, _helpers.keccak256)(binary);

      return {
        byContext: (0, _extends3.default)({}, state.byContext, {

          [context]: { context, binary, contractName }
        }),

        byBinary: (0, _extends3.default)({}, state.byBinary, {

          [binary]: { context: context }
        })
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const DEFAULT_INSTANCES = {
  byAddress: {},
  byContext: {}
};

function instances(state = DEFAULT_INSTANCES, action) {
  switch (action.type) {
    /*
     * Adding a new address for context
     */
    case actions.ADD_INSTANCE:
      let { address, context, binary } = action;

      // get known addresses for this context
      let otherInstances = state.byContext[context] || [];
      let otherAddresses = otherInstances.map(({ address }) => address);

      return {
        byAddress: (0, _extends3.default)({}, state.byAddress, {

          [address]: { context, binary }
        }),

        byContext: (0, _extends3.default)({}, state.byContext, {

          // reconstruct context instances to include new address
          [context]: (0, _from2.default)(new _set2.default(otherAddresses).add(address)).map(address => ({ address }))
        })
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  contexts,
  instances
});

function callstack(state = [], action) {
  switch (action.type) {
    case actions.CALL:
      let address = action.address;
      return state.concat([{ address }]);

    case actions.CREATE:
      const binary = action.binary;
      return state.concat([{ binary }]);

    case actions.RETURN:
      return state.slice(0, -1); // pop

    default:
      return state;
  };
}

const proc = (0, _redux.combineReducers)({
  callstack
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/array/from");

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(3);

var _extends3 = _interopRequireDefault(_extends2);

var _keys = __webpack_require__(17);

var _keys2 = _interopRequireDefault(_keys);

exports.functionDepth = functionDepth;

var _redux = __webpack_require__(15);

var _helpers = __webpack_require__(5);

var _actions = __webpack_require__(33);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const DEFAULT_SOURCES = {
  byId: {}
};

function sources(state = DEFAULT_SOURCES, action) {
  switch (action.type) {
    /*
     * Adding a new source
     */
    case actions.ADD_SOURCE:
      let { ast, source, sourcePath } = action;

      let id = (0, _keys2.default)(state.byId).length;

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [id]: {
            id,
            ast,
            source,
            sourcePath
          }
        })

        /*
         * Default case
         */
      };default:
      return state;
  }
}

const DEFAULT_SOURCEMAPS = {
  byContext: {}
};

function sourceMaps(state = DEFAULT_SOURCEMAPS, action) {
  switch (action.type) {
    /*
     * Adding a new sourceMap
     */
    case actions.ADD_SOURCEMAP:
      let { binary, sourceMap } = action;
      let context = (0, _helpers.keccak256)(binary);

      return {
        byContext: (0, _extends3.default)({}, state.byContext, {

          [context]: {
            context,
            sourceMap
          }
        })
      };

    /*
     * Default Case
     */
    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  sources,
  sourceMaps
});

function functionDepth(state = 1, action) {
  if (action.type === actions.JUMP) {
    const delta = spelunk(action.jumpDirection);
    return state + delta;
  } else {
    return state;
  }
}

function spelunk(jump) {
  if (jump == "i") {
    return 1;
  } else if (jump == "o") {
    return -1;
  } else {
    return 0;
  }
}

const proc = (0, _redux.combineReducers)({
  functionDepth
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.index = index;
exports.steps = steps;

var _redux = __webpack_require__(15);

var _actions = __webpack_require__(21);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function index(state = 0, action) {
  if (action.type == actions.TOCK || action.type == actions.END_OF_TRACE) {
    return state + 1;
  } else {
    return state;
  }
}

function steps(state = null, action) {
  if (action.type == actions.SAVE_STEPS) {
    return action.steps;
  } else {
    return state;
  }
}

const info = (0, _redux.combineReducers)({
  steps
});

const proc = (0, _redux.combineReducers)({
  index
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _keys = __webpack_require__(17);

var _keys2 = _interopRequireDefault(_keys);

var _asyncToGenerator2 = __webpack_require__(7);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _chai = __webpack_require__(12);

var _ganacheCli = __webpack_require__(16);

var _ganacheCli2 = _interopRequireDefault(_ganacheCli);

var _web = __webpack_require__(8);

var _web2 = _interopRequireDefault(_web);

var _helpers = __webpack_require__(13);

var _debugger = __webpack_require__(18);

var _debugger2 = _interopRequireDefault(_debugger);

var _selectors = __webpack_require__(35);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(19);

var _selectors4 = _interopRequireDefault(_selectors3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("test:context");

const __OUTER = `
pragma solidity ^0.4.18;

import "./InnerContract.sol";

contract OuterContract {
  event Outer();

  InnerContract inner;

  function OuterContract(address _inner) public {
    inner = InnerContract(_inner);
  }

  function run() public {
    inner.run();

    Outer();
  }
}
`;

const __INNER = `
pragma solidity ^0.4.18;

contract InnerContract {
  event Inner();

  function run() public {
    Inner();
  }
}
`;

const __MIGRATION = `
let OuterContract = artifacts.require("OuterContract");
let InnerContract = artifacts.require("InnerContract");

module.exports = function(deployer) {
  return deployer
    .then(function() {
      return deployer.deploy(InnerContract);
    })
    .then(function() {
      return InnerContract.deployed();
    })
    .then(function(inner) {
      return deployer.deploy(OuterContract, inner.address);
    });
};
`;

let migrations = {
  "2_deploy_contracts.js": __MIGRATION
};

let sources = {
  "OuterLibrary.sol": __OUTER,
  "InnerContract.sol": __INNER
};

describe("Contexts", function () {
  var provider;
  var web3;

  var abstractions;
  var artifacts;

  before("Create Provider", (0, _asyncToGenerator3.default)(function* () {
    provider = _ganacheCli2.default.provider({ seed: "debugger", gasLimit: 7000000 });
    web3 = new _web2.default(provider);
  }));

  before("Prepare contracts and artifacts", (0, _asyncToGenerator3.default)(function* () {
    this.timeout(30000);

    let prepared = yield (0, _helpers.prepareContracts)(provider, sources, migrations);
    abstractions = prepared.abstractions;
    artifacts = prepared.artifacts;
  }));

  it("returns view of addresses affected", (0, _asyncToGenerator3.default)(function* () {
    let outer = yield abstractions.OuterContract.deployed();
    let inner = yield abstractions.InnerContract.deployed();

    // run outer contract method
    let result = yield outer.run();

    _chai.assert.equal(2, result.receipt.logs.length, "There should be two logs");

    let txHash = result.tx;

    let bugger = yield _debugger2.default.forTx(txHash, {
      provider,
      contracts: artifacts
    });
    debug("debugger ready");

    let session = bugger.connect();

    let affectedInstances = session.view(_selectors2.default.info.affectedInstances);
    debug("affectedInstances: %o", affectedInstances);

    let affectedAddresses = (0, _keys2.default)(affectedInstances).map(function (address) {
      return address.toLowerCase();
    });

    _chai.assert.equal(2, affectedAddresses.length);

    _chai.assert.include(affectedAddresses, outer.address.toLowerCase(), "OuterContract should be an affected address");

    _chai.assert.include(affectedAddresses, inner.address.toLowerCase(), "InnerContract should be an affected address");
  }));
});

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _entries = __webpack_require__(1);

var _entries2 = _interopRequireDefault(_entries);

var _stringify = __webpack_require__(80);

var _stringify2 = _interopRequireDefault(_stringify);

var _assign = __webpack_require__(4);

var _assign2 = _interopRequireDefault(_assign);

var _extends2 = __webpack_require__(3);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _faker = __webpack_require__(81);

var _faker2 = _interopRequireDefault(_faker);

var _selectors = __webpack_require__(2);

var _selectors2 = _interopRequireDefault(_selectors);

var _helpers = __webpack_require__(36);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("test:data:decode");

const uints = (0, _helpers.generateUints)();

function generateArray(length) {
  return [...Array(length)].map(() => uints.next().value);
}

const commonFixtures = [{
  name: "multipleFullWordArray",
  type: "uint[]",
  value: generateArray(3) // takes up 3 whole words
}, {
  name: "withinWordArray",
  type: "uint16[]",
  value: generateArray(10) // takes up >1/2 word
}, {
  name: "multiplePartWordArray",
  type: "uint64[]",
  value: generateArray(9) // takes up 2.25 words
}, {
  name: "inconvenientlyWordOffsetArray",
  type: "uint240[]",
  value: generateArray(3) // takes up ~2.8 words
}, {
  name: "shortString",
  type: "string",
  value: "hello world"
}, {
  name: "longString",
  type: "string",
  value: "solidity allocation is a fun lesson in endianness"
}];

const mappingFixtures = [{
  // name: "simpleMapping",
  // type: {
  //   from: "uint256",
  //   to: "uint256"
  // },
  // value: {
  //   ...Object.assign({}, ...generateArray(5).map(
  //     (value, idx) => ({ [idx]: value })
  //   ))
  // }
  // }, {
  // name: "numberedStrings",
  // type: {
  //   from: "uint256",
  //   to: "string"
  // },
  // value: {
  //   ...Object.assign({}, ...generateArray(7).map(
  //     (value, idx) => ({ [value]: faker.lorem.slug(idx) })
  //   ))
  // }
  // }, {
  name: "stringsToStrings",
  type: {
    from: "string",
    to: "string"
  },
  value: (0, _extends3.default)({}, (0, _assign2.default)({}, ...[0, 1, 2, 3, 4].map(idx => ({ [_faker2.default.lorem.slug(idx)]: _faker2.default.lorem.slug(idx) }))))
}];

debug("mappingFixtures %O", mappingFixtures);

describe("Decoding", function () {

  /*
   * Storage Tests
   */
  (0, _helpers.describeDecoding)("Storage Variables", commonFixtures, _selectors2.default.current.state.storage, (contractName, fixtures) => {
    return `pragma solidity ^0.4.23;

contract ${contractName} {

  event Done();

  // declarations
  ${fixtures.map(({ type, name }) => `${type} ${name};`).join("\n  ")}

  function run() public {
    ${fixtures.map(({ name, value }) => `${name} = ${(0, _stringify2.default)(value)};`).join("\n    ")}

    emit Done();
  }
}
`;
  });

  (0, _helpers.describeDecoding)("Mapping Variables", mappingFixtures, _selectors2.default.current.state.storage, (contractName, fixtures) => {
    return `pragma solidity ^0.4.24;

contract ${contractName} {
  event Done();

  // declarations
  ${fixtures.map(({ name, type: { from, to } }) => `mapping (${from} => ${to}) ${name};`).join("\n  ")}

  function run() public {
    ${fixtures.map(({ name, type: { from }, value }) => (0, _entries2.default)(value).map(([k, v]) => from === "string" ? `${name}["${k}"] = ${(0, _stringify2.default)(v)};` : `${name}[${k}] = ${(0, _stringify2.default)(v)};`).join("\n    ")).join("\n\n    ")}

    emit Done();
  }
}
`;
  });

  /*
   * Memory Tests
   */
  (0, _helpers.describeDecoding)("Memory Variables", commonFixtures, _selectors2.default.current.state.memory, (contractName, fixtures) => {
    const separator = ";\n    ";

    function declareAssign({ name, type, value }) {
      if (type.indexOf("[]") != -1) {
        // array, must `new`
        let declare = `${type} memory ${name} = new ${type}(${value.length})`;
        let assigns = value.map((k, i) => `${name}[${i}] = ${k}`);
        return `${declare}${separator}${assigns.join(separator)}`;
      } else {
        return `${type} memory ${name} = ${(0, _stringify2.default)(value)}`;
      }
    }

    return `pragma solidity ^0.4.23;

contract ${contractName} {

  event Done();

  function run() public {
    uint i;
    // declarations
    ${fixtures.map(declareAssign).join(separator)};

    emit Done();
  }
}
`;
  });
});

/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/json/stringify");

/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = require("faker");

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = require("change-case");

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _chai = __webpack_require__(12);

var _bignumber = __webpack_require__(20);

var _utils = __webpack_require__(11);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("test:data:decode:utils");

describe("Utils", function () {
  describe("typeClass()", function () {
    it("handles mappings", function () {
      let definition = {
        typeDescriptions: {
          typeIdentifier: "t_mapping$_t_uint256_$_t_uint256_$"
        }
      };

      _chai.assert.equal(utils.typeClass(definition), "mapping");
    });
  });

  describe("toBigNumber()", function () {
    it("returns correct value", function () {
      let bytes = [0xf5, 0xe2, 0xc5, 0x17];
      let expectedValue = new _bignumber.BigNumber("f5e2c517", 16);

      let result = utils.toBigNumber(bytes);

      _chai.assert.equal(result.toString(), expectedValue.toString());
    });
  });

  describe("toSignedBigNumber()", function () {
    it("returns correct negative value", function () {
      let bytes = [0xf5, 0xe2, 0xc5, 0x17]; // starts with 0b1
      let raw = new _bignumber.BigNumber("f5e2c517", 16);
      let bitfipped = new _bignumber.BigNumber(raw.toString(2).replace(/0/g, "x").replace(/1/g, "0").replace(/x/g, "1"), 2);

      let expectedValue = bitfipped.plus(1).negated();

      let result = utils.toSignedBigNumber(bytes);

      _chai.assert.equal(result.toString(), expectedValue.toString());
    });

    it("returns correct positive value", function () {
      let bytes = [0x05, 0xe2, 0xc5, 0x17]; // starts with 0b0
      let raw = new _bignumber.BigNumber("05e2c517", 16);
      let expectedValue = raw;

      let result = utils.toSignedBigNumber(bytes);

      _chai.assert.equal(result.toString(), expectedValue.toString());
    });
  });

  describe("toHexString()", function () {
    it("returns correct representation with full bytes", function () {
      // ie, 0x00 instead of 0x0
      _chai.assert.equal(utils.toHexString([0x05, 0x11]), "0x0511");
      _chai.assert.equal(utils.toHexString([0xff, 0x00, 0xff]), "0xff00ff");
    });

    it("allows removing leading zeroes", function () {
      _chai.assert.equal(utils.toHexString([0x00, 0x00, 0xcc], true), "0xcc");
    });
  });
});

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _asyncToGenerator2 = __webpack_require__(7);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _chai = __webpack_require__(12);

var _ganacheCli = __webpack_require__(16);

var _ganacheCli2 = _interopRequireDefault(_ganacheCli);

var _web = __webpack_require__(8);

var _web2 = _interopRequireDefault(_web);

var _helpers = __webpack_require__(13);

var _debugger = __webpack_require__(18);

var _debugger2 = _interopRequireDefault(_debugger);

var _selectors = __webpack_require__(2);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("test:solidity");

const __OUTER = `
pragma solidity ^0.4.18;

import "./Inner.sol";

contract Outer {
  event Called();

  Inner inner;

  function Outer(address _inner) {
    inner = Inner(_inner);
  }

  function runSingle() public {
  }

  function run() public {
    inner.run();
  }
}
`;

const __INNER = `
pragma solidity ^0.4.18;

contract Inner {
  function run() public {
  }
}
`;

const __MIGRATION = `
let Outer = artifacts.require("Outer");
let Inner = artifacts.require("Inner");

module.exports = function(deployer) {
  return deployer
    .then(function() {
      return deployer.deploy(Inner);
    })
    .then(function() {
      return Inner.deployed();
    })
    .then(function(inner) {
      return deployer.deploy(Outer, inner.address);
    });
};
`;

let sources = {
  "Inner.sol": __INNER,
  "Outer.sol": __OUTER
};

let migrations = {
  "2_deploy_contracts.js": __MIGRATION
};

describe("EVM Debugging", function () {
  var provider;
  var web3;

  var abstractions;
  var artifacts;
  var files;

  before("Create Provider", (0, _asyncToGenerator3.default)(function* () {
    provider = _ganacheCli2.default.provider({ seed: "debugger", gasLimit: 7000000 });
    web3 = new _web2.default(provider);
  }));

  before("Prepare contracts and artifacts", (0, _asyncToGenerator3.default)(function* () {
    this.timeout(30000);

    let prepared = yield (0, _helpers.prepareContracts)(provider, sources, migrations);
    abstractions = prepared.abstractions;
    artifacts = prepared.artifacts;
    files = prepared.files;
  }));

  describe("Function Depth", function () {
    it("remains at 1 in absence of cross-contract calls", (0, _asyncToGenerator3.default)(function* () {
      const maxExpected = 1;

      let instance = yield abstractions.Inner.deployed();
      let receipt = yield instance.run();
      let txHash = receipt.tx;

      let bugger = yield _debugger2.default.forTx(txHash, {
        provider,
        files,
        contracts: artifacts
      });

      let session = bugger.connect();
      var stepped; // session steppers return false when done

      do {
        stepped = session.stepNext();

        let actual = session.view(_selectors2.default.current.callstack).length;

        _chai.assert.isAtMost(actual, maxExpected);
      } while (stepped);
    }));

    it("tracks callstack correctly", (0, _asyncToGenerator3.default)(function* () {
      // prepare
      let instance = yield abstractions.Outer.deployed();
      let receipt = yield instance.run();
      let txHash = receipt.tx;

      let bugger = yield _debugger2.default.forTx(txHash, {
        provider,
        files,
        contracts: artifacts
      });

      let session = bugger.connect();

      // follow callstack length values in list
      // see source above
      let expectedDepthSequence = [1, 2, 1, 0];
      let actualSequence = [session.view(_selectors2.default.current.callstack).length];

      var stepped;

      do {
        stepped = session.stepNext();

        let currentDepth = session.view(_selectors2.default.current.callstack).length;
        let lastKnown = actualSequence[actualSequence.length - 1];

        if (currentDepth !== lastKnown) {
          actualSequence.push(currentDepth);
        }
      } while (stepped);

      _chai.assert.deepEqual(actualSequence, expectedDepthSequence);
    }));
  });
});

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _asyncToGenerator2 = __webpack_require__(7);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _chai = __webpack_require__(12);

var _ganacheCli = __webpack_require__(16);

var _ganacheCli2 = _interopRequireDefault(_ganacheCli);

var _web = __webpack_require__(8);

var _web2 = _interopRequireDefault(_web);

var _helpers = __webpack_require__(13);

var _debugger = __webpack_require__(18);

var _debugger2 = _interopRequireDefault(_debugger);

var _selectors = __webpack_require__(6);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("test:solidity");

const __SINGLE_CALL = `
pragma solidity ^0.4.18;

contract SingleCall {
  event Called();

  function run() public {
    Called();
  }
}
`;

const __NESTED_CALL = `pragma solidity ^0.4.18;

contract NestedCall {
  event First();
  event Second();

  // run()
  //   first()    1
  //     inner()  2
  //       event  3
  //              2
  //   second     1
  //     event    2
  //              1
  function run() public {
    first();
    second();
  }

  function first() public {
    inner();
  }

  function inner() public {
    First();
  }

  function second() public {
    Second();
  }

}
`;

let sources = {
  "SingleCall.sol": __SINGLE_CALL,
  "NestedCall.sol": __NESTED_CALL
};

describe("Solidity Debugging", function () {
  var provider;
  var web3;

  var abstractions;
  var artifacts;
  var files;

  before("Create Provider", (0, _asyncToGenerator3.default)(function* () {
    provider = _ganacheCli2.default.provider({ seed: "debugger", gasLimit: 7000000 });
    web3 = new _web2.default(provider);
  }));

  before("Prepare contracts and artifacts", (0, _asyncToGenerator3.default)(function* () {
    this.timeout(30000);

    let prepared = yield (0, _helpers.prepareContracts)(provider, sources);
    abstractions = prepared.abstractions;
    artifacts = prepared.artifacts;
    files = prepared.files;
  }));

  it("exposes functionality to stop at breakpoints", (0, _asyncToGenerator3.default)(function* () {
    // prepare
    let instance = yield abstractions.NestedCall.deployed();
    let receipt = yield instance.run();
    let txHash = receipt.tx;

    let bugger = yield _debugger2.default.forTx(txHash, {
      provider,
      files,
      contracts: artifacts
    });

    let session = bugger.connect();

    // at `second();`
    let breakpoint = { "address": instance.address, line: 16 };
    let breakpointStopped = false;

    do {
      session.continueUntil(breakpoint);

      if (!session.finished) {
        let range = yield session.view(_selectors2.default.current.sourceRange);
        _chai.assert.equal(range.lines.start.line, 16);

        breakpointStopped = true;
      }
    } while (!session.finished);
  }));

  describe("Function Depth", function () {
    it("remains at 1 in absence of inner function calls", (0, _asyncToGenerator3.default)(function* () {
      const maxExpected = 1;

      let instance = yield abstractions.SingleCall.deployed();
      let receipt = yield instance.run();
      let txHash = receipt.tx;

      let bugger = yield _debugger2.default.forTx(txHash, {
        provider,
        files,
        contracts: artifacts
      });

      let session = bugger.connect();
      var stepped; // session steppers return false when done

      do {
        stepped = session.stepNext();

        let actual = session.view(_selectors2.default.current.functionDepth);

        _chai.assert.isAtMost(actual, maxExpected);
      } while (stepped);
    }));

    it("spelunks correctly", (0, _asyncToGenerator3.default)(function* () {
      // prepare
      let instance = yield abstractions.NestedCall.deployed();
      let receipt = yield instance.run();
      let txHash = receipt.tx;

      let bugger = yield _debugger2.default.forTx(txHash, {
        provider,
        files,
        contracts: artifacts
      });

      let session = bugger.connect();

      // follow functionDepth values in list
      // see source above
      let expectedDepthSequence = [1, 2, 3, 2, 1, 2, 1, 0];
      let actualSequence = [session.view(_selectors2.default.current.functionDepth)];

      var stepped;

      do {
        stepped = session.stepNext();

        let currentDepth = session.view(_selectors2.default.current.functionDepth);
        let lastKnown = actualSequence[actualSequence.length - 1];

        if (currentDepth !== lastKnown) {
          actualSequence.push(currentDepth);
        }
      } while (stepped);

      _chai.assert.deepEqual(actualSequence, expectedDepthSequence);
    }));
  });
});

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrL2Jvb3RzdHJhcCA5MmIwODU1MTE4N2VjMTNkNzM4ZSIsImV4dGVybmFsIFwiZGVidWdcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9lbnRyaWVzXCIiLCJsaWIvZXZtL3NlbGVjdG9ycy9pbmRleC5qcyIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ25cIiIsImxpYi9oZWxwZXJzL2luZGV4LmpzIiwibGliL3NvbGlkaXR5L3NlbGVjdG9ycy9pbmRleC5qcyIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIiIsImV4dGVybmFsIFwid2ViM1wiIiwiZXh0ZXJuYWwgXCJyZXNlbGVjdC10cmVlXCIiLCJleHRlcm5hbCBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiIiwibGliL2RhdGEvZGVjb2RlL3V0aWxzLmpzIiwiZXh0ZXJuYWwgXCJjaGFpXCIiLCJ0ZXN0L2hlbHBlcnMuanMiLCJsaWIvYXN0L3NlbGVjdG9ycy9pbmRleC5qcyIsImV4dGVybmFsIFwicmVkdXhcIiIsImV4dGVybmFsIFwiZ2FuYWNoZS1jbGlcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzXCIiLCJsaWIvZGVidWdnZXIuanMiLCJsaWIvdHJhY2Uvc2VsZWN0b3JzL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJiaWdudW1iZXIuanNcIiIsImxpYi90cmFjZS9hY3Rpb25zL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0XCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCIiLCJleHRlcm5hbCBcImpzb24tcG9pbnRlclwiIiwibGliL3Nlc3Npb24vYWN0aW9ucy9pbmRleC5qcyIsImxpYi9kYXRhL3NlbGVjdG9ycy9pbmRleC5qcyIsImV4dGVybmFsIFwidHJ1ZmZsZS1leHBlY3RcIiIsImxpYi9hc3QvbWFwLmpzIiwibGliL2NvbnRyb2xsZXIvYWN0aW9ucy9pbmRleC5qcyIsImxpYi9kYXRhL3NhZ2FzL2luZGV4LmpzIiwibGliL2RhdGEvYWN0aW9ucy9pbmRleC5qcyIsImxpYi90cmFjZS9zYWdhcy9pbmRleC5qcyIsImxpYi9zb2xpZGl0eS9hY3Rpb25zL2luZGV4LmpzIiwibGliL2V2bS9hY3Rpb25zL2luZGV4LmpzIiwibGliL3Nlc3Npb24vc2VsZWN0b3JzL2luZGV4LmpzIiwidGVzdC9kYXRhL2RlY29kZS9oZWxwZXJzLmpzIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9tb2NoYS13ZWJwYWNrL2xpYi9lbnRyeS5qcyIsInRlc3QvYXN0LmpzIiwiZXh0ZXJuYWwgXCJwYXRoXCIiLCJleHRlcm5hbCBcImZzLWV4dHJhXCIiLCJleHRlcm5hbCBcImFzeW5jXCIiLCJleHRlcm5hbCBcInRydWZmbGUtd29ya2Zsb3ctY29tcGlsZVwiIiwiZXh0ZXJuYWwgXCJ0cnVmZmxlLWRlYnVnLXV0aWxzXCIiLCJleHRlcm5hbCBcInRydWZmbGUtYXJ0aWZhY3RvclwiIiwiZXh0ZXJuYWwgXCJ0cnVmZmxlLW1pZ3JhdGVcIiIsImV4dGVybmFsIFwidHJ1ZmZsZS1ib3hcIiIsImV4dGVybmFsIFwidHJ1ZmZsZS1yZXNvbHZlclwiIiwibGliL3Nlc3Npb24vaW5kZXguanMiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvdmFsdWVzXCIiLCJleHRlcm5hbCBcInRydWZmbGUtc29saWRpdHktdXRpbHNcIiIsImV4dGVybmFsIFwidHJ1ZmZsZS1jb2RlLXV0aWxzXCIiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL25vZGUtaW50ZXJ2YWwtdHJlZS9saWIvaW5kZXguanMiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL3NoYWxsb3dlcXVhbC9pbmRleC5qcyIsImxpYi9zdG9yZS9pbmRleC5qcyIsImxpYi9zdG9yZS90ZXN0LmpzIiwibGliL3N0b3JlL2NvbW1vbi5qcyIsImV4dGVybmFsIFwicmVkdXgtc2FnYVwiIiwiZXh0ZXJuYWwgXCJyZWR1eC1jbGktbG9nZ2VyXCIiLCJsaWIvc2Vzc2lvbi9zYWdhcy9pbmRleC5qcyIsImxpYi9hc3Qvc2FnYXMvaW5kZXguanMiLCJsaWIvZGF0YS9kZWNvZGUvaW5kZXguanMiLCJsaWIvZGF0YS9kZWNvZGUvbWVtb3J5LmpzIiwibGliL2RhdGEvZGVjb2RlL3N0b3JhZ2UuanMiLCJsaWIvYXN0L2FjdGlvbnMvaW5kZXguanMiLCJsaWIvY29udHJvbGxlci9zYWdhcy9pbmRleC5qcyIsImxpYi9jb250cm9sbGVyL3NlbGVjdG9ycy9pbmRleC5qcyIsImxpYi9zb2xpZGl0eS9zYWdhcy9pbmRleC5qcyIsImxpYi9ldm0vc2FnYXMvaW5kZXguanMiLCJsaWIvd2ViMy9zYWdhcy9pbmRleC5qcyIsImxpYi93ZWIzL2FjdGlvbnMvaW5kZXguanMiLCJsaWIvd2ViMy9hZGFwdGVyLmpzIiwibGliL3Nlc3Npb24vcmVkdWNlcnMuanMiLCJsaWIvZGF0YS9yZWR1Y2Vycy5qcyIsImxpYi9ldm0vcmVkdWNlcnMuanMiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tXCIiLCJsaWIvc29saWRpdHkvcmVkdWNlcnMuanMiLCJsaWIvdHJhY2UvcmVkdWNlcnMuanMiLCJ0ZXN0L2NvbnRleHQuanMiLCJ0ZXN0L2RhdGEvZGVjb2RlL2RlY29kaW5nLmpzIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnlcIiIsImV4dGVybmFsIFwiZmFrZXJcIiIsImV4dGVybmFsIFwiY2hhbmdlLWNhc2VcIiIsInRlc3QvZGF0YS9kZWNvZGUvdXRpbHMuanMiLCJ0ZXN0L2V2bS5qcyIsInRlc3Qvc29saWRpdHkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJEZWJ1Z2dlclwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJEZWJ1Z2dlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJEZWJ1Z2dlclwiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMzcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDkyYjA4NTUxMTg3ZWMxM2Q3MzhlIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZGVidWdcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJkZWJ1Z1wiXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZW50cmllc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZW50cmllc1wiXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpldm06c2VsZWN0b3JzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5pbXBvcnQgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9zZWxlY3RvcnNcIjtcblxuY29uc3QgV09SRF9TSVpFID0gMHgyMDtcblxuLyoqXG4gKiBjcmVhdGUgRVZNLWxldmVsIHNlbGVjdG9ycyBmb3IgYSBnaXZlbiB0cmFjZSBzdGVwIHNlbGVjdG9yXG4gKiBtYXkgc3BlY2lmeSBhZGRpdGlvbmFsIHNlbGVjdG9ycyB0byBpbmNsdWRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0ZXBTZWxlY3RvcnMoc3RlcCwgc3RhdGUgPSBudWxsKSB7XG4gIGxldCBiYXNlID0ge1xuICAgIC8qKlxuICAgICAqIC50cmFjZVxuICAgICAqXG4gICAgICogdHJhY2Ugc3RlcCBpbmZvIHJlbGF0ZWQgdG8gb3BlcmF0aW9uXG4gICAgICovXG4gICAgdHJhY2U6IGNyZWF0ZUxlYWYoXG4gICAgICBbc3RlcF0sICh7Z2FzQ29zdCwgb3AsIHBjfSkgPT4gKHtnYXNDb3N0LCBvcCwgcGN9KVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAucHJvZ3JhbUNvdW50ZXJcbiAgICAgKi9cbiAgICBwcm9ncmFtQ291bnRlcjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vdHJhY2VcIl0sIChzdGVwKSA9PiBzdGVwLnBjXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIC5pc0p1bXBcbiAgICAgKi9cbiAgICBpc0p1bXA6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3RyYWNlXCJdLCAoc3RlcCkgPT4gKFxuICAgICAgICBzdGVwLm9wICE9IFwiSlVNUERFU1RcIiAmJiBzdGVwLm9wLmluZGV4T2YoXCJKVU1QXCIpID09IDBcbiAgICAgIClcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogLmlzQ2FsbFxuICAgICAqXG4gICAgICogd2hldGhlciB0aGUgb3Bjb2RlIHdpbGwgc3dpdGNoIHRvIGFub3RoZXIgY2FsbGluZyBjb250ZXh0XG4gICAgICovXG4gICAgaXNDYWxsOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi90cmFjZVwiXSwgKHN0ZXApID0+IHN0ZXAub3AgPT0gXCJDQUxMXCIgfHwgc3RlcC5vcCA9PSBcIkRFTEVHQVRFQ0FMTFwiXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIC5pc0NyZWF0ZVxuICAgICAqL1xuICAgIGlzQ3JlYXRlOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi90cmFjZVwiXSwgKHN0ZXApID0+IHN0ZXAub3AgPT0gXCJDUkVBVEVcIlxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuaXNIYWx0aW5nXG4gICAgICpcbiAgICAgKiB3aGV0aGVyIHRoZSBpbnN0cnVjdGlvbiBoYWx0cyBvciByZXR1cm5zIGZyb20gYSBjYWxsaW5nIGNvbnRleHRcbiAgICAgKi9cbiAgICBpc0hhbHRpbmc6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3RyYWNlXCJdLCAoc3RlcCkgPT4gc3RlcC5vcCA9PSBcIlNUT1BcIiB8fCBzdGVwLm9wID09IFwiUkVUVVJOXCJcbiAgICApXG4gIH07XG5cbiAgaWYgKHN0YXRlKSB7XG4gICAgY29uc3QgaXNSZWxhdGl2ZSA9IChwYXRoKSA9PiAoXG4gICAgICB0eXBlb2YgcGF0aCA9PSBcInN0cmluZ1wiICYmIChcbiAgICAgICAgcGF0aC5zdGFydHNXaXRoKFwiLi9cIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiLi4vXCIpXG4gICAgICApXG4gICAgKTtcblxuICAgIGlmIChpc1JlbGF0aXZlKHN0YXRlKSkge1xuICAgICAgc3RhdGUgPSBgLi4vJHtzdGF0ZX1gO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oYmFzZSwge1xuICAgICAgLyoqXG4gICAgICAgKiAuY2FsbEFkZHJlc3NcbiAgICAgICAqXG4gICAgICAgKiBhZGRyZXNzIHRyYW5zZmVycmVkIHRvIGJ5IGNhbGwgb3BlcmF0aW9uXG4gICAgICAgKi9cbiAgICAgIGNhbGxBZGRyZXNzOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIuL2lzQ2FsbFwiLCBcIi4vdHJhY2VcIiwgc3RhdGVdLFxuXG4gICAgICAgIChtYXRjaGVzLCBzdGVwLCB7c3RhY2t9KSA9PiB7XG4gICAgICAgICAgaWYgKCFtYXRjaGVzKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgIGxldCBhZGRyZXNzID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl1cbiAgICAgICAgICBhZGRyZXNzID0gXCIweFwiICsgYWRkcmVzcy5zdWJzdHJpbmcoMjQpO1xuICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIC5jcmVhdGVCaW5hcnlcbiAgICAgICAqXG4gICAgICAgKiBiaW5hcnkgY29kZSB0byBleGVjdXRlIHZpYSBjcmVhdGUgb3BlcmF0aW9uXG4gICAgICAgKi9cbiAgICAgIGNyZWF0ZUJpbmFyeTogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiLi9pc0NyZWF0ZVwiLCBcIi4vdHJhY2VcIiwgc3RhdGVdLFxuXG4gICAgICAgIChtYXRjaGVzLCBzdGVwLCB7c3RhY2ssIG1lbW9yeX0pID0+IHtcbiAgICAgICAgICBpZiAoIW1hdGNoZXMpIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgLy8gR2V0IHRoZSBjb2RlIHRoYXQncyBnb2luZyB0byBiZSBjcmVhdGVkIGZyb20gbWVtb3J5LlxuICAgICAgICAgIC8vIE5vdGUgd2UgbXVsdGlwbHkgYnkgMiBiZWNhdXNlIHRoZXNlIG9mZnNldHMgYXJlIGluIGJ5dGVzLlxuICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHBhcnNlSW50KHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLCAxNikgKiAyO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHN0YWNrW3N0YWNrLmxlbmd0aCAtIDNdLCAxNikgKiAyO1xuXG4gICAgICAgICAgcmV0dXJuIFwiMHhcIiArIG1lbW9yeS5qb2luKFwiXCIpLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufVxuXG5jb25zdCBldm0gPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuICAvKipcbiAgICogZXZtLnN0YXRlXG4gICAqL1xuICBzdGF0ZTogKHN0YXRlKSA9PiBzdGF0ZS5ldm0sXG5cbiAgLyoqXG4gICAqIGV2bS5pbmZvXG4gICAqL1xuICBpbmZvOiB7XG4gICAgLyoqXG4gICAgICogZXZtLmluZm8uY29udGV4dHNcbiAgICAgKi9cbiAgICBjb250ZXh0czogY3JlYXRlTGVhZihbJy9zdGF0ZSddLCAoc3RhdGUpID0+IHN0YXRlLmluZm8uY29udGV4dHMuYnlDb250ZXh0KSxcblxuICAgIC8qKlxuICAgICAqIGV2bS5pbmZvLmluc3RhbmNlc1xuICAgICAqL1xuICAgIGluc3RhbmNlczogY3JlYXRlTGVhZihbJy9zdGF0ZSddLCAoc3RhdGUpID0+IHN0YXRlLmluZm8uaW5zdGFuY2VzLmJ5QWRkcmVzcyksXG5cbiAgICAvKipcbiAgICAgKiBldm0uaW5mby5iaW5hcmllc1xuICAgICAqL1xuICAgIGJpbmFyaWVzOiB7XG4gICAgICBfOiBjcmVhdGVMZWFmKFsnL3N0YXRlJ10sIChzdGF0ZSkgPT4gc3RhdGUuaW5mby5jb250ZXh0cy5ieUJpbmFyeSksXG5cbiAgICAgIC8qKlxuICAgICAgICogZXZtLmluZm8uYmluYXJpZXMuc2VhcmNoXG4gICAgICAgKlxuICAgICAgICogcmV0dXJucyBmdW5jdGlvbiAoYmluYXJ5KSA9PiBjb250ZXh0XG4gICAgICAgKi9cbiAgICAgIHNlYXJjaDogY3JlYXRlTGVhZihbJy4vXyddLCAoYmluYXJpZXMpID0+IHtcbiAgICAgICAgLy8gSEFDSyBpZ25vcmUgbGluayByZWZlcmVuY2VzIGZvciBzZWFyY2hcbiAgICAgICAgLy8gbGluayByZWZlcmVuY2VzIGNvbWUgaW4gdHdvIGZvcm1zOiB3aXRoIHVuZGVyc2NvcmVzIG9yIGFsbCB6ZXJvZXNcbiAgICAgICAgLy8gdGhlIHVuZGVyc2NvcmUgZm9ybWF0IGlzIHVzZWQgYnkgVHJ1ZmZsZSB0byByZWZlcmVuY2UgbGlua3MgYnkgbmFtZVxuICAgICAgICAvLyB6ZXJvZXMgYXJlIHVzZWQgYnkgc29sYyBkaXJlY3RseSwgYXMgbGlicmFyaWVzIGluamVjdCB0aGVpciBvd25cbiAgICAgICAgLy8gYWRkcmVzcyBhdCBDUkVBVEUtdGltZVxuICAgICAgICBjb25zdCB0b1JlZ0V4cCA9IChiaW5hcnkpID0+XG4gICAgICAgICAgbmV3IFJlZ0V4cChgXiR7YmluYXJ5LnJlcGxhY2UoL19fLnszOH18MHs0MH0vZywgXCIuezQwfVwiKX1gKVxuXG4gICAgICAgIGxldCBtYXRjaGVycyA9IE9iamVjdC5lbnRyaWVzKGJpbmFyaWVzKVxuICAgICAgICAgIC5tYXAoIChbYmluYXJ5LCB7Y29udGV4dH1dKSA9PiAoe1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHJlZ2V4OiB0b1JlZ0V4cChiaW5hcnkpXG4gICAgICAgICAgfSkpXG5cbiAgICAgICAgcmV0dXJuIChiaW5hcnkpID0+IG1hdGNoZXJzXG4gICAgICAgICAgLmZpbHRlciggKHsgY29udGV4dCwgcmVnZXggfSkgPT4gYmluYXJ5Lm1hdGNoKHJlZ2V4KSApXG4gICAgICAgICAgLm1hcCggKHsgY29udGV4dCB9KSA9PiAoeyBjb250ZXh0IH0pIClcbiAgICAgICAgICBbMF0gfHwgbnVsbDtcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBldm0uY3VycmVudFxuICAgKi9cbiAgY3VycmVudDoge1xuXG4gICAgLyoqXG4gICAgICogZXZtLmN1cnJlbnQuY2FsbHN0YWNrXG4gICAgICovXG4gICAgY2FsbHN0YWNrOiAoc3RhdGUpID0+IHN0YXRlLmV2bS5wcm9jLmNhbGxzdGFjayxcblxuICAgIC8qKlxuICAgICAqIGV2bS5jdXJyZW50LmNhbGxcbiAgICAgKi9cbiAgICBjYWxsOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9jYWxsc3RhY2tcIl0sXG5cbiAgICAgIChzdGFjaykgPT4gc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gOiB7fVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5jb250ZXh0XG4gICAgICovXG4gICAgY29udGV4dDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vY2FsbFwiLCBcIi9pbmZvL2luc3RhbmNlc1wiLCBcIi9pbmZvL2JpbmFyaWVzL3NlYXJjaFwiLCBcIi9pbmZvL2NvbnRleHRzXCJdLFxuXG4gICAgICAoe2FkZHJlc3MsIGJpbmFyeX0sIGluc3RhbmNlcywgc2VhcmNoLCBjb250ZXh0cykgPT4ge1xuICAgICAgICBsZXQgcmVjb3JkO1xuICAgICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICAgIHJlY29yZCA9IGluc3RhbmNlc1thZGRyZXNzXTtcbiAgICAgICAgICBiaW5hcnkgPSByZWNvcmQuYmluYXJ5XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjb3JkID0gc2VhcmNoKGJpbmFyeSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29udGV4dCA9IGNvbnRleHRzWyhyZWNvcmQgfHwge30pLmNvbnRleHRdO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICBiaW5hcnlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5zdGF0ZVxuICAgICAqXG4gICAgICogZXZtIHN0YXRlIGluZm86IGFzIG9mIGxhc3Qgb3BlcmF0aW9uLCBiZWZvcmUgb3AgZGVmaW5lZCBpbiBzdGVwXG4gICAgICovXG4gICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oe30sIC4uLihcbiAgICAgIFtcbiAgICAgICAgXCJkZXB0aFwiLFxuICAgICAgICBcImVycm9yXCIsXG4gICAgICAgIFwiZ2FzXCIsXG4gICAgICAgIFwibWVtb3J5XCIsXG4gICAgICAgIFwic3RhY2tcIixcbiAgICAgICAgXCJzdG9yYWdlXCJcbiAgICAgIF0ubWFwKCAocGFyYW0pID0+ICh7XG4gICAgICAgIFtwYXJhbV06IGNyZWF0ZUxlYWYoW3RyYWNlLnN0ZXBdLCAoc3RlcCkgPT4gc3RlcFtwYXJhbV0pXG4gICAgICB9KSlcbiAgICApKSxcblxuICAgIC8qKlxuICAgICAqIGV2bS5jdXJyZW50LnN0ZXBcbiAgICAgKi9cbiAgICBzdGVwOiBjcmVhdGVTdGVwU2VsZWN0b3JzKHRyYWNlLnN0ZXAsIFwiLi9zdGF0ZVwiKVxuICB9LFxuXG4gIC8qKlxuICAgKiBldm0ubmV4dFxuICAgKi9cbiAgbmV4dDoge1xuXG4gICAgLyoqXG4gICAgICogZXZtLm5leHQuc3RhdGVcbiAgICAgKlxuICAgICAqIGV2bSBzdGF0ZSBhcyBhIHJlc3VsdCBvZiBuZXh0IHN0ZXAgb3BlcmF0aW9uXG4gICAgICovXG4gICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oe30sIC4uLihcbiAgICAgIFtcbiAgICAgICAgXCJkZXB0aFwiLFxuICAgICAgICBcImVycm9yXCIsXG4gICAgICAgIFwiZ2FzXCIsXG4gICAgICAgIFwibWVtb3J5XCIsXG4gICAgICAgIFwic3RhY2tcIixcbiAgICAgICAgXCJzdG9yYWdlXCJcbiAgICAgIF0ubWFwKCAocGFyYW0pID0+ICh7XG4gICAgICAgIFtwYXJhbV06IGNyZWF0ZUxlYWYoW3RyYWNlLm5leHRdLCAoc3RlcCkgPT4gc3RlcFtwYXJhbV0pXG4gICAgICB9KSlcbiAgICApKSxcblxuICAgIHN0ZXA6IGNyZWF0ZVN0ZXBTZWxlY3RvcnModHJhY2UubmV4dCwgXCIuL3N0YXRlXCIpXG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBldm07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2V2bS9zZWxlY3RvcnMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzXCJcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ25cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGtlY2NhazI1NiBhcyBfa2VjY2FrMjU2LCB0b0hleFN0cmluZyB9IGZyb20gXCJsaWIvZGF0YS9kZWNvZGUvdXRpbHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHByZWZpeE5hbWUocHJlZml4LCBmbikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICduYW1lJywge1xuICAgIHZhbHVlOiBgJHtwcmVmaXh9LiR7Zm4ubmFtZX1gLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogQHJldHVybiAweC1wcmVmaXggc3RyaW5nIG9mIGtlY2NhazI1NiBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYoLi4uYXJncykge1xuICByZXR1cm4gdG9IZXhTdHJpbmcoX2tlY2NhazI1NiguLi5hcmdzKSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2hlbHBlcnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6c29saWRpdHk6c2VsZWN0b3JzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuaW1wb3J0IFNvbGlkaXR5VXRpbHMgZnJvbSBcInRydWZmbGUtc29saWRpdHktdXRpbHNcIjtcbmltcG9ydCBDb2RlVXRpbHMgZnJvbSBcInRydWZmbGUtY29kZS11dGlsc1wiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3NlbGVjdG9yc1wiO1xuXG5mdW5jdGlvbiBnZXRTb3VyY2VSYW5nZShpbnN0cnVjdGlvbiA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGluc3RydWN0aW9uLnN0YXJ0IHx8IDAsXG4gICAgbGVuZ3RoOiBpbnN0cnVjdGlvbi5sZW5ndGggfHwgMCxcbiAgICBsaW5lczogaW5zdHJ1Y3Rpb24ucmFuZ2UgfHwge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgbGluZTogMCwgY29sdW1uOiAwXG4gICAgICB9LFxuICAgICAgZW5kOiB7XG4gICAgICAgIGxpbmU6IDAsIGNvbHVtbjogMFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxubGV0IHNvbGlkaXR5ID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIHNvbGlkaXR5LnN0YXRlXG4gICAqL1xuICBzdGF0ZTogKHN0YXRlKSA9PiBzdGF0ZS5zb2xpZGl0eSxcblxuICAvKipcbiAgICogc29saWRpdHkuaW5mb1xuICAgKi9cbiAgaW5mbzoge1xuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmluZm8uc291cmNlc1xuICAgICAqL1xuICAgIHNvdXJjZXM6IGNyZWF0ZUxlYWYoWycvc3RhdGUnXSwgKHN0YXRlKSA9PiBzdGF0ZS5pbmZvLnNvdXJjZXMuYnlJZCksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5pbmZvLnNvdXJjZU1hcHNcbiAgICAgKi9cbiAgICBzb3VyY2VNYXBzOiBjcmVhdGVMZWFmKFsnL3N0YXRlJ10sIChzdGF0ZSkgPT4gc3RhdGUuaW5mby5zb3VyY2VNYXBzLmJ5Q29udGV4dClcbiAgfSxcblxuICAvKipcbiAgICogc29saWRpdHkuY3VycmVudFxuICAgKi9cbiAgY3VycmVudDoge1xuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5zb3VyY2VNYXBcbiAgICAgKi9cbiAgICBzb3VyY2VNYXA6IGNyZWF0ZUxlYWYoXG4gICAgICBbZXZtLmN1cnJlbnQuY29udGV4dCwgXCIvaW5mby9zb3VyY2VNYXBzXCJdLFxuXG4gICAgICAoe2NvbnRleHR9LCBzb3VyY2VNYXBzKSA9PiBzb3VyY2VNYXBzW2NvbnRleHRdIHx8IHt9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuZnVuY3Rpb25EZXB0aFxuICAgICAqL1xuICAgIGZ1bmN0aW9uRGVwdGg6IChzdGF0ZSkgPT4gc3RhdGUuc29saWRpdHkucHJvYy5mdW5jdGlvbkRlcHRoLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5pbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBpbnN0cnVjdGlvbnM6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIvaW5mby9zb3VyY2VzXCIsIGV2bS5jdXJyZW50LmNvbnRleHQsIFwiLi9zb3VyY2VNYXBcIl0sXG5cbiAgICAgIChzb3VyY2VzLCB7YmluYXJ5fSwge3NvdXJjZU1hcH0pID0+IHtcbiAgICAgICAgbGV0IGluc3RydWN0aW9ucyA9IENvZGVVdGlscy5wYXJzZUNvZGUoYmluYXJ5KTtcblxuICAgICAgICBpZiAoIXNvdXJjZU1hcCkge1xuICAgICAgICAgIC8vIExldCdzIGNyZWF0ZSBhIHNvdXJjZSBtYXAgdG8gdXNlIHNpbmNlIG5vbmUgZXhpc3RzLiBUaGlzIHNvdXJjZSBtYXBcbiAgICAgICAgICAvLyBtYXBzIGp1c3QgYXMgbWFueSByYW5nZXMgYXMgdGhlcmUgYXJlIGluc3RydWN0aW9ucywgYW5kIGVuc3VyZXMgZXZlcnlcbiAgICAgICAgICAvLyBpbnN0cnVjdGlvbiBpcyBtYXJrZWQgYXMgXCJqdW1waW5nIG91dFwiLiBUaGlzIHdpbGwgZW5zdXJlIGFsbFxuICAgICAgICAgIC8vIGF2YWlsYWJsZSBkZWJ1Z2dlciBjb21tYW5kcyBzdGVwIG9uZSBpbnN0cnVjdGlvbiBhdCBhIHRpbWUuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUaGlzIGlzIGtpbmRvZiBhIGhhY2s7IHBlcmhhcHMgdGhpcyBzaG91bGQgYmUgYnJva2VuIG91dCBpbnRvIHNlcGFyYXRlXG4gICAgICAgICAgLy8gY29udGV4dCB0eXBlcy4gVE9ET1xuICAgICAgICAgIHNvdXJjZU1hcCA9IFwiXCI7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNvdXJjZU1hcCArPSBpICsgXCI6XCIgKyBpICsgXCI6MTotMTtcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGluZUFuZENvbHVtbk1hcHBpbmdzID0gT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhzb3VyY2VzKS5tYXAoXG4gICAgICAgICAgICAoW2lkLCB7c291cmNlfV0pID0+ICh7XG4gICAgICAgICAgICAgIFtpZF06IFNvbGlkaXR5VXRpbHMuZ2V0Q2hhcmFjdGVyT2Zmc2V0VG9MaW5lQW5kQ29sdW1uTWFwcGluZyhzb3VyY2UgfHwgXCJcIilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICB2YXIgaHVtYW5SZWFkYWJsZVNvdXJjZU1hcCA9IFNvbGlkaXR5VXRpbHMuZ2V0SHVtYW5SZWFkYWJsZVNvdXJjZU1hcChzb3VyY2VNYXApO1xuXG4gICAgICAgIGxldCBwcmltYXJ5RmlsZSA9IGh1bWFuUmVhZGFibGVTb3VyY2VNYXBbMF0uZmlsZTtcbiAgICAgICAgZGVidWcoXCJwcmltYXJ5RmlsZSAlb1wiLCBwcmltYXJ5RmlsZSk7XG5cbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uc1xuICAgICAgICAgIC5tYXAoIChpbnN0cnVjdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIC8vIGxvb2t1cCBzb3VyY2UgbWFwIGJ5IGluZGV4IGFuZCBhZGQgYGluZGV4YCBwcm9wZXJ0eSB0b1xuICAgICAgICAgICAgLy8gaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZU1hcCA9IGh1bWFuUmVhZGFibGVTb3VyY2VNYXBbaW5kZXhdIHx8IHt9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpbnN0cnVjdGlvbjogeyAuLi5pbnN0cnVjdGlvbiwgaW5kZXggfSxcbiAgICAgICAgICAgICAgc291cmNlTWFwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5tYXAoICh7IGluc3RydWN0aW9uLCBzb3VyY2VNYXB9KSA9PiB7XG4gICAgICAgICAgICAvLyBhZGQgc291cmNlIG1hcCBpbmZvcm1hdGlvbiB0byBpbnN0cnVjdGlvbiwgb3IgZGVmYXVsdHNcbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIGNvbnN0IHsganVtcCwgc3RhcnQgPSAwLCBsZW5ndGggPSAwLCBmaWxlID0gcHJpbWFyeUZpbGUgfSA9IHNvdXJjZU1hcDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVBbmRDb2x1bW5NYXBwaW5nID0gbGluZUFuZENvbHVtbk1hcHBpbmdzW2ZpbGVdIHx8IHt9O1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBsaW5lQW5kQ29sdW1uTWFwcGluZ1tzdGFydF0gfHxcbiAgICAgICAgICAgICAgICB7IGxpbmU6IG51bGwsIGNvbHVtbjogbnVsbCB9LFxuICAgICAgICAgICAgICBlbmQ6IGxpbmVBbmRDb2x1bW5NYXBwaW5nW3N0YXJ0ICsgbGVuZ3RoXSB8fFxuICAgICAgICAgICAgICAgIHsgbGluZTogbnVsbCwgY29sdW1uOiBudWxsIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydC5saW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGRlYnVnKFwic291cmNlTWFwICVvXCIsIHNvdXJjZU1hcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmluc3RydWN0aW9uLFxuXG4gICAgICAgICAgICAgIGp1bXAsXG4gICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICAgIHJhbmdlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb25BdFByb2dyYW1Db3VudGVyXG4gICAgICovXG4gICAgaW5zdHJ1Y3Rpb25BdFByb2dyYW1Db3VudGVyOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9pbnN0cnVjdGlvbnNcIl0sXG5cbiAgICAgIChpbnN0cnVjdGlvbnMpID0+IHtcbiAgICAgICAgbGV0IG1hcCA9IFtdO1xuICAgICAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihpbnN0cnVjdGlvbikge1xuICAgICAgICAgIG1hcFtpbnN0cnVjdGlvbi5wY10gPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZmlsbCBpbiBnYXBzIGluIG1hcCBieSBkZWZhdWx0aW5nIHRvIHRoZSBsYXN0IGtub3duIGluc3RydWN0aW9uXG4gICAgICAgIGxldCBsYXN0U2VlbiA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IFtwYywgaW5zdHJ1Y3Rpb25dIG9mIG1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIGxhc3RTZWVuID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcFtwY10gPSBsYXN0U2VlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5pbnN0cnVjdGlvblxuICAgICAqL1xuICAgIGluc3RydWN0aW9uOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9pbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXJcIiwgZXZtLmN1cnJlbnQuc3RlcC5wcm9ncmFtQ291bnRlcl0sXG5cbiAgICAgIChtYXAsIHBjKSA9PiBtYXBbcGNdIHx8IHt9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuc291cmNlXG4gICAgICovXG4gICAgc291cmNlOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiL2luZm8vc291cmNlc1wiLCBcIi4vaW5zdHJ1Y3Rpb25cIl0sXG5cbiAgICAgIChzb3VyY2VzLCB7ZmlsZTogaWR9KSA9PiBzb3VyY2VzW2lkXSB8fCB7fVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LnNvdXJjZVJhbmdlXG4gICAgICovXG4gICAgc291cmNlUmFuZ2U6IGNyZWF0ZUxlYWYoW1wiLi9pbnN0cnVjdGlvblwiXSwgZ2V0U291cmNlUmFuZ2UpLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5pc1NvdXJjZVJhbmdlRmluYWxcbiAgICAgKi9cbiAgICBpc1NvdXJjZVJhbmdlRmluYWw6IGNyZWF0ZUxlYWYoXG4gICAgICBbXG4gICAgICAgIFwiLi9pbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXJcIixcbiAgICAgICAgZXZtLmN1cnJlbnQuc3RlcC5wcm9ncmFtQ291bnRlcixcbiAgICAgICAgZXZtLm5leHQuc3RlcC5wcm9ncmFtQ291bnRlclxuICAgICAgXSxcblxuICAgICAgKG1hcCwgY3VycmVudCwgbmV4dCkgPT4ge1xuICAgICAgICBpZiAoIW1hcFtuZXh0XSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA9IG1hcFtjdXJyZW50XTtcbiAgICAgICAgbmV4dCA9IG1hcFtuZXh0XTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGN1cnJlbnQuc3RhcnQgIT0gbmV4dC5zdGFydCB8fFxuICAgICAgICAgIGN1cnJlbnQubGVuZ3RoICE9IG5leHQubGVuZ3RoIHx8XG4gICAgICAgICAgY3VycmVudC5maWxlICE9IG5leHQuZmlsZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmlzTXVsdGlsaW5lXG4gICAgICovXG4gICAgaXNNdWx0aWxpbmU6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3NvdXJjZVJhbmdlXCJdLFxuXG4gICAgICAoIHtsaW5lc30gKSA9PiBsaW5lcy5zdGFydC5saW5lICE9IGxpbmVzLmVuZC5saW5lXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQud2lsbEp1bXBcbiAgICAgKi9cbiAgICB3aWxsSnVtcDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0p1bXBdLCAoaXNKdW1wKSA9PiBpc0p1bXApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5qdW1wRGlyZWN0aW9uXG4gICAgICovXG4gICAganVtcERpcmVjdGlvbjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vaW5zdHJ1Y3Rpb25cIl0sIChpID0ge30pID0+IChpLmp1bXAgfHwgXCItXCIpXG4gICAgKVxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc29saWRpdHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3NvbGlkaXR5L3NlbGVjdG9ycy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIlxuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ3ZWIzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwid2ViM1wiXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlc2VsZWN0LXRyZWVcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZXNlbGVjdC10cmVlXCJcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXgtc2FnYS9lZmZlY3RzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVkdXgtc2FnYS9lZmZlY3RzXCJcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpkYXRhOmRlY29kZTp1dGlsc1wiKTtcblxuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcImJpZ251bWJlci5qc1wiO1xuaW1wb3J0IFdlYjMgZnJvbSBcIndlYjNcIjtcblxuZXhwb3J0IGNvbnN0IFdPUkRfU0laRSA9IDB4MjA7XG5leHBvcnQgY29uc3QgTUFYX1dPUkQgPSBuZXcgQmlnTnVtYmVyKDIpLnBvdygyNTYpLm1pbnVzKDEpO1xuXG4vKipcbiAqIHJlY3Vyc2l2ZWx5IGNvbnZlcnRzIGJpZyBudW1iZXJzIGludG8gc29tZXRoaW5nIG5pY2VyIHRvIGxvb2sgYXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuQmlnTnVtYmVycyh2YWx1ZSkge1xuICBpZiAoQmlnTnVtYmVyLmlzQmlnTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS50b051bWJlcigpO1xuXG4gIH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUubWFwICE9IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2YWx1ZS5tYXAoIChpbm5lcikgPT4gY2xlYW5CaWdOdW1iZXJzKGlubmVyKSApO1xuXG4gIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LCAuLi5PYmplY3QuZW50cmllcyh2YWx1ZSlcbiAgICAgICAgLm1hcCggKFtrZXksIGlubmVyXSkgPT4gKHsgW2tleV06IGNsZWFuQmlnTnVtYmVycyhpbm5lcikgfSkgKVxuICAgICk7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIGRlZmluaXRpb24udHlwZURlc2NyaXB0aW9ucy50eXBlSWRlbnRpZmllcjtcbn1cblxuLyoqXG4gKiByZXR1cm5zIGJhc2ljIHR5cGUgY2xhc3MgZm9yIGEgdmFyaWFibGUgZGVmaW5pdGlvbiBub2RlXG4gKiBlLmcuOlxuICogIGB0X3VpbnQyNTZgIGJlY29tZXMgYHVpbnRgXG4gKiAgYHRfc3RydWN0JF9UaGluZ18kMjBfbWVtb3J5X3B0cmAgYmVjb21lcyBgc3RydWN0YFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHlwZUNsYXNzKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pLm1hdGNoKC90XyhbXiRfMC05XSspLylbMV07XG59XG5cbi8qKlxuICogQWxsb2NhdGUgc3RvcmFnZSBmb3IgZ2l2ZW4gdmFyaWFibGUgZGVjbGFyYXRpb25zXG4gKlxuICogUG9zdGNvbmRpdGlvbjogc3RhcnRzIGEgbmV3IHNsb3QgYW5kIG9jY3VwaWVzIHdob2xlIHNsb3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGxvY2F0ZURlY2xhcmF0aW9ucyhcbiAgZGVjbGFyYXRpb25zLFxuICByZWZzLFxuICBzbG90ID0gMCxcbiAgaW5kZXggPSBXT1JEX1NJWkUgLSAxLFxuICBwYXRoID0gW11cbikge1xuICBpZiAoaW5kZXggPCBXT1JEX1NJWkUgLSAxKSB7ICAvLyBzdGFydHMgYSBuZXcgc2xvdFxuICAgIHNsb3QrKztcbiAgICBpbmRleCA9IFdPUkRfU0laRSAtIDE7XG4gIH1cblxuICBsZXQgcGFyZW50RnJvbSA9IHsgc2xvdCwgaW5kZXg6IDAgfTtcbiAgdmFyIHBhcmVudFRvID0geyBzbG90LCBpbmRleDogV09SRF9TSVpFIC0gMSB9O1xuICBsZXQgbWFwcGluZyA9IHt9O1xuXG4gIGZvciAobGV0IGRlY2xhcmF0aW9uIG9mIGRlY2xhcmF0aW9ucykge1xuICAgIGxldCB7IGZyb20sIHRvLCBuZXh0LCBjaGlsZHJlbiB9ID1cbiAgICAgIGFsbG9jYXRlRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIHJlZnMsIHNsb3QsIGluZGV4KTtcblxuICAgIG1hcHBpbmdbZGVjbGFyYXRpb24uaWRdID0geyBmcm9tLCB0bywgbmFtZTogZGVjbGFyYXRpb24ubmFtZSB9O1xuICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtYXBwaW5nW2RlY2xhcmF0aW9uLmlkXS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH1cblxuICAgIHNsb3QgPSBuZXh0LnNsb3Q7XG4gICAgaW5kZXggPSBuZXh0LmluZGV4O1xuXG4gICAgcGFyZW50VG8gPSB7IHNsb3Q6IHRvLnNsb3QsIGluZGV4OiBXT1JEX1NJWkUgLSAxIH07XG4gIH1cblxuICBpZiAoaW5kZXggPCBXT1JEX1NJWkUgLSAxKSB7XG4gICAgc2xvdCsrO1xuICAgIGluZGV4ID0gV09SRF9TSVpFIC0gMTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZnJvbTogcGFyZW50RnJvbSxcbiAgICB0bzogcGFyZW50VG8sXG4gICAgbmV4dDogeyBzbG90LCBpbmRleCB9LFxuICAgIGNoaWxkcmVuOiBtYXBwaW5nXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFsbG9jYXRlVmFsdWUoc2xvdCwgaW5kZXgsIGJ5dGVzKSB7XG4gIGxldCBmcm9tID0gaW5kZXggLSBieXRlcyArIDEgPj0gMCA/XG4gICAgeyBzbG90LCBpbmRleDogaW5kZXggLSBieXRlcyArIDEgfSA6XG4gICAgeyBzbG90OiBzbG90ICsgMSwgaW5kZXg6IFdPUkRfU0laRSAtIGJ5dGVzIH07XG5cbiAgbGV0IHRvID0geyBzbG90OiBmcm9tLnNsb3QsIGluZGV4OiBmcm9tLmluZGV4ICsgYnl0ZXMgLSAxIH07XG5cbiAgbGV0IG5leHQgPSBmcm9tLmluZGV4ID09IDAgP1xuICAgIHsgc2xvdDogZnJvbS5zbG90ICsgMSwgaW5kZXg6IFdPUkRfU0laRSAtIDEgfSA6XG4gICAgeyBzbG90OiBmcm9tLnNsb3QsIGluZGV4OiBmcm9tLmluZGV4IC0gMSB9O1xuXG4gIHJldHVybiB7IGZyb20sIHRvLCBuZXh0IH07XG59XG5cbmZ1bmN0aW9uIGFsbG9jYXRlRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIHJlZnMsIHNsb3QsIGluZGV4KSB7XG4gIGxldCBkZWZpbml0aW9uID0gcmVmc1tkZWNsYXJhdGlvbi5pZF0uZGVmaW5pdGlvbjtcbiAgdmFyIGJ5dGVTaXplID0gc3RvcmFnZVNpemUoZGVmaW5pdGlvbik7ICAvLyB5dW1cblxuICBpZiAodHlwZUNsYXNzKGRlZmluaXRpb24pID09IFwic3RydWN0XCIpIHtcbiAgICBsZXQgc3RydWN0ID0gcmVmc1tkZWZpbml0aW9uLnR5cGVOYW1lLnJlZmVyZW5jZWREZWNsYXJhdGlvbl07XG4gICAgZGVidWcoXCJzdHJ1Y3Q6ICVPXCIsIHN0cnVjdCk7XG5cbiAgICBsZXQgcmVzdWx0ID0gIGFsbG9jYXRlRGVjbGFyYXRpb25zKHN0cnVjdC52YXJpYWJsZXMgfHwgW10sIHJlZnMsIHNsb3QsIGluZGV4KTtcbiAgICBkZWJ1ZyhcInN0cnVjdCByZXN1bHQgJW9cIiwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHR5cGVDbGFzcyhkZWZpbml0aW9uKSA9PSBcIm1hcHBpbmdcIikge1xuXG4gIH1cblxuICByZXR1cm4gYWxsb2NhdGVWYWx1ZShzbG90LCBpbmRleCwgYnl0ZVNpemUpO1xufVxuXG4vKipcbiAqIGUuZy4gdWludDQ4IC0+IDZcbiAqIEByZXR1cm4gc2l6ZSBpbiBieXRlcyBmb3IgZXhwbGljaXQgdHlwZSBzaXplLCBvciBgbnVsbGAgaWYgbm90IHN0YXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BlY2lmaWVkU2l6ZShkZWZpbml0aW9uKSB7XG4gIGxldCBzcGVjaWZpZWQgPSB0eXBlSWRlbnRpZmllcihkZWZpbml0aW9uKS5tYXRjaCgvdF9bYS16XSsoWzAtOV0rKS8pO1xuXG4gIGlmICghc3BlY2lmaWVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgbnVtID0gc3BlY2lmaWVkWzFdO1xuXG4gIHN3aXRjaCAodHlwZUNsYXNzKGRlZmluaXRpb24pKSB7XG4gICAgY2FzZSBcImludFwiOlxuICAgIGNhc2UgXCJ1aW50XCI6XG4gICAgICByZXR1cm4gbnVtIC8gODtcblxuICAgIGNhc2UgXCJieXRlc1wiOlxuICAgICAgcmV0dXJuIG51bTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBkZWJ1ZyhcIlVua25vd24gdHlwZSBmb3Igc2l6ZSBzcGVjaWZpY2F0aW9uOiAlc1wiLCB0eXBlSWRlbnRpZmllcihkZWZpbml0aW9uKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0b3JhZ2VTaXplKGRlZmluaXRpb24pIHtcbiAgc3dpdGNoICh0eXBlQ2xhc3MoZGVmaW5pdGlvbikpIHtcbiAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgcmV0dXJuIDE7XG5cbiAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgcmV0dXJuIDIwO1xuXG4gICAgY2FzZSBcImludFwiOlxuICAgIGNhc2UgXCJ1aW50XCI6XG4gICAgICAvLyBpcyB0aGlzIGEgSEFDSz8gKFwiMjU2XCIgLyA4KVxuICAgICAgcmV0dXJuIHR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pLm1hdGNoKC90X1thLXpdKyhbMC05XSspLylbMV0gLyA4O1xuXG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJieXRlc1wiOlxuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgcmV0dXJuIFdPUkRfU0laRTtcblxuICAgIGNhc2UgXCJtYXBwaW5nXCI6XG4gICAgICAvLyBIQUNLIGp1c3QgdG8gcmVzZXJ2ZSBzbG90LiBtYXBwaW5ncyBoYXZlIG5vIHNpemUgYXMgc3VjaFxuICAgICAgcmV0dXJuIFdPUkRfU0laRTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNYXBwaW5nKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pLm1hdGNoKC9edF9tYXBwaW5nLykgIT0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVmZXJlbmNlKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pLm1hdGNoKC9fKG1lbW9yeXxzdG9yYWdlKShfcHRyKT8kLykgIT0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZmVyZW5jZVR5cGUoZGVmaW5pdGlvbikge1xuICByZXR1cm4gdHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbikubWF0Y2goL18oW15fXSspKF9wdHIpPyQvKVsxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhc2VEZWZpbml0aW9uKGRlZmluaXRpb24pIHtcbiAgbGV0IGJhc2VJZGVudGlmaWVyID0gdHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbilcbiAgICAvLyBmaXJzdCBkb2xsYXIgc2lnbiAgICAgbGFzdCBkb2xsYXIgc2lnblxuICAgIC8vICAgYC0tLS0tLS0tLS4gICAgICAgLC0tLSdcbiAgICAubWF0Y2goL15bXiRdK1xcJF8oLispX1xcJFteJF0rJC8pWzFdXG4gICAgLy8gICAgICAgICAgICAgIGAtLS0tJyBncmVlZHkgbWF0Y2hcblxuICAvLyBIQUNLIC0gaW50ZXJuYWwgdHlwZXMgZm9yIG1lbW9yeSBvciBzdG9yYWdlIGFsc28gc2VlbSB0byBiZSBwb2ludGVyc1xuICBpZiAoYmFzZUlkZW50aWZpZXIubWF0Y2goL18obWVtb3J5fHN0b3JhZ2UpJC8pICE9IG51bGwpIHtcbiAgICBiYXNlSWRlbnRpZmllciA9IGAke2Jhc2VJZGVudGlmaWVyfV9wdHJgO1xuICB9XG5cbiAgLy8gYW5vdGhlciBIQUNLIC0gd2UgZ2V0IGF3YXkgd2l0aCBpdCBiZWNhdXNld2UncmUgb25seSB1c2luZyB0aGF0IG9uZSBwcm9wZXJ0eVxuICByZXR1cm4ge1xuICAgIHR5cGVEZXNjcmlwdGlvbnM6IHtcbiAgICAgIHR5cGVJZGVudGlmaWVyOiBiYXNlSWRlbnRpZmllclxuICAgIH1cbiAgfTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdG9CaWdOdW1iZXIoYnl0ZXMpIHtcbiAgaWYgKGJ5dGVzID09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGJ5dGVzID09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbmV3IEJpZ051bWJlcihieXRlcywgMTYpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PSBcIm51bWJlclwiIHx8IEJpZ051bWJlci5pc0JpZ051bWJlcihieXRlcykpIHtcbiAgICByZXR1cm4gbmV3IEJpZ051bWJlcihieXRlcyk7XG4gIH0gZWxzZSBpZiAoYnl0ZXMucmVkdWNlKSB7XG4gICAgcmV0dXJuIGJ5dGVzLnJlZHVjZShcbiAgICAgIChudW0sIGJ5dGUpID0+IG51bS50aW1lcygweDEwMCkucGx1cyhieXRlKSxcbiAgICAgIG5ldyBCaWdOdW1iZXIoMClcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1NpZ25lZEJpZ051bWJlcihieXRlcykge1xuICBpZiAoYnl0ZXNbMF0gPCAwYjEwMDAwMDAwKSB7ICAvLyBmaXJzdCBiaXQgaXMgMFxuICAgIHJldHVybiB0b0JpZ051bWJlcihieXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvQmlnTnVtYmVyKGJ5dGVzLm1hcCggKGIpID0+IDB4ZmYgLSBiICkpLnBsdXMoMSkubmVnYXRlZCgpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIGJ5dGVzIC0gVWludDhBcnJheVxuICogQHBhcmFtIGxlbmd0aCAtIGRlc2lyZWQgYnl0ZSBsZW5ndGggKHBhZCB3aXRoIHplcm9lcylcbiAqIEBwYXJhbSB0cmltIC0gb21pdCBsZWFkaW5nIHplcm9lc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXhTdHJpbmcoYnl0ZXMsIGxlbmd0aCA9IDAsIHRyaW0gPSBmYWxzZSkge1xuICBpZiAodHlwZW9mIGxlbmd0aCA9PSBcImJvb2xlYW5cIikge1xuICAgIHRyaW0gPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gMDtcbiAgfVxuXG4gIGlmIChCaWdOdW1iZXIuaXNCaWdOdW1iZXIoYnl0ZXMpKSB7XG4gICAgYnl0ZXMgPSB0b0J5dGVzKGJ5dGVzKTtcbiAgfVxuXG4gIGNvbnN0IHBhZCA9IChzKSA9PiBgJHtcIjAwXCIuc2xpY2UoMCwgMiAtIHMubGVuZ3RoKX0ke3N9YFxuXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCAgMSAgMiAgMyAgNFxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgIDEgIDIgIDMgIDQgIDUgIDYgIDdcbiAgLy8gYnl0ZXMubGVuZ3RoOiAgICAgICAgNSAgLSAgMHgoICAgICAgICAgIGU1IGMyIGFhIDA5IDExIClcbiAgLy8gbGVuZ3RoIChwcmVmZXJyZWQpOiAgOCAgLSAgMHgoIDAwIDAwIDAwIGU1IGMyIGFhIDA5IDExIClcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAtLS4tLS0nXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCAzXG4gIGlmIChieXRlcy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICBsZXQgcHJpb3IgPSBieXRlcztcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG5cbiAgICBieXRlcy5zZXQocHJpb3IsIGxlbmd0aCAtIHByaW9yLmxlbmd0aCk7XG4gIH1cblxuICBkZWJ1ZyhcImJ5dGVzOiAlb1wiLCBieXRlcyk7XG5cbiAgbGV0IHN0cmluZyA9IGJ5dGVzLnJlZHVjZShcbiAgICAoc3RyLCBieXRlKSA9PiBgJHtzdHJ9JHtwYWQoYnl0ZS50b1N0cmluZygxNikpfWAsIFwiXCJcbiAgKTtcblxuICBpZiAodHJpbSkge1xuICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eKDAwKSsvLCBcIlwiKTtcbiAgfVxuXG4gIGlmIChzdHJpbmcubGVuZ3RoID09IDApIHtcbiAgICBzdHJpbmcgPSBcIjAwXCI7XG4gIH1cblxuICByZXR1cm4gYDB4JHtzdHJpbmd9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMobnVtYmVyLCBsZW5ndGggPSAwKSB7XG4gIGlmIChudW1iZXIgPCAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgbGV0IGhleCA9IG51bWJlci50b1N0cmluZygxNik7XG4gIGlmIChoZXgubGVuZ3RoICUgMiA9PSAxKSB7XG4gICAgaGV4ID0gYDAke2hleH1gO1xuICB9XG5cbiAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgaGV4Lm1hdGNoKC8uezJ9L2cpXG4gICAgICAubWFwKCAoYnl0ZSkgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpIClcbiAgKTtcblxuICBpZiAoYnl0ZXMubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgbGV0IHByaW9yID0gYnl0ZXM7XG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGJ5dGVzLnNldChwcmlvciwgbGVuZ3RoIC0gcHJpb3IubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1NiguLi5hcmdzKSB7XG4gIGxldCB3ZWIzID0gbmV3IFdlYjMoKTtcblxuICBkZWJ1ZyhcImFyZ3MgJW9cIiwgYXJncyk7XG5cbiAgLy8gYXJncyA9IGFyZ3MubWFwKCAoYXJnKSA9PiB7XG4gIC8vICAgaWYgKHR5cGVvZiBhcmcgPT0gXCJudW1iZXJcIiB8fCBCaWdOdW1iZXIuaXNCaWdOdW1iZXIoYXJnKSkge1xuICAvLyAgICAgcmV0dXJuIHRvSGV4U3RyaW5nKHRvQnl0ZXMoYXJnLCBXT1JEX1NJWkUpKS5zbGljZSgyKVxuICAvLyAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PSBcInN0cmluZ1wiKSB7XG4gIC8vICAgICByZXR1cm4gd2ViMy51dGlscy50b0hleChhcmcpLnNsaWNlKDIpO1xuICAvLyAgIH0gZWxzZSB7XG4gIC8vICAgICByZXR1cm4gXCJcIjtcbiAgLy8gICB9XG4gIC8vIH0pO1xuXG4gIC8vIGRlYnVnKFwicHJvY2Vzc2VkIGFyZ3MgJW9cIiwgYXJncyk7XG5cbiAgbGV0IHNoYSA9IHdlYjMudXRpbHMuc29saWRpdHlTaGEzKC4uLmFyZ3MpO1xuICBkZWJ1ZyhcInNoYSAlb1wiLCBzaGEpO1xuICByZXR1cm4gdG9CaWdOdW1iZXIoc2hhKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGF0YS9kZWNvZGUvdXRpbHMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjaGFpXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiY2hhaVwiXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwidGVzdDpoZWxwZXJzXCIpO1xuXG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IGZzIGZyb20gXCJmcy1leHRyYVwiO1xuaW1wb3J0IGFzeW5jIGZyb20gXCJhc3luY1wiO1xuaW1wb3J0IENvbnRyYWN0cyBmcm9tIFwidHJ1ZmZsZS13b3JrZmxvdy1jb21waWxlXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcInRydWZmbGUtZGVidWctdXRpbHNcIjtcbmltcG9ydCBBcnRpZmFjdG9yIGZyb20gXCJ0cnVmZmxlLWFydGlmYWN0b3JcIjtcbmltcG9ydCBXZWIzIGZyb20gXCJ3ZWIzXCI7XG5pbXBvcnQgTWlncmF0ZSBmcm9tIFwidHJ1ZmZsZS1taWdyYXRlXCI7XG5pbXBvcnQgQm94IGZyb20gXCJ0cnVmZmxlLWJveFwiO1xuaW1wb3J0IFJlc29sdmVyIGZyb20gXCJ0cnVmZmxlLXJlc29sdmVyXCI7XG5pbXBvcnQgZXhwZWN0IGZyb20gXCJ0cnVmZmxlLWV4cGVjdFwiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlcGFyZUNvbnRyYWN0cyhwcm92aWRlciwgc291cmNlcyA9IHt9LCBtaWdyYXRpb25zKSB7XG4gIGxldCBjb25maWcgPSBhd2FpdCBjcmVhdGVTYW5kYm94KCk7XG5cbiAgbGV0IGFjY291bnRzID0gYXdhaXQgZ2V0QWNjb3VudHMocHJvdmlkZXIpO1xuXG4gIGNvbmZpZy5uZXR3b3Jrc1tcImRlYnVnZ2VyXCJdID0ge1xuICAgIHByb3ZpZGVyOiBwcm92aWRlcixcbiAgICBuZXR3b3JrX2lkOiBcIipcIixcbiAgICBmcm9tOiBhY2NvdW50c1swXVxuICB9XG4gIGNvbmZpZy5uZXR3b3JrID0gXCJkZWJ1Z2dlclwiO1xuXG4gIGF3YWl0IGFkZENvbnRyYWN0cyhjb25maWcsIHNvdXJjZXMpO1xuICBsZXQgeyBjb250cmFjdHMsIGZpbGVzIH0gPSBhd2FpdCBjb21waWxlKGNvbmZpZyk7XG4gIGxldCBjb250cmFjdE5hbWVzID0gT2JqZWN0LmtleXMoY29udHJhY3RzKTtcblxuICBpZiAoIW1pZ3JhdGlvbnMpIHtcbiAgICBtaWdyYXRpb25zID0gYXdhaXQgZGVmYXVsdE1pZ3JhdGlvbnMoY29udHJhY3ROYW1lcyk7XG4gIH1cblxuICBhd2FpdCBhZGRNaWdyYXRpb25zKGNvbmZpZywgbWlncmF0aW9ucyk7XG4gIGF3YWl0IG1pZ3JhdGUoY29uZmlnKTtcblxuICBsZXQgYXJ0aWZhY3RzID0gYXdhaXQgZ2F0aGVyQXJ0aWZhY3RzKGNvbmZpZyk7XG4gIGRlYnVnKFwiYXJ0aWZhY3RzOiAlb1wiLCBhcnRpZmFjdHMubWFwKChhKSA9PiBhLmNvbnRyYWN0TmFtZSkpO1xuXG4gIGxldCBhYnN0cmFjdGlvbnMgPSB7fTtcbiAgY29udHJhY3ROYW1lcy5mb3JFYWNoKCAobmFtZSkgPT4ge1xuICAgIGFic3RyYWN0aW9uc1tuYW1lXSA9IGNvbmZpZy5yZXNvbHZlci5yZXF1aXJlKG5hbWUpO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGZpbGVzLFxuICAgIGFic3RyYWN0aW9ucyxcbiAgICBhcnRpZmFjdHMsXG4gICAgY29uZmlnXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY2NvdW50cyhwcm92aWRlcikge1xuICBsZXQgd2ViMyA9IG5ldyBXZWIzKHByb3ZpZGVyKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGFjY2VwdCwgcmVqZWN0KSB7XG4gICAgd2ViMy5ldGguZ2V0QWNjb3VudHMoZnVuY3Rpb24oZXJyLCBhY2NvdW50cykge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgYWNjZXB0KGFjY291bnRzKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVTYW5kYm94KCkge1xuICBsZXQgY29uZmlnID0gYXdhaXQgbmV3IFByb21pc2UoZnVuY3Rpb24oYWNjZXB0LCByZWplY3QpIHtcbiAgICBCb3guc2FuZGJveChmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgcmVzdWx0LnJlc29sdmVyID0gbmV3IFJlc29sdmVyKHJlc3VsdCk7XG4gICAgICByZXN1bHQuYXJ0aWZhY3RvciA9IG5ldyBBcnRpZmFjdG9yKHJlc3VsdC5jb250cmFjdHNfYnVpbGRfZGlyZWN0b3J5KTtcbiAgICAgIHJlc3VsdC5uZXR3b3JrcyA9IHt9O1xuXG4gICAgICBhY2NlcHQocmVzdWx0KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgYXdhaXQgZnMucmVtb3ZlKHBhdGguam9pbihjb25maWcuY29udHJhY3RzX2RpcmVjdG9yeSwgXCJNZXRhQ29pbi5zb2xcIikpO1xuICBhd2FpdCBmcy5yZW1vdmUocGF0aC5qb2luKGNvbmZpZy5jb250cmFjdHNfZGlyZWN0b3J5LCBcIkNvbnZlcnRMaWIuc29sXCIpKTtcbiAgYXdhaXQgZnMucmVtb3ZlKHBhdGguam9pbihjb25maWcubWlncmF0aW9uc19kaXJlY3RvcnksIFwiMl9kZXBsb3lfY29udHJhY3RzLmpzXCIpKTtcblxuICByZXR1cm4gY29uZmlnO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkQ29udHJhY3RzKGNvbmZpZywgc291cmNlcyA9IHt9KSB7XG4gIGxldCBwcm9taXNlcyA9IFtdO1xuICBmb3IgKGxldCBmaWxlbmFtZSBvZiBPYmplY3Qua2V5cyhzb3VyY2VzKSkge1xuICAgIGxldCBzb3VyY2UgPSBzb3VyY2VzW2ZpbGVuYW1lXTtcbiAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgZnMub3V0cHV0RmlsZShwYXRoLmpvaW4oY29uZmlnLmNvbnRyYWN0c19kaXJlY3RvcnksIGZpbGVuYW1lKSwgc291cmNlKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkTWlncmF0aW9ucyhjb25maWcsIG1pZ3JhdGlvbnMgPSB7fSkge1xuICBsZXQgcHJvbWlzZXMgPSBbXTtcbiAgZm9yIChsZXQgZmlsZW5hbWUgb2YgT2JqZWN0LmtleXMobWlncmF0aW9ucykpIHtcbiAgICBsZXQgc291cmNlID0gbWlncmF0aW9uc1tmaWxlbmFtZV07XG4gICAgcHJvbWlzZXMucHVzaChcbiAgICAgIGZzLm91dHB1dEZpbGUocGF0aC5qb2luKGNvbmZpZy5taWdyYXRpb25zX2RpcmVjdG9yeSwgZmlsZW5hbWUpLCBzb3VyY2UpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWZhdWx0TWlncmF0aW9ucyhjb250cmFjdE5hbWVzKSB7XG4gIGNvbnRyYWN0TmFtZXMgPSBjb250cmFjdE5hbWVzLmZpbHRlcigobmFtZSkgPT4gbmFtZSAhPSBcIk1pZ3JhdGlvbnNcIik7XG5cbiAgbGV0IG1pZ3JhdGlvbnMgPSB7fTtcblxuICBjb250cmFjdE5hbWVzLmZvckVhY2goIChjb250cmFjdE5hbWUsIGkpID0+IHtcbiAgICBsZXQgaW5kZXggPSBpICsgMjsgIC8vIHN0YXJ0IGF0IDIgY2F1c2UgTWlncmF0aW9ucyBtaWdyYXRpb25cbiAgICBsZXQgZmlsZW5hbWUgPSBgJHtpbmRleH1fbWlncmF0ZV8ke2NvbnRyYWN0TmFtZX0uanNgO1xuICAgIGxldCBzb3VyY2UgPSBgXG4gICAgICB2YXIgJHtjb250cmFjdE5hbWV9ID0gYXJ0aWZhY3RzLnJlcXVpcmUoXCIke2NvbnRyYWN0TmFtZX1cIik7XG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGVwbG95ZXIpIHtcbiAgICAgICAgZGVwbG95ZXIuZGVwbG95KCR7Y29udHJhY3ROYW1lfSk7XG4gICAgICB9O1xuICAgIGA7XG5cbiAgICBtaWdyYXRpb25zW2ZpbGVuYW1lXSA9IHNvdXJjZVxuICB9KTtcblxuICByZXR1cm4gbWlncmF0aW9ucztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbXBpbGUoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihhY2NlcHQsIHJlamVjdCkge1xuICAgIENvbnRyYWN0cy5jb21waWxlKGNvbmZpZy53aXRoKHtcbiAgICAgIGFsbDogdHJ1ZSxcbiAgICAgIHF1aWV0OiB0cnVlXG4gICAgfSksIGZ1bmN0aW9uKGVyciwgY29udHJhY3RzLCBmaWxlcykge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgcmV0dXJuIGFjY2VwdCh7Y29udHJhY3RzLCBmaWxlc30pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihhY2NlcHQsIHJlamVjdCkge1xuICAgIE1pZ3JhdGUucnVuKGNvbmZpZy53aXRoKHtcbiAgICAgIHF1aWV0OiB0cnVlXG4gICAgfSksIGZ1bmN0aW9uKGVyciwgY29udHJhY3RzKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICBhY2NlcHQoY29udHJhY3RzKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnYXRoZXJBcnRpZmFjdHMoY29uZmlnKSB7XG4gIHJldHVybiBEZWJ1Zy5nYXRoZXJBcnRpZmFjdHMoY29uZmlnKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB0ZXN0L2hlbHBlcnMuanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6YXN0OnNlbGVjdG9yc1wiKTtcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcbmltcG9ydCBqc29ucG9pbnRlciBmcm9tIFwianNvbi1wb2ludGVyXCI7XG5cbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuXG5pbXBvcnQgeyBmaW5kUmFuZ2UgfSBmcm9tIFwiLi4vbWFwXCI7XG5cblxuLyoqXG4gKiBhc3RcbiAqL1xuY29uc3QgYXN0ID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIGFzdC52aWV3c1xuICAgKi9cbiAgdmlld3M6IHtcbiAgICAvKipcbiAgICAgKiBhc3Qudmlld3Muc291cmNlc1xuICAgICAqL1xuICAgIHNvdXJjZXM6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmluZm8uc291cmNlc10sIHNvdXJjZXMgPT4gc291cmNlcylcbiAgfSxcblxuICAvKipcbiAgICogYXN0LmN1cnJlbnRcbiAgICovXG4gIGN1cnJlbnQ6IHtcblxuICAgIC8qKlxuICAgICAqIGFzdC5jdXJyZW50LnRyZWVcbiAgICAgKlxuICAgICAqIGFzdCBmb3IgY3VycmVudCBzb3VyY2VcbiAgICAgKi9cbiAgICB0cmVlOiBjcmVhdGVMZWFmKFxuICAgICAgW3NvbGlkaXR5LmN1cnJlbnQuc291cmNlXSwgKHthc3R9KSA9PiBhc3RcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogYXN0LmN1cnJlbnQuaW5kZXhcbiAgICAgKlxuICAgICAqIHNvdXJjZSBJRFxuICAgICAqL1xuICAgIGluZGV4OiBjcmVhdGVMZWFmKFxuICAgICAgW3NvbGlkaXR5LmN1cnJlbnQuc291cmNlXSwgKHtpZH0pID0+IGlkXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIGFzdC5jdXJyZW50LnBvaW50ZXJcbiAgICAgKlxuICAgICAqIGpzb25wb2ludGVyIGZvciBjdXJyZW50IGFzdCBub2RlXG4gICAgICovXG4gICAgcG9pbnRlcjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vdHJlZVwiLCBzb2xpZGl0eS5jdXJyZW50LnNvdXJjZVJhbmdlXSxcblxuICAgICAgKGFzdCwgcmFuZ2UpID0+IGZpbmRSYW5nZShhc3QsIHJhbmdlLnN0YXJ0LCByYW5nZS5sZW5ndGgpXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIGFzdC5jdXJyZW50Lm5vZGVcbiAgICAgKlxuICAgICAqIGN1cnJlbnQgYXN0IG5vZGUgdG8gZXhlY3V0ZVxuICAgICAqL1xuICAgIG5vZGU6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3RyZWVcIiwgXCIuL3BvaW50ZXJcIl0sIChhc3QsIHBvaW50ZXIpID0+XG4gICAgICAgIChwb2ludGVyKVxuICAgICAgICAgID8ganNvbnBvaW50ZXIuZ2V0KGFzdCwgcG9pbnRlcilcbiAgICAgICAgICA6IGpzb25wb2ludGVyLmdldChhc3QsIFwiXCIpXG4gICAgKSxcblxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9hc3Qvc2VsZWN0b3JzL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXhcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWR1eFwiXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJnYW5hY2hlLWNsaVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImdhbmFjaGUtY2xpXCJcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5c1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5c1wiXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSAnZGVidWcnO1xuaW1wb3J0IGV4cGVjdCBmcm9tIFwidHJ1ZmZsZS1leHBlY3RcIjtcblxuaW1wb3J0IFNlc3Npb24gZnJvbSBcIi4vc2Vzc2lvblwiO1xuXG5pbXBvcnQgeyBjcmVhdGVOZXN0ZWRTZWxlY3RvciB9IGZyb20gXCJyZXNlbGVjdC10cmVlXCI7XG5cbmltcG9ydCBkYXRhU2VsZWN0b3IgZnJvbSBcIi4vZGF0YS9zZWxlY3RvcnNcIjtcbmltcG9ydCBhc3RTZWxlY3RvciBmcm9tIFwiLi9hc3Qvc2VsZWN0b3JzXCI7XG5pbXBvcnQgdHJhY2VTZWxlY3RvciBmcm9tIFwiLi90cmFjZS9zZWxlY3RvcnNcIjtcbmltcG9ydCBldm1TZWxlY3RvciBmcm9tIFwiLi9ldm0vc2VsZWN0b3JzXCI7XG5pbXBvcnQgc29saWRpdHlTZWxlY3RvciBmcm9tIFwiLi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcbmltcG9ydCBzZXNzaW9uU2VsZWN0b3IgZnJvbSBcIi4vc2Vzc2lvbi9zZWxlY3RvcnNcIjtcblxuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyXCIpO1xuXG4vKipcbiAqIEBleGFtcGxlXG4gKiBsZXQgc2Vzc2lvbiA9IERlYnVnZ2VyXG4gKiAgIC5mb3JUeCg8dHhIYXNoPiwge1xuICogICAgIGNvbnRyYWN0czogWzxjb250cmFjdCBvYmo+LCAuLi5dLFxuICogICAgIHByb3ZpZGVyOiA8cHJvdmlkZXIgaW5zdGFuY2U+XG4gKiAgIH0pXG4gKiAgIC5jb25uZWN0KCk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlYnVnZ2VyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U2Vzc2lvbn0gc2Vzc2lvbiAtIGRlYnVnZ2VyIHNlc3Npb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNlc3Npb24pIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3Nlc3Npb24gPSBzZXNzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlcyBhIERlYnVnZ2VyIGZvciBhIGdpdmVuIHRyYW5zYWN0aW9uIGhhc2guXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eEhhc2ggLSB0cmFuc2FjdGlvbiBoYXNoIHdpdGggbGVhZGluZyBcIjB4XCJcbiAgICogQHBhcmFtIHt7Y29udHJhY3RzOiBBcnJheTxDb250cmFjdD4sIGZpbGVzOiBBcnJheTxTdHJpbmc+LCBwcm92aWRlcjogV2ViM1Byb3ZpZGVyfX0gb3B0aW9ucyAtXG4gICAqIEByZXR1cm4ge0RlYnVnZ2VyfSBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZvclR4KHR4SGFzaCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgZXhwZWN0Lm9wdGlvbnMob3B0aW9ucywgW1xuICAgICAgXCJjb250cmFjdHNcIixcbiAgICAgIFwicHJvdmlkZXJcIlxuICAgIF0pO1xuXG4gICAgbGV0IHNlc3Npb24gPSBuZXcgU2Vzc2lvbihcbiAgICAgIG9wdGlvbnMuY29udHJhY3RzLCBvcHRpb25zLmZpbGVzLFxuICAgICAgdHhIYXNoLCBvcHRpb25zLnByb3ZpZGVyXG4gICAgKTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzZXNzaW9uLnJlYWR5KCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IHRoaXMoc2Vzc2lvbik7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byB0aGUgaW5zdGFudGlhdGVkIERlYnVnZ2VyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTZXNzaW9ufSBzZXNzaW9uIGluc3RhbmNlXG4gICAqL1xuICBjb25uZWN0KCkge1xuICAgIHJldHVybiB0aGlzLl9zZXNzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydGVkIHNlbGVjdG9yc1xuICAgKlxuICAgKiBTZWUgaW5kaXZpZHVhbCBzZWxlY3RvciBkb2NzIGZvciBmdWxsIGxpc3RpbmdcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogRGVidWdnZXIuc2VsZWN0b3JzLmFzdC5jdXJyZW50LnRyZWVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogRGVidWdnZXIuc2VsZWN0b3JzLnNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogRGVidWdnZXIuc2VsZWN0b3JzLnRyYWNlLnN0ZXBzXG4gICAqL1xuICBzdGF0aWMgZ2V0IHNlbGVjdG9ycygpIHtcbiAgICByZXR1cm4gY3JlYXRlTmVzdGVkU2VsZWN0b3Ioe1xuICAgICAgYXN0OiBhc3RTZWxlY3RvcixcbiAgICAgIGRhdGE6IGRhdGFTZWxlY3RvcixcbiAgICAgIHRyYWNlOiB0cmFjZVNlbGVjdG9yLFxuICAgICAgZXZtOiBldm1TZWxlY3RvcixcbiAgICAgIHNvbGlkaXR5OiBzb2xpZGl0eVNlbGVjdG9yLFxuICAgICAgc2Vzc2lvbjogc2Vzc2lvblNlbGVjdG9yLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29udHJhY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250cmFjdE5hbWUgY29udHJhY3QgbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSBzb2xpZGl0eSBzb3VyY2UgY29kZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZVBhdGggcGF0aCB0byBzb3VyY2UgZmlsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJpbmFyeSAweC1wcmVmaXhlZCBoZXggc3RyaW5nIHdpdGggY3JlYXRlIGJ5dGVjb2RlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlTWFwIHNvbGlkaXR5IHNvdXJjZSBtYXAgZm9yIGNyZWF0ZSBieXRlY29kZVxuICogQHByb3BlcnR5IHtPYmplY3R9IGFzdCBBYnN0cmFjdCBTeW50YXggVHJlZSBmcm9tIFNvbGlkaXR5XG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVwbG95ZWRCaW5hcnkgMHgtcHJlZml4ZWQgY29tcGlsZWQgYmluYXJ5IChvbiBjaGFpbilcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXBsb3llZFNvdXJjZU1hcCBzb2xpZGl0eSBzb3VyY2UgbWFwIGZvciBvbi1jaGFpbiBieXRlY29kZVxuICovXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RlYnVnZ2VyLmpzIiwiaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcblxubGV0IHRyYWNlID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIHRyYWNlLmluZGV4XG4gICAqXG4gICAqIGN1cnJlbnQgc3RlcCBpbmRleFxuICAgKi9cbiAgaW5kZXg6IChzdGF0ZSkgPT4gc3RhdGUudHJhY2UucHJvYy5pbmRleCxcblxuICAvKipcbiAgICogdHJhY2Uuc3RlcHNcbiAgICpcbiAgICogYWxsIHRyYWNlIHN0ZXBzXG4gICAqL1xuICBzdGVwczogKHN0YXRlKSA9PiBzdGF0ZS50cmFjZS5pbmZvLnN0ZXBzLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5zdGVwc1JlbWFpbmluZ1xuICAgKlxuICAgKiBudW1iZXIgb2Ygc3RlcHMgcmVtYWluaW5nIGluIHRyYWNlXG4gICAqL1xuICBzdGVwc1JlbWFpbmluZzogY3JlYXRlTGVhZihcbiAgICBbXCIuL3N0ZXBzXCIsIFwiLi9pbmRleFwiXSwgKHN0ZXBzLCBpbmRleCkgPT4gc3RlcHMubGVuZ3RoIC0gaW5kZXhcbiAgKSxcblxuICAvKipcbiAgICogdHJhY2Uuc3RlcFxuICAgKlxuICAgKiBjdXJyZW50IHRyYWNlIHN0ZXBcbiAgICovXG4gIHN0ZXA6IGNyZWF0ZUxlYWYoXG4gICAgW1wiLi9zdGVwc1wiLCBcIi4vaW5kZXhcIl0sIChzdGVwcywgaW5kZXgpID0+IHN0ZXBzW2luZGV4XVxuICApLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5uZXh0XG4gICAqXG4gICAqIG5leHQgdHJhY2Ugc3RlcCBvciB7fVxuICAgKi9cbiAgbmV4dDogY3JlYXRlTGVhZihcbiAgICBbXCIuL3N0ZXBzXCIsIFwiLi9pbmRleFwiXSwgKHN0ZXBzLCBpbmRleCkgPT5cbiAgICAgIGluZGV4IDwgc3RlcHMubGVuZ3RoIC0gMSA/IHN0ZXBzW2luZGV4ICsgMV0gOiB7fVxuICApXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdHJhY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3RyYWNlL3NlbGVjdG9ycy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJpZ251bWJlci5qc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJpZ251bWJlci5qc1wiXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgY29uc3QgU0FWRV9TVEVQUyA9IFwiU0FWRV9TVEVQU1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHNhdmVTdGVwcyhzdGVwcykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNBVkVfU1RFUFMsXG4gICAgc3RlcHNcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFQ0VJVkVfQUREUkVTU0VTID0gXCJSRUNFSVZFX0FERFJFU1NFU1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlY2VpdmVBZGRyZXNzZXMoYWRkcmVzc2VzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDRUlWRV9BRERSRVNTRVMsXG4gICAgYWRkcmVzc2VzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBORVhUID0gXCJORVhUXCI7XG5leHBvcnQgZnVuY3Rpb24gbmV4dCgpIHtcbiAgcmV0dXJuIHt0eXBlOiBORVhUfTtcbn1cblxuZXhwb3J0IGNvbnN0IFRJQ0sgPSBcIlRJQ0tcIjtcbmV4cG9ydCBmdW5jdGlvbiB0aWNrKCkge1xuICByZXR1cm4ge3R5cGU6IFRJQ0t9O1xufVxuXG5leHBvcnQgY29uc3QgVE9DSyA9IFwiVE9DS1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHRvY2soKSB7XG4gIHJldHVybiB7dHlwZTogVE9DS307XG59XG5cbmV4cG9ydCBjb25zdCBFTkRfT0ZfVFJBQ0UgPSBcIkVPVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGVuZFRyYWNlKCkge1xuICByZXR1cm4ge3R5cGU6IEVORF9PRl9UUkFDRX07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3RyYWNlL2FjdGlvbnMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldFwiXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCJcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImpzb24tcG9pbnRlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImpzb24tcG9pbnRlclwiXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgY29uc3QgU1RBUlQgPSBcIlNFU1NJT05fU1RBUlRcIjtcbmV4cG9ydCBmdW5jdGlvbiBzdGFydCh0eEhhc2gsIHByb3ZpZGVyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU1RBUlQsXG4gICAgdHhIYXNoLCBwcm92aWRlclxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVBRFkgPSBcIlNFU1NJT05fUkVBRFlcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWFkeSgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUFEWSxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEVSUk9SID0gXCJTRVNTSU9OX0VSUk9SXCI7XG5leHBvcnQgZnVuY3Rpb24gZXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBFUlJPUixcbiAgICBlcnJvclxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgRklOSVNIID0gXCJTRVNTSU9OX0ZJTklTSFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBGSU5JU0gsXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRUNPUkRfQ09OVFJBQ1RTID0gXCJSRUNPUkRfQ09OVFJBQ1RTXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVjb3JkQ29udHJhY3RzKGNvbnRleHRzLCBzb3VyY2VzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDT1JEX0NPTlRSQUNUUyxcbiAgICBjb250ZXh0cywgc291cmNlc1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3Nlc3Npb24vYWN0aW9ucy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpkYXRhOnNlbGVjdG9yc1wiKTtcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcbmltcG9ydCBqc29ucG9pbnRlciBmcm9tIFwianNvbi1wb2ludGVyXCI7XG5cbmltcG9ydCBhc3QgZnJvbSBcImxpYi9hc3Qvc2VsZWN0b3JzXCI7XG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNvbGlkaXR5IGZyb20gXCJsaWIvc29saWRpdHkvc2VsZWN0b3JzXCI7XG5cbmltcG9ydCBkZWNvZGUgZnJvbSBcIi4uL2RlY29kZVwiO1xuaW1wb3J0ICogYXMgZGVjb2RlVXRpbHMgZnJvbSBcIi4uL2RlY29kZS91dGlsc1wiO1xuXG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlU2VsZWN0b3JzKHsgc3RhY2ssIG1lbW9yeSwgc3RvcmFnZSB9KSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogLnN0YWNrXG4gICAgICovXG4gICAgc3RhY2s6IGNyZWF0ZUxlYWYoXG4gICAgICBbc3RhY2tdLFxuXG4gICAgICAod29yZHMpID0+ICh3b3JkcyB8fCBbXSkubWFwKFxuICAgICAgICAod29yZCkgPT4gZGVjb2RlVXRpbHMudG9CeXRlcyhkZWNvZGVVdGlscy50b0JpZ051bWJlcih3b3JkLCBkZWNvZGVVdGlscy5XT1JEX1NJWkUpKVxuICAgICAgKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAubWVtb3J5XG4gICAgICovXG4gICAgbWVtb3J5OiBjcmVhdGVMZWFmKFxuICAgICAgW21lbW9yeV0sXG5cbiAgICAgICh3b3JkcykgPT4gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICh3b3Jkcy5qb2luKFwiXCIpLm1hdGNoKC8uezEsMn0vZykgfHwgW10pXG4gICAgICAgICAgLm1hcCggKGJ5dGUpID0+IHBhcnNlSW50KGJ5dGUsIDE2KSApXG4gICAgICApXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIC5zdG9yYWdlXG4gICAgICovXG4gICAgc3RvcmFnZTogY3JlYXRlTGVhZihcbiAgICAgIFtzdG9yYWdlXSxcblxuICAgICAgKG1hcHBpbmcpID0+IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LCAuLi5PYmplY3QuZW50cmllcyhtYXBwaW5nKS5tYXAoIChbIGFkZHJlc3MsIHdvcmQgXSkgPT5cbiAgICAgICAgICAoe1xuICAgICAgICAgICAgW2AweCR7YWRkcmVzc31gXTogbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgICh3b3JkLm1hdGNoKC8uezEsMn0vZykgfHwgW10pXG4gICAgICAgICAgICAgICAgLm1hcCggKGJ5dGUpID0+IHBhcnNlSW50KGJ5dGUsIDE2KSApXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgIClcbiAgfTtcbn1cblxuY29uc3QgZGF0YSA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG4gIHN0YXRlOiAoc3RhdGUpID0+IHN0YXRlLmRhdGEsXG5cbiAgLyoqXG4gICAqIGRhdGEudmlld3NcbiAgICovXG4gIHZpZXdzOiB7XG4gICAgYXN0OiBjcmVhdGVMZWFmKFxuICAgICAgW2FzdC5jdXJyZW50XSwgKHRyZWUpID0+IHRyZWVcbiAgICApLFxuXG4gICAgYXRMYXN0SW5zdHJ1Y3Rpb25Gb3JTb3VyY2VSYW5nZTogY3JlYXRlTGVhZihcbiAgICAgIFtzb2xpZGl0eS5jdXJyZW50LmlzU291cmNlUmFuZ2VGaW5hbF0sIChmaW5hbCkgPT4gZmluYWxcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS52aWV3cy5zY29wZXNcbiAgICAgKi9cbiAgICBzY29wZXM6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLnZpZXdzLnNjb3Blcy5pbmxpbmVkXG4gICAgICAgKi9cbiAgICAgIGlubGluZWQ6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi9pbmZvL3Njb3Blc1wiLCBzb2xpZGl0eS5pbmZvLnNvdXJjZXNdLFxuXG4gICAgICAgIChzY29wZXMsIHNvdXJjZXMpID0+IE9iamVjdC5hc3NpZ24oe30sXG4gICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMoc2NvcGVzKS5tYXAoXG4gICAgICAgICAgICAoW2lkLCBlbnRyeV0pID0+ICh7XG4gICAgICAgICAgICAgIFtpZF06IHtcbiAgICAgICAgICAgICAgICAuLi5lbnRyeSxcblxuICAgICAgICAgICAgICAgIGRlZmluaXRpb246IGpzb25wb2ludGVyLmdldChcbiAgICAgICAgICAgICAgICAgIHNvdXJjZXNbZW50cnkuc291cmNlSWRdLmFzdCwgZW50cnkucG9pbnRlclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGF0YS52aWV3cy5kZWNvZGVyXG4gICAgICpcbiAgICAgKiBzZWxlY3RvciByZXR1cm5zIChhc3Qgbm9kZSBkZWZpbml0aW9uLCBkYXRhIHJlZmVyZW5jZSkgPT4gdmFsdWVcbiAgICAgKi9cbiAgICBkZWNvZGVyOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkXCIsIFwiL25leHQvc3RhdGVcIl0sXG5cbiAgICAgIChzY29wZXMsIHN0YXRlKSA9PiB7XG4gICAgICAgIHJldHVybiAoZGVmaW5pdGlvbiwgcmVmKSA9PiBkZWNvZGUoZGVmaW5pdGlvbiwgcmVmLCBzdGF0ZSwgc2NvcGVzKVxuICAgICAgfVxuICAgIClcbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5pbmZvXG4gICAqL1xuICBpbmZvOiB7XG5cbiAgICAvKipcbiAgICAgKiBkYXRhLmluZm8uc2NvcGVzXG4gICAgICovXG4gICAgc2NvcGVzOiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgKHN0YXRlKSA9PiBzdGF0ZS5pbmZvLnNjb3Blcy5ieUlkKVxuICB9LFxuXG4gIC8qKlxuICAgKiBkYXRhLnByb2NcbiAgICovXG4gIHByb2M6IHtcblxuICAgIC8qKlxuICAgICAqIGRhdGEucHJvYy5hc3NpZ25tZW50c1xuICAgICAqL1xuICAgIGFzc2lnbm1lbnRzOiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgKHN0YXRlKSA9PiBzdGF0ZS5wcm9jLmFzc2lnbm1lbnRzLmJ5SWQpXG4gIH0sXG5cbiAgLyoqXG4gICAqIGRhdGEuY3VycmVudFxuICAgKi9cbiAgY3VycmVudDoge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogZGF0YS5jdXJyZW50LnNjb3BlXG4gICAgICovXG4gICAgc2NvcGU6IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLmN1cnJlbnQuc2NvcGUuaWRcbiAgICAgICAqL1xuICAgICAgaWQ6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFthc3QuY3VycmVudC5ub2RlXSwgKG5vZGUpID0+IG5vZGUuaWRcbiAgICAgIClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50LnN0YXRlXG4gICAgICovXG4gICAgc3RhdGU6IGNyZWF0ZVN0YXRlU2VsZWN0b3JzKGV2bS5jdXJyZW50LnN0YXRlKSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuY3VycmVudC5pZGVudGlmaWVycyAobmFtZXNwYWNlKVxuICAgICAqL1xuICAgIGlkZW50aWZpZXJzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzIChzZWxlY3RvcilcbiAgICAgICAqXG4gICAgICAgKiByZXR1cm5zIGlkZW50aWZlcnMgYW5kIGNvcnJlc3BvbmRpbmcgZGVmaW5pdGlvbiBub2RlIElEXG4gICAgICAgKi9cbiAgICAgIF86IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcbiAgICAgICAgICBcIi92aWV3cy9zY29wZXMvaW5saW5lZFwiLFxuICAgICAgICAgIFwiL2N1cnJlbnQvc2NvcGVcIixcbiAgICAgICAgXSxcblxuICAgICAgICAoc2NvcGVzLCBzY29wZSkgPT4ge1xuICAgICAgICAgIGxldCBjdXIgPSBzY29wZS5pZDtcbiAgICAgICAgICBsZXQgdmFyaWFibGVzID0ge307XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXJpYWJsZXMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgIC4uLihzY29wZXNbY3VyXS52YXJpYWJsZXMgfHwgW10pXG4gICAgICAgICAgICAgICAgLmZpbHRlciggKHYpID0+IHZhcmlhYmxlc1t2Lm5hbWVdID09IHVuZGVmaW5lZCApXG4gICAgICAgICAgICAgICAgLm1hcCggKHYpID0+ICh7IFt2Lm5hbWVdOiB2LmlkIH0pIClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGN1ciA9IHNjb3Blc1tjdXJdLnBhcmVudElkO1xuICAgICAgICAgIH0gd2hpbGUgKGN1ciAhPSBudWxsKTtcblxuICAgICAgICAgIHJldHVybiB2YXJpYWJsZXM7XG4gICAgICAgIH1cbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzLmRlZmluaXRpb25zXG4gICAgICAgKlxuICAgICAgICogY3VycmVudCB2YXJpYWJsZSBkZWZpbml0aW9uc1xuICAgICAgICovXG4gICAgICBkZWZpbml0aW9uczogY3JlYXRlTGVhZihcbiAgICAgICAgW1xuICAgICAgICAgIFwiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkXCIsXG4gICAgICAgICAgXCIuL19cIlxuICAgICAgICBdLFxuXG4gICAgICAgIChzY29wZXMsIGlkZW50aWZpZXJzKSA9PiBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKGlkZW50aWZpZXJzKVxuICAgICAgICAgICAgLm1hcCggKFtpZGVudGlmaWVyLCBpZF0pID0+IHtcbiAgICAgICAgICAgICAgbGV0IHsgZGVmaW5pdGlvbiB9ID0gc2NvcGVzW2lkXTtcblxuICAgICAgICAgICAgICByZXR1cm4geyBbaWRlbnRpZmllcl06IGRlZmluaXRpb24gfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzLnJlZnNcbiAgICAgICAqXG4gICAgICAgKiBjdXJyZW50IHZhcmlhYmxlcycgdmFsdWUgcmVmc1xuICAgICAgICovXG4gICAgICByZWZzOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXG4gICAgICAgICAgXCIvcHJvYy9hc3NpZ25tZW50c1wiLFxuICAgICAgICAgIFwiLi9fXCJcbiAgICAgICAgXSxcblxuICAgICAgICAoYXNzaWdubWVudHMsIGlkZW50aWZpZXJzKSA9PiBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKGlkZW50aWZpZXJzKVxuICAgICAgICAgICAgLm1hcCggKFtpZGVudGlmaWVyLCBpZF0pID0+IHtcbiAgICAgICAgICAgICAgbGV0IHsgcmVmIH0gPSAoYXNzaWdubWVudHNbaWRdIHx8IHt9KVxuICAgICAgICAgICAgICBpZiAoIXJlZikgeyByZXR1cm4gdW5kZWZpbmVkIH07XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBbaWRlbnRpZmllcl06IHJlZlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKSxcblxuICAgICAgZGVjb2RlZDogY3JlYXRlTGVhZihcbiAgICAgICAgW1xuICAgICAgICAgIFwiL3ZpZXdzL2RlY29kZXJcIixcbiAgICAgICAgICBcIi4vZGVmaW5pdGlvbnNcIixcbiAgICAgICAgICBcIi4vcmVmc1wiLFxuICAgICAgICBdLFxuXG4gICAgICAgIChkZWNvZGUsIGRlZmluaXRpb25zLCByZWZzKSA9PiBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKHJlZnMpXG4gICAgICAgICAgICAubWFwKCAoW2lkZW50aWZpZXIsIHJlZl0pID0+ICh7XG4gICAgICAgICAgICAgIFtpZGVudGlmaWVyXTogZGVjb2RlKGRlZmluaXRpb25zW2lkZW50aWZpZXJdLCByZWYpXG4gICAgICAgICAgICB9KSApXG4gICAgICAgIClcbiAgICAgICksXG5cbiAgICAgIG5hdGl2ZTogY3JlYXRlTGVhZihbJy4vZGVjb2RlZCddLCBkZWNvZGVVdGlscy5jbGVhbkJpZ051bWJlcnMpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBkYXRhLm5leHRcbiAgICovXG4gIG5leHQ6IHtcblxuICAgIC8qKlxuICAgICAqIGRhdGEubmV4dC5zdGF0ZVxuICAgICAqL1xuICAgIHN0YXRlOiBjcmVhdGVTdGF0ZVNlbGVjdG9ycyhldm0ubmV4dC5zdGF0ZSlcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRhdGE7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvc2VsZWN0b3JzL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHJ1ZmZsZS1leHBlY3RcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0cnVmZmxlLWV4cGVjdFwiXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6YXN0Om1hcFwiKTtcblxuaW1wb3J0IEludGVydmFsVHJlZSBmcm9tIFwibm9kZS1pbnRlcnZhbC10cmVlXCI7XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZ2Uobm9kZSkge1xuICAvLyBzcmM6IFwiPHN0YXJ0Pjo8bGVuZ3RoPjo8Xz5cIlxuICAvLyByZXR1cm5zIFtzdGFydCwgZW5kXVxuICBsZXQgW3N0YXJ0LCBsZW5ndGhdID0gbm9kZS5zcmNcbiAgICAuc3BsaXQoXCI6XCIpXG4gICAgLnNsaWNlKDAsIDIpXG4gICAgLm1hcCggKGkpID0+IHBhcnNlSW50KGkpICk7XG5cbiAgcmV0dXJuIFtzdGFydCwgc3RhcnQgKyBsZW5ndGhdO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5nZU5vZGVzKG5vZGUsIHBvaW50ZXIgPSBcIlwiKSB7XG4gIGlmIChub2RlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KFxuICAgICAgLi4ubm9kZS5tYXAoIChzdWIsIGkpID0+IHJhbmdlTm9kZXMoc3ViLCBgJHtwb2ludGVyfS8ke2l9YCkgKVxuICAgICk7XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICBpZiAobm9kZS5zcmMpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7cG9pbnRlciwgcmFuZ2U6IGdldFJhbmdlKG5vZGUpfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHMuY29uY2F0KFxuICAgICAgLi4uT2JqZWN0LmtleXMobm9kZSkubWFwKFxuICAgICAgICAoa2V5KSA9PiByYW5nZU5vZGVzKG5vZGVba2V5XSwgYCR7cG9pbnRlcn0vJHtrZXl9YClcbiAgICAgIClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUmFuZ2Uobm9kZSwgc291cmNlU3RhcnQsIHNvdXJjZUxlbmd0aCkge1xuICBsZXQgcmFuZ2VzID0gcmFuZ2VOb2Rlcyhub2RlKTtcbiAgbGV0IHRyZWUgPSBuZXcgSW50ZXJ2YWxUcmVlKCk7XG5cbiAgcmFuZ2VzLmZvckVhY2goICh7cmFuZ2UsIHBvaW50ZXJ9KSA9PiB7XG4gICAgbGV0IFtzdGFydCwgZW5kXSA9IHJhbmdlO1xuXG4gICAgdHJlZS5pbnNlcnQoc3RhcnQsIGVuZCwge3JhbmdlLCBwb2ludGVyfSk7XG4gIH0pO1xuXG4gIGxldCBzb3VyY2VFbmQgPSBzb3VyY2VTdGFydCArIHNvdXJjZUxlbmd0aDtcblxuICBsZXQgb3ZlcmxhcHBpbmcgPSB0cmVlLnNlYXJjaChzb3VyY2VTdGFydCwgc291cmNlRW5kKTtcblxuICAvLyBmaW5kIG5vZGVzIHRoYXQgZnVsbHkgY29udGFpbiByZXF1ZXN0ZWQgcmFuZ2UsXG4gIC8vIHJldHVybiBsb25nZXN0IHBvaW50ZXJcbiAgcmV0dXJuIG92ZXJsYXBwaW5nXG4gICAgLmZpbHRlciggKHtyYW5nZX0pID0+IHNvdXJjZVN0YXJ0ID49IHJhbmdlWzBdICYmIHNvdXJjZUVuZCA8PSByYW5nZVsxXSApXG4gICAgLm1hcCggKHtwb2ludGVyfSkgPT4gcG9pbnRlciApXG4gICAgLnJlZHVjZSggKGEsIGIpID0+IGEubGVuZ3RoID4gYi5sZW5ndGggPyBhIDogYiwgXCJcIiApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9hc3QvbWFwLmpzIiwiZXhwb3J0IGNvbnN0IEJFR0lOX1NURVAgPSBcIkJFR0lOX1NURVBcIjtcbmV4cG9ydCBmdW5jdGlvbiBiZWdpblN0ZXAodHlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEJFR0lOX1NURVAsXG4gICAgc3RlcFR5cGU6IHR5cGVcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEFEVkFOQ0UgPSBcIkFEVkFOQ0VcIjtcbmV4cG9ydCBmdW5jdGlvbiBhZHZhbmNlKCkge1xuICByZXR1cm4ge3R5cGU6IEFEVkFOQ0V9O1xufVxuXG5leHBvcnQgY29uc3QgU1RFUF9ORVhUID0gXCJTVEVQX05FWFRcIjtcbmV4cG9ydCBmdW5jdGlvbiBzdGVwTmV4dCgpIHtcbiAgcmV0dXJuIHt0eXBlOiBTVEVQX05FWFR9O1xufVxuXG5leHBvcnQgY29uc3QgU1RFUF9PVkVSID0gXCJTVEVQX09WRVJcIjtcbmV4cG9ydCBmdW5jdGlvbiBzdGVwT3ZlcigpIHtcbiAgcmV0dXJuIHt0eXBlOiBTVEVQX09WRVJ9O1xufVxuXG5leHBvcnQgY29uc3QgU1RFUF9JTlRPID0gXCJTVEVQX0lOVE9cIjtcbmV4cG9ydCBmdW5jdGlvbiBzdGVwSW50bygpIHtcbiAgcmV0dXJuIHt0eXBlOiBTVEVQX0lOVE99O1xufVxuXG5leHBvcnQgY29uc3QgU1RFUF9PVVQgPSBcIlNURVBfT1VUXCI7XG5leHBvcnQgZnVuY3Rpb24gc3RlcE91dCgpIHtcbiAgcmV0dXJuIHt0eXBlOiBTVEVQX09VVH07XG59XG5cbmV4cG9ydCBjb25zdCBJTlRFUlJVUFQgPSBcIklOVEVSUlVQVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGludGVycnVwdCAoKSB7XG4gIHJldHVybiB7dHlwZTogSU5URVJSVVBUfTtcbn1cblxuXG5leHBvcnQgY29uc3QgQ09OVElOVUVfVU5USUwgPSBcIkNPTlRJTlVFX1VOVElMXCI7XG5leHBvcnQgZnVuY3Rpb24gY29udGludWVVbnRpbCguLi5icmVha3BvaW50cykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IENPTlRJTlVFX1VOVElMLFxuICAgIGJyZWFrcG9pbnRzXG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2NvbnRyb2xsZXIvYWN0aW9ucy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpkYXRhOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBwdXQsIHRha2VFdmVyeSwgc2VsZWN0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuaW1wb3J0IGpzb25wb2ludGVyIGZyb20gXCJqc29uLXBvaW50ZXJcIjtcblxuaW1wb3J0IHsgcHJlZml4TmFtZSB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgeyBUSUNLIH0gZnJvbSBcImxpYi90cmFjZS9hY3Rpb25zXCI7XG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5cbmltcG9ydCBkYXRhIGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuaW1wb3J0IHsgV09SRF9TSVpFIH0gZnJvbSBcImxpYi9kYXRhL2RlY29kZS91dGlsc1wiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcImxpYi9kYXRhL2RlY29kZS91dGlsc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gKnNjb3BlKG5vZGVJZCwgcG9pbnRlciwgcGFyZW50SWQsIHNvdXJjZUlkKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnNjb3BlKG5vZGVJZCwgcG9pbnRlciwgcGFyZW50SWQsIHNvdXJjZUlkKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAqZGVjbGFyZShub2RlKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmRlY2xhcmUobm9kZSkpO1xufVxuXG5mdW5jdGlvbiAqdGlja1NhZ2EoKSB7XG4gIGxldCB7XG4gICAgdHJlZSxcbiAgICBpZDogdHJlZUlkLFxuICAgIG5vZGUsXG4gICAgcG9pbnRlclxuICB9ID0geWllbGQgc2VsZWN0KGRhdGEudmlld3MuYXN0KTtcblxuICBsZXQgZGVjb2RlID0geWllbGQgc2VsZWN0KGRhdGEudmlld3MuZGVjb2Rlcik7XG4gIGxldCBzY29wZXMgPSB5aWVsZCBzZWxlY3QoZGF0YS5pbmZvLnNjb3Blcyk7XG4gIGxldCBkZWZpbml0aW9ucyA9IHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLnNjb3Blcy5pbmxpbmVkKTtcbiAgbGV0IGN1cnJlbnRBc3NpZ25tZW50cyA9IHlpZWxkIHNlbGVjdChkYXRhLnByb2MuYXNzaWdubWVudHMpO1xuXG4gIGxldCBzdGFjayA9IHlpZWxkIHNlbGVjdChkYXRhLm5leHQuc3RhdGUuc3RhY2spO1xuICBpZiAoIXN0YWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHRvcCA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gIHZhciBwYXJhbWV0ZXJzLCByZXR1cm5QYXJhbWV0ZXJzLCBhc3NpZ25tZW50cywgc3RvcmFnZVZhcnM7XG5cbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc3RhY2sgaXMgb25seSByZWFkeSBmb3IgaW50ZXJwcmV0YXRpb24gYWZ0ZXIgdGhlIGxhc3Qgc3RlcCBvZiBlYWNoXG4gIC8vIHNvdXJjZSByYW5nZVxuICAvL1xuICAvLyB0aGUgZGF0YSBtb2R1bGUgYWx3YXlzIGxvb2tzIGF0IHRoZSByZXN1bHQgb2YgYSBwYXJ0aWN1bGFyIG9wY29kZVxuICAvLyAoaS5lLiwgdGhlIGZvbGxvd2luZyB0cmFjZSBzdGVwJ3Mgc3RhY2svbWVtb3J5L3N0b3JhZ2UpLCBzbyB0aGlzXG4gIC8vIGFzc2VydHMgdGhhdCB0aGUgX2N1cnJlbnRfIG9wZXJhdGlvbiBpcyB0aGUgZmluYWwgb25lIGJlZm9yZVxuICAvLyBwcm9jZWVkaW5nXG4gIGlmICghKHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLmF0TGFzdEluc3RydWN0aW9uRm9yU291cmNlUmFuZ2UpKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuXG4gICAgY2FzZSBcIkZ1bmN0aW9uRGVmaW5pdGlvblwiOlxuICAgICAgcGFyYW1ldGVycyA9IG5vZGUucGFyYW1ldGVycy5wYXJhbWV0ZXJzXG4gICAgICAgIC5tYXAoIChwLCBpKSA9PiBgJHtwb2ludGVyfS9wYXJhbWV0ZXJzL3BhcmFtZXRlcnMvJHtpfWAgKTtcblxuICAgICAgcmV0dXJuUGFyYW1ldGVycyA9IG5vZGUucmV0dXJuUGFyYW1ldGVycy5wYXJhbWV0ZXJzXG4gICAgICAgIC5tYXAoIChwLCBpKSA9PiBgJHtwb2ludGVyfS9yZXR1cm5QYXJhbWV0ZXJzL3BhcmFtZXRlcnMvJHtpfWAgKTtcblxuICAgICAgYXNzaWdubWVudHMgPSByZXR1cm5QYXJhbWV0ZXJzLmNvbmNhdChwYXJhbWV0ZXJzKS5yZXZlcnNlKClcbiAgICAgICAgLm1hcCggKHBvaW50ZXIpID0+IGpzb25wb2ludGVyLmdldCh0cmVlLCBwb2ludGVyKS5pZCApXG4gICAgICAgIC5tYXAoIChpZCwgaSkgPT4gKHsgW2lkXToge1wic3RhY2tcIjogdG9wIC0gaX0gfSkgKVxuICAgICAgICAucmVkdWNlKCAoYWNjLCBhc3NpZ25tZW50KSA9PiBPYmplY3QuYXNzaWduKGFjYywgYXNzaWdubWVudCksIHt9ICk7XG5cbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmFzc2lnbih0cmVlSWQsIGFzc2lnbm1lbnRzKSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJDb250cmFjdERlZmluaXRpb25cIjpcbiAgICAgIGxldCBzdG9yYWdlVmFycyA9IHNjb3Blc1tub2RlLmlkXS52YXJpYWJsZXMgfHwgW107XG4gICAgICBsZXQgc2xvdCA9IDA7XG4gICAgICBsZXQgaW5kZXggPSBXT1JEX1NJWkUgLSAxOyAgLy8gY2F1c2UgbG93ZXItb3JkZXJcbiAgICAgIGRlYnVnKFwic3RvcmFnZSB2YXJzICVvXCIsIHN0b3JhZ2VWYXJzKTtcblxuICAgICAgbGV0IGFsbG9jYXRpb24gPSB1dGlscy5hbGxvY2F0ZURlY2xhcmF0aW9ucyhzdG9yYWdlVmFycywgZGVmaW5pdGlvbnMpO1xuICAgICAgYXNzaWdubWVudHMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSwgLi4uT2JqZWN0LmVudHJpZXMoYWxsb2NhdGlvbi5jaGlsZHJlbilcbiAgICAgICAgICAubWFwKCAoW2lkLCBzdG9yYWdlXSkgPT4gKHtcbiAgICAgICAgICAgIFtpZF06IHtcbiAgICAgICAgICAgICAgLi4uKGN1cnJlbnRBc3NpZ25tZW50c1tpZF0gfHwgeyByZWY6IHt9IH0pLnJlZixcbiAgICAgICAgICAgICAgc3RvcmFnZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pIClcbiAgICAgICk7XG4gICAgICBkZWJ1ZyhcImFzc2lnbm1lbnRzICVPXCIsIGFzc2lnbm1lbnRzKTtcblxuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuYXNzaWduKHRyZWVJZCwgYXNzaWdubWVudHMpKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjpcbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmFzc2lnbih0cmVlSWQsIHtcbiAgICAgICAgW2pzb25wb2ludGVyLmdldCh0cmVlLCBwb2ludGVyKS5pZF06IHtcInN0YWNrXCI6IHRvcH1cbiAgICAgIH0pKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIkluZGV4QWNjZXNzXCI6XG4gICAgICAvLyB0byB0cmFjayBgbWFwcGluZ2AgdHlwZXMga25vd24gaW5kZXhlc1xuICAgICAgbGV0IHtcbiAgICAgICAgYmFzZUV4cHJlc3Npb246IHtcbiAgICAgICAgICBpZDogYmFzZUlkLFxuICAgICAgICAgIHJlZmVyZW5jZWREZWNsYXJhdGlvbjogYmFzZURlY2xhcmF0aW9uSWQsXG4gICAgICAgIH0sXG4gICAgICAgIGluZGV4RXhwcmVzc2lvbjoge1xuICAgICAgICAgIGlkOiBpbmRleElkLFxuICAgICAgICB9XG4gICAgICB9ID0gbm9kZTtcblxuICAgICAgbGV0IGJhc2VBc3NpZ25tZW50ID0gKGN1cnJlbnRBc3NpZ25tZW50c1tiYXNlRGVjbGFyYXRpb25JZF0gfHwge1xuICAgICAgICByZWY6IHt9XG4gICAgICB9KS5yZWY7XG4gICAgICBkZWJ1ZyhcImJhc2VBc3NpZ25tZW50ICVPXCIsIGJhc2VBc3NpZ25tZW50KTtcblxuICAgICAgbGV0IGJhc2VEZWZpbml0aW9uID0gZGVmaW5pdGlvbnNbYmFzZURlY2xhcmF0aW9uSWRdLmRlZmluaXRpb247XG4gICAgICBpZiAodXRpbHMudHlwZUNsYXNzKGJhc2VEZWZpbml0aW9uKSAhPT0gXCJtYXBwaW5nXCIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluZGV4QXNzaWdubWVudCA9IChjdXJyZW50QXNzaWdubWVudHNbaW5kZXhJZF0gfHwge30pLnJlZjtcbiAgICAgIGNvbnN0IGluZGV4VmFsdWUgPSAoaW5kZXhBc3NpZ25tZW50KVxuICAgICAgICA/IGRlY29kZShub2RlLmluZGV4RXhwcmVzc2lvbiwgaW5kZXhBc3NpZ25tZW50KVxuICAgICAgICA6IHV0aWxzLnRvQnl0ZXMobm9kZS5pbmRleEV4cHJlc3Npb24uaGV4VmFsdWUpO1xuXG4gICAgICBkZWJ1ZyhcImluZGV4IHZhbHVlICVPXCIsIGluZGV4VmFsdWUpO1xuICAgICAgaWYgKGluZGV4VmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhc3NpZ25tZW50cyA9IHtcbiAgICAgICAgW2Jhc2VEZWNsYXJhdGlvbklkXToge1xuICAgICAgICAgIC4uLmJhc2VBc3NpZ25tZW50LFxuICAgICAgICAgIGtleXM6IFtcbiAgICAgICAgICAgIC4uLm5ldyBTZXQoW1xuICAgICAgICAgICAgICAuLi4oYmFzZUFzc2lnbm1lbnQua2V5cyB8fCBbXSksXG4gICAgICAgICAgICAgIGluZGV4VmFsdWVcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlYnVnKFwibWFwcGluZyBhc3NpZ25tZW50cyAlT1wiLCBhc3NpZ25tZW50cyk7XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5hc3NpZ24odHJlZUlkLCBhc3NpZ25tZW50cykpO1xuICAgICAgZGVidWcoXCJuZXcgYXNzaWdubWVudHMgJU9cIiwgeWllbGQgc2VsZWN0KGRhdGEucHJvYy5hc3NpZ25tZW50cykpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiQXNzaWdubWVudFwiOlxuICAgICAgYnJlYWs7XG5cblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAobm9kZS50eXBlRGVzY3JpcHRpb25zID09IHVuZGVmaW5lZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZGVidWcoXCJkZWNvZGluZyBleHByZXNzaW9uIHZhbHVlICVPXCIsIG5vZGUudHlwZURlc2NyaXB0aW9ucyk7XG4gICAgICBsZXQgbGl0ZXJhbCA9IGRlY29kZShub2RlLCB7IFwic3RhY2tcIjogdG9wIH0pO1xuXG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5hc3NpZ24odHJlZUlkLCB7XG4gICAgICAgIFtub2RlLmlkXTogeyBsaXRlcmFsIH1cbiAgICAgIH0pKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSAoKSB7XG4gIHlpZWxkIHRha2VFdmVyeShUSUNLLCBmdW5jdGlvbiogKCkge1xuICAgIHRyeSB7XG4gICAgICB5aWVsZCAqdGlja1NhZ2EoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZyhlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwiZGF0YVwiLCBzYWdhKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGF0YS9zYWdhcy9pbmRleC5qcyIsImV4cG9ydCBjb25zdCBTQ09QRSA9IFwiU0NPUEVcIjtcbmV4cG9ydCBmdW5jdGlvbiBzY29wZShpZCwgcG9pbnRlciwgcGFyZW50SWQsIHNvdXJjZUlkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU0NPUEUsXG4gICAgaWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZFxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBERUNMQVJFID0gXCJERUNMQVJFX1ZBUklBQkxFXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVjbGFyZShub2RlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogREVDTEFSRSxcbiAgICBub2RlXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEFTU0lHTiA9IFwiQVNTSUdOXCI7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKGNvbnRleHQsIGFzc2lnbm1lbnRzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQVNTSUdOLFxuICAgIGNvbnRleHQsIGFzc2lnbm1lbnRzXG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvYWN0aW9ucy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjp0cmFjZTpzYWdhc1wiKTtcblxuaW1wb3J0IHsgdGFrZSwgdGFrZUV2ZXJ5LCBwdXQsIHNlbGVjdCB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuXG5pbXBvcnQgdHJhY2UgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5mdW5jdGlvbiAqd2FpdEZvclRyYWNlKCkge1xuICBsZXQge3N0ZXBzfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5TQVZFX1NURVBTKTtcblxuICBsZXQgYWRkcmVzc2VzID0gW1xuICAgIC4uLm5ldyBTZXQoXG4gICAgICBzdGVwc1xuICAgICAgICAuZmlsdGVyKCAoe29wfSkgPT4gb3AgPT0gXCJDQUxMXCIgfHwgb3AgPT0gXCJERUxFR0FURUNBTExcIiApXG4gICAgICAgIC5tYXAoICh7c3RhY2t9KSA9PiBcIjB4XCIgKyBzdGFja1tzdGFjay5sZW5ndGggLSAyXS5zdWJzdHJpbmcoMjQpIClcbiAgICApXG4gIF07XG5cbiAgeWllbGQgcHV0KGFjdGlvbnMucmVjZWl2ZUFkZHJlc3NlcyhhZGRyZXNzZXMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uICphZHZhbmNlKCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5uZXh0KCkpO1xuXG4gIHlpZWxkIHRha2UoYWN0aW9ucy5UT0NLKTtcbn1cblxuZnVuY3Rpb24qIG5leHQoKSB7XG4gIGxldCByZW1haW5pbmcgPSB5aWVsZCBzZWxlY3QodHJhY2Uuc3RlcHNSZW1haW5pbmcpO1xuICBkZWJ1ZyhcInJlbWFpbmluZzogJW9cIiwgcmVtYWluaW5nKTtcbiAgbGV0IHN0ZXBzID0geWllbGQgc2VsZWN0KHRyYWNlLnN0ZXBzKTtcbiAgZGVidWcoXCJ0b3RhbCBzdGVwczogJW9cIiwgc3RlcHMubGVuZ3RoKTtcblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIGRlYnVnKFwicHV0dGluZyBUSUNLXCIpO1xuICAgIC8vIHVwZGF0ZXMgc3RhdGUgZm9yIGN1cnJlbnQgc3RlcFxuICAgIHlpZWxkIHB1dChhY3Rpb25zLnRpY2soKSk7XG4gICAgZGVidWcoXCJwdXQgVElDS1wiKTtcblxuICAgIHJlbWFpbmluZy0tOyAvLyBsb2NhbCB1cGRhdGUsIGp1c3QgZm9yIGNvbnZlbmllbmNlXG4gIH1cblxuICBpZiAocmVtYWluaW5nKSB7XG4gICAgZGVidWcoXCJwdXR0aW5nIFRPQ0tcIik7XG4gICAgLy8gdXBkYXRlcyBzdGVwIHRvIG5leHQgc3RlcCBpbiB0cmFjZVxuICAgIHlpZWxkIHB1dChhY3Rpb25zLnRvY2soKSk7XG4gICAgZGVidWcoXCJwdXQgVE9DS1wiKTtcblxuICB9IGVsc2Uge1xuXG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZW5kVHJhY2UoKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiB3YWl0KCkge1xuICB5aWVsZCB0YWtlKGFjdGlvbnMuRU5EX09GX1RSQUNFKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uICpwcm9jZXNzVHJhY2UodHJhY2UpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuc2F2ZVN0ZXBzKHRyYWNlKSk7XG5cbiAgbGV0IHthZGRyZXNzZXN9ID0geWllbGQgdGFrZShhY3Rpb25zLlJFQ0VJVkVfQUREUkVTU0VTKTtcbiAgZGVidWcoXCJyZWNlaXZlZCBhZGRyZXNzZXNcIik7XG5cbiAgcmV0dXJuIGFkZHJlc3Nlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICAvLyB3YWl0IGZvciB0cmFjZSB0byBiZSBkZWZpbmVkXG4gIHlpZWxkICp3YWl0Rm9yVHJhY2UoKTtcblxuICB5aWVsZCB0YWtlRXZlcnkoYWN0aW9ucy5ORVhULCBuZXh0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcInRyYWNlXCIsIHNhZ2EpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi90cmFjZS9zYWdhcy9pbmRleC5qcyIsImV4cG9ydCBjb25zdCBBRERfU09VUkNFID0gXCJTT0xJRElUWV9BRERfU09VUkNFXCI7XG5leHBvcnQgZnVuY3Rpb24gYWRkU291cmNlKHNvdXJjZSwgc291cmNlUGF0aCwgYXN0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX1NPVVJDRSxcbiAgICBzb3VyY2UsIHNvdXJjZVBhdGgsIGFzdFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgQUREX1NPVVJDRU1BUCA9IFwiU09MSURJVFlfQUREX1NPVVJDRU1BUFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFNvdXJjZU1hcChiaW5hcnksIHNvdXJjZU1hcCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFERF9TT1VSQ0VNQVAsXG4gICAgYmluYXJ5LCBzb3VyY2VNYXBcbiAgfTtcbn1cblxuXG5leHBvcnQgY29uc3QgSlVNUCA9IFwiSlVNUFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGp1bXAoanVtcERpcmVjdGlvbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEpVTVAsXG4gICAganVtcERpcmVjdGlvblxuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zb2xpZGl0eS9hY3Rpb25zL2luZGV4LmpzIiwiZXhwb3J0IGNvbnN0IEFERF9DT05URVhUID0gXCJFVk1fQUREX0NPTlRFWFRcIjtcbmV4cG9ydCBmdW5jdGlvbiBhZGRDb250ZXh0KGNvbnRyYWN0TmFtZSwgYmluYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX0NPTlRFWFQsXG4gICAgY29udHJhY3ROYW1lLCBiaW5hcnlcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQUREX0lOU1RBTkNFID0gXCJFVk1fQUREX0lOU1RBTkNFXCI7XG5leHBvcnQgZnVuY3Rpb24gYWRkSW5zdGFuY2UoYWRkcmVzcywgY29udGV4dCwgYmluYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX0lOU1RBTkNFLFxuICAgIGFkZHJlc3MsIGNvbnRleHQsIGJpbmFyeVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBDQUxMID0gXCJDQUxMXCI7XG5leHBvcnQgZnVuY3Rpb24gY2FsbChhZGRyZXNzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQ0FMTCxcbiAgICBhZGRyZXNzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBDUkVBVEUgPSBcIkNSRUFURVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShiaW5hcnkpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBDUkVBVEUsXG4gICAgYmluYXJ5XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRVRVUk4gPSBcIlJFVFVSTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkNhbGwoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVUVVJOXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZXZtL2FjdGlvbnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6c2Vzc2lvbjpzZWxlY3RvcnNcIik7XG5cbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yVHJlZSwgY3JlYXRlTGVhZiB9IGZyb20gXCJyZXNlbGVjdC10cmVlXCI7XG5cbmltcG9ydCBldm0gZnJvbSBcImxpYi9ldm0vc2VsZWN0b3JzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcblxuY29uc3Qgc2Vzc2lvbiA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG4gIC8qKlxuICAgKiBzZXNzaW9uLmluZm9cbiAgICovXG4gIGluZm86IHtcblxuICAgIC8qKlxuICAgICAqIHNlc3Npb24uaW5mby5hZmZlY3RlZEluc3RhbmNlc1xuICAgICAqL1xuICAgIGFmZmVjdGVkSW5zdGFuY2VzOiBjcmVhdGVMZWFmKFxuICAgICAgW2V2bS5pbmZvLmluc3RhbmNlcywgZXZtLmluZm8uY29udGV4dHMsIHNvbGlkaXR5LmluZm8uc291cmNlcywgc29saWRpdHkuaW5mby5zb3VyY2VNYXBzXSxcblxuICAgICAgKGluc3RhbmNlcywgY29udGV4dHMsIHNvdXJjZXMsIHNvdXJjZU1hcHMpID0+IE9iamVjdC5hc3NpZ24oe30sXG4gICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKGluc3RhbmNlcykubWFwKFxuICAgICAgICAgIChbYWRkcmVzcywge2NvbnRleHR9XSkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29udHJhY3ROYW1lLCBiaW5hcnkgfSA9IGNvbnRleHRzW2NvbnRleHRdO1xuICAgICAgICAgICAgbGV0IHsgc291cmNlTWFwIH0gPSBzb3VyY2VNYXBzW2NvbnRleHRdO1xuXG4gICAgICAgICAgICBsZXQgeyBzb3VyY2UgfSA9IHNvdXJjZU1hcCA/XG4gICAgICAgICAgICAgIC8vIGxvb2sgZm9yIHNvdXJjZSBJRCBiZXR3ZWVuIHNlY29uZCBhbmQgdGhpcmQgY29sb25zIChIQUNLKVxuICAgICAgICAgICAgICBzb3VyY2VzW3NvdXJjZU1hcC5tYXRjaCgvXlteOl0rOlteOl0rOihbXjpdKyk6LylbMV1dIDpcbiAgICAgICAgICAgICAge307XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIFthZGRyZXNzXToge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0TmFtZSwgc291cmNlLCBiaW5hcnlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIClcbiAgICApXG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzZXNzaW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zZXNzaW9uL3NlbGVjdG9ycy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJ0ZXN0OmRhdGE6ZGVjb2RlXCIpO1xuXG5pbXBvcnQgR2FuYWNoZSBmcm9tIFwiZ2FuYWNoZS1jbGlcIjtcbmltcG9ydCBXZWIzIGZyb20gXCJ3ZWIzXCI7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiY2hhaVwiO1xuaW1wb3J0IGNoYW5nZUNhc2UgZnJvbSBcImNoYW5nZS1jYXNlXCI7XG5cbmltcG9ydCB7IHByZXBhcmVDb250cmFjdHMgfSBmcm9tIFwidGVzdC9oZWxwZXJzXCI7XG5cbmltcG9ydCBEZWJ1Z2dlciBmcm9tIFwibGliL2RlYnVnZ2VyXCI7XG5cbmltcG9ydCB7IGNsZWFuQmlnTnVtYmVycyB9IGZyb20gXCJsaWIvZGF0YS9kZWNvZGUvdXRpbHNcIjtcblxuaW1wb3J0IGRhdGEgZnJvbSBcImxpYi9kYXRhL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uICpnZW5lcmF0ZVVpbnRzKCkge1xuICBsZXQgeCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgeWllbGQgeDtcbiAgICB4Kys7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29udHJhY3ROYW1lKHRlc3ROYW1lKSB7XG4gIHJldHVybiB0ZXN0TmFtZS5yZXBsYWNlKC8gL2csIFwiXCIpO1xufVxuXG5mdW5jdGlvbiBmaWxlTmFtZSh0ZXN0TmFtZSkge1xuICByZXR1cm4gYCR7Y29udHJhY3ROYW1lKHRlc3ROYW1lKX0uc29sYDtcbn1cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZVRlc3RzKGZpeHR1cmVzKSB7XG4gIGZvciAobGV0IHsgbmFtZSwgdmFsdWU6IGV4cGVjdGVkIH0gb2YgZml4dHVyZXMpIHtcbiAgICBpdChgY29ycmVjdGx5IGRlY29kZXMgJHtuYW1lfWAsXG4gICAgICAoKSA9PiB7IGFzc2VydC5kZWVwRXF1YWwodGhpcy5kZWNvZGUobmFtZSksIGV4cGVjdGVkKTsgfVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGFzdFN0YXRlbWVudExpbmUoc291cmNlKSB7XG4gIGNvbnN0IGxpbmVzID0gc291cmNlLnNwbGl0KFwiXFxuXCIpO1xuICBmb3IgKGxldCBpID0gbGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgbGluZSA9IGxpbmVzW2ldO1xuICAgIGlmIChsaW5lLmluZGV4T2YoXCI7XCIpICE9IC0xKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbn1cblxuXG5hc3luYyBmdW5jdGlvbiBwcmVwYXJlRGVidWdnZXIodGVzdE5hbWUsIHNvdXJjZXMpIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBHYW5hY2hlLnByb3ZpZGVyKHtzZWVkOiBcImRlYnVnZ2VyXCIsIGdhc0xpbWl0OiA3MDAwMDAwfSk7XG4gIGNvbnN0IHdlYjMgPSBuZXcgV2ViMyhwcm92aWRlcik7XG5cbiAgbGV0IHsgYWJzdHJhY3Rpb25zLCBhcnRpZmFjdHM6IGNvbnRyYWN0cywgZmlsZXMgfSA9XG4gICAgYXdhaXQgcHJlcGFyZUNvbnRyYWN0cyhwcm92aWRlciwgc291cmNlcyk7XG5cbiAgbGV0IGluc3RhbmNlID0gYXdhaXQgYWJzdHJhY3Rpb25zW2NvbnRyYWN0TmFtZSh0ZXN0TmFtZSldLmRlcGxveWVkKCk7XG4gIGxldCByZWNlaXB0ID0gYXdhaXQgaW5zdGFuY2UucnVuKCk7XG4gIGxldCB0eEhhc2ggPSByZWNlaXB0LnR4O1xuXG4gIGxldCBidWdnZXIgPSBhd2FpdCBEZWJ1Z2dlci5mb3JUeCh0eEhhc2gsIHsgcHJvdmlkZXIsIGZpbGVzLCBjb250cmFjdHMgfSk7XG5cbiAgbGV0IHNlc3Npb24gPSBidWdnZXIuY29ubmVjdCgpO1xuXG4gIGxldCBicmVha3BvaW50ID0ge1xuICAgIGFkZHJlc3M6IGluc3RhbmNlLmFkZHJlc3MsXG4gICAgbGluZTogbGFzdFN0YXRlbWVudExpbmUoc291cmNlc1tmaWxlTmFtZSh0ZXN0TmFtZSldKVxuICB9O1xuXG4gIHNlc3Npb24uY29udGludWVVbnRpbChicmVha3BvaW50KTtcblxuICByZXR1cm4gc2Vzc2lvbjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0RGVjb2RlKHNlc3Npb24pIHtcbiAgY29uc3QgZGVmaW5pdGlvbnMgPSBzZXNzaW9uLnZpZXcoZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzLmRlZmluaXRpb25zKTtcbiAgY29uc3QgcmVmcyA9IHNlc3Npb24udmlldyhkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMucmVmcyk7XG5cbiAgY29uc3QgZGVjb2RlID0gc2Vzc2lvbi52aWV3KGRhdGEudmlld3MuZGVjb2Rlcik7XG4gIHJldHVybiAobmFtZSkgPT4gY2xlYW5CaWdOdW1iZXJzKFxuICAgIGRlY29kZShkZWZpbml0aW9uc1tuYW1lXSwgcmVmc1tuYW1lXSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc2NyaWJlRGVjb2RpbmcodGVzdE5hbWUsIGZpeHR1cmVzLCBzZWxlY3RvciwgZ2VuZXJhdGVTb3VyY2UpIHtcbiAgY29uc3Qgc291cmNlcyA9IHtcbiAgICBbZmlsZU5hbWUodGVzdE5hbWUpXTogZ2VuZXJhdGVTb3VyY2UoY29udHJhY3ROYW1lKHRlc3ROYW1lKSwgZml4dHVyZXMpXG4gIH07XG5cbiAgZGVzY3JpYmUodGVzdE5hbWUsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHRlc3REZWJ1ZyA9IGRlYnVnTW9kdWxlKFxuICAgICAgYHRlc3Q6ZGF0YTpkZWNvZGU6JHtjaGFuZ2VDYXNlLnBhcmFtQ2FzZSh0ZXN0TmFtZSl9YFxuICAgICk7XG5cbiAgICB0aGlzLnRpbWVvdXQoMzAwMDApO1xuXG4gICAgYmVmb3JlKFwicnVucyBhbmQgb2JzZXJ2ZXMgZGVidWdnZXJcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHByZXBhcmVEZWJ1Z2dlcih0ZXN0TmFtZSwgc291cmNlcyk7XG4gICAgICB0aGlzLmRlY29kZSA9IGF3YWl0IGdldERlY29kZShzZXNzaW9uKTtcblxuICAgICAgdGVzdERlYnVnKFwic3RvcmFnZSAlT1wiLCBzZXNzaW9uLnZpZXcoZXZtLmN1cnJlbnQuc3RhdGUuc3RvcmFnZSkpO1xuXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgZGVidWcoXCJzZWxlY3RvciAlT1wiLCBzZXNzaW9uLnZpZXcoc2VsZWN0b3IpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGdlbmVyYXRlVGVzdHMuYmluZCh0aGlzKShmaXh0dXJlcyk7XG4gIH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHRlc3QvZGF0YS9kZWNvZGUvaGVscGVycy5qcyIsIi8vIHJ1bnRpbWUgaGVscGVyXG5mdW5jdGlvbiBpbk1hbmlmZXN0KGlkKSB7IHJldHVybiBnbG9iYWwuX193ZWJwYWNrTWFuaWZlc3RfXy5pbmRleE9mKGlkKSA+PSAwO31cbmZ1bmN0aW9uIHJ1bihpZCkgeyBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTt9XG5cbi8vIG1vZHVsZXMgdG8gZXhlY3V0ZSBnb2VzIGhlcmVcbnZhciBpZHMgPSBbXG5yZXF1aXJlLnJlc29sdmUoXCIuLi8uLi8uLi9wYWNrYWdlcy90cnVmZmxlLWRlYnVnZ2VyL3Rlc3QvYXN0LmpzXCIpLHJlcXVpcmUucmVzb2x2ZShcIi4uLy4uLy4uL3BhY2thZ2VzL3RydWZmbGUtZGVidWdnZXIvdGVzdC9jb250ZXh0LmpzXCIpLHJlcXVpcmUucmVzb2x2ZShcIi4uLy4uLy4uL3BhY2thZ2VzL3RydWZmbGUtZGVidWdnZXIvdGVzdC9kYXRhL2RlY29kZS9kZWNvZGluZy5qc1wiKSxyZXF1aXJlLnJlc29sdmUoXCIuLi8uLi8uLi9wYWNrYWdlcy90cnVmZmxlLWRlYnVnZ2VyL3Rlc3QvZGF0YS9kZWNvZGUvaGVscGVycy5qc1wiKSxyZXF1aXJlLnJlc29sdmUoXCIuLi8uLi8uLi9wYWNrYWdlcy90cnVmZmxlLWRlYnVnZ2VyL3Rlc3QvZGF0YS9kZWNvZGUvdXRpbHMuanNcIikscmVxdWlyZS5yZXNvbHZlKFwiLi4vLi4vLi4vcGFja2FnZXMvdHJ1ZmZsZS1kZWJ1Z2dlci90ZXN0L2V2bS5qc1wiKSxyZXF1aXJlLnJlc29sdmUoXCIuLi8uLi8uLi9wYWNrYWdlcy90cnVmZmxlLWRlYnVnZ2VyL3Rlc3QvaGVscGVycy5qc1wiKSxyZXF1aXJlLnJlc29sdmUoXCIuLi8uLi8uLi9wYWNrYWdlcy90cnVmZmxlLWRlYnVnZ2VyL3Rlc3Qvc29saWRpdHkuanNcIilcbl07XG5cbmlkcy5maWx0ZXIoaW5NYW5pZmVzdCkuZm9yRWFjaChydW4pXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9tb2NoYS13ZWJwYWNrL2xpYi9lbnRyeS5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcInRlc3Q6YXN0XCIpO1xuXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiY2hhaVwiO1xuXG5pbXBvcnQgR2FuYWNoZSBmcm9tIFwiZ2FuYWNoZS1jbGlcIjtcbmltcG9ydCBXZWIzIGZyb20gXCJ3ZWIzXCI7XG5cbmltcG9ydCB7IHByZXBhcmVDb250cmFjdHMgfSBmcm9tIFwiLi9oZWxwZXJzXCI7XG5pbXBvcnQgRGVidWdnZXIgZnJvbSBcImxpYi9kZWJ1Z2dlclwiO1xuXG5pbXBvcnQgYXN0IGZyb20gXCJsaWIvYXN0L3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNvbGlkaXR5IGZyb20gXCJsaWIvc29saWRpdHkvc2VsZWN0b3JzXCI7XG5cbmltcG9ydCB7IGdldFJhbmdlLCBmaW5kUmFuZ2UsIHJhbmdlTm9kZXMgfSBmcm9tIFwibGliL2FzdC9tYXBcIjtcblxuY29uc3QgX19WQVJJQUJMRVMgPSBgXG5wcmFnbWEgc29saWRpdHkgXjAuNC4xODtcblxuY29udHJhY3QgVmFyaWFibGVzIHtcbiAgZXZlbnQgUmVzdWx0KHVpbnQyNTYgcmVzdWx0KTtcblxuICB1aW50MjU2IHF1eDtcbiAgc3RyaW5nIHF1dXg7XG5cbiAgZnVuY3Rpb24gc3RhY2sodWludDI1NiBmb28pIHB1YmxpYyByZXR1cm5zICh1aW50MjU2KSB7XG4gICAgdWludDI1NiBiYXIgPSBmb28gKyAxO1xuICAgIHVpbnQyNTYgYmF6ID0gaW5uZXJTdGFjayhiYXIpO1xuXG4gICAgYmF6ICs9IDQ7XG5cbiAgICBxdXggPSBiYXo7XG5cbiAgICBSZXN1bHQoYmF6KTtcblxuICAgIHJldHVybiBiYXo7XG4gIH1cblxuICBmdW5jdGlvbiBpbm5lclN0YWNrKHVpbnQyNTYgYmF6KSBwdWJsaWMgcmV0dXJucyAodWludDI1Nikge1xuICAgIHVpbnQyNTYgYmFyID0gYmF6ICsgMjtcbiAgICByZXR1cm4gYmFyO1xuICB9XG59XG5gO1xuXG5cbmxldCBzb3VyY2VzID0ge1xuICBcIlZhcmlhYmxlcy5zb2xcIjogX19WQVJJQUJMRVNcbn1cblxuZGVzY3JpYmUoXCJBU1RcIiwgZnVuY3Rpb24oKSB7XG4gIHZhciBwcm92aWRlcjtcbiAgdmFyIHdlYjM7XG5cbiAgdmFyIGFic3RyYWN0aW9ucztcbiAgdmFyIGFydGlmYWN0cztcbiAgdmFyIGZpbGVzO1xuXG4gIGJlZm9yZShcIkNyZWF0ZSBQcm92aWRlclwiLCBhc3luYyBmdW5jdGlvbigpIHtcbiAgICBwcm92aWRlciA9IEdhbmFjaGUucHJvdmlkZXIoe3NlZWQ6IFwiZGVidWdnZXJcIiwgZ2FzTGltaXQ6IDcwMDAwMDB9KTtcbiAgICB3ZWIzID0gbmV3IFdlYjMocHJvdmlkZXIpO1xuICB9KTtcblxuICBiZWZvcmUoXCJQcmVwYXJlIGNvbnRyYWN0cyBhbmQgYXJ0aWZhY3RzXCIsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGltZW91dCgzMDAwMCk7XG5cbiAgICBsZXQgcHJlcGFyZWQgPSBhd2FpdCBwcmVwYXJlQ29udHJhY3RzKHByb3ZpZGVyLCBzb3VyY2VzKVxuICAgIGFic3RyYWN0aW9ucyA9IHByZXBhcmVkLmFic3RyYWN0aW9ucztcbiAgICBhcnRpZmFjdHMgPSBwcmVwYXJlZC5hcnRpZmFjdHM7XG4gICAgZmlsZXMgPSBwcmVwYXJlZC5maWxlcztcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJOb2RlIHBvaW50ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgaXQoXCJ0cmF2ZXJzZXNcIiwgYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRpbWVvdXQoMCk7XG4gICAgICBsZXQgaW5zdGFuY2UgPSBhd2FpdCBhYnN0cmFjdGlvbnMuVmFyaWFibGVzLmRlcGxveWVkKCk7XG4gICAgICBsZXQgcmVjZWlwdCA9IGF3YWl0IGluc3RhbmNlLnN0YWNrKDQpO1xuICAgICAgbGV0IHR4SGFzaCA9IHJlY2VpcHQudHg7XG5cbiAgICAgIGxldCBidWdnZXIgPSBhd2FpdCBEZWJ1Z2dlci5mb3JUeCh0eEhhc2gsIHtcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIGZpbGVzLFxuICAgICAgICBjb250cmFjdHM6IGFydGlmYWN0c1xuICAgICAgfSk7XG5cbiAgICAgIGxldCBzZXNzaW9uID0gYnVnZ2VyLmNvbm5lY3QoKTtcbiAgICAgIGRlYnVnKFwiYXN0OiAlT1wiLCBzZXNzaW9uLnZpZXcoYXN0LmN1cnJlbnQudHJlZSkpO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBsZW5ndGggfSA9IHNlc3Npb24udmlldyhzb2xpZGl0eS5jdXJyZW50LnNvdXJjZVJhbmdlKTtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgbGVuZ3RoO1xuXG4gICAgICAgIGxldCBub2RlID0gc2Vzc2lvbi52aWV3KGFzdC5jdXJyZW50Lm5vZGUpO1xuXG4gICAgICAgIGxldCBbIG5vZGVTdGFydCwgbm9kZUxlbmd0aCBdID0gZ2V0UmFuZ2Uobm9kZSk7XG4gICAgICAgIGxldCBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZUxlbmd0aDtcblxuICAgICAgICBsZXQgcG9pbnRlciA9IHNlc3Npb24udmlldyhhc3QuY3VycmVudC5wb2ludGVyKTtcblxuICAgICAgICBhc3NlcnQuaXNBdE1vc3QoXG4gICAgICAgICAgbm9kZVN0YXJ0LCBzdGFydCxcbiAgICAgICAgICBgTm9kZSAke3BvaW50ZXJ9IGF0IHNob3VsZCBub3QgYmVnaW4gYWZ0ZXIgaW5zdHJ1Y3Rpb24gc291cmNlIHJhbmdlYFxuICAgICAgICApO1xuICAgICAgICBhc3NlcnQuaXNBdExlYXN0KFxuICAgICAgICAgIG5vZGVFbmQsIGVuZCxcbiAgICAgICAgICBgTm9kZSAke3BvaW50ZXJ9IHNob3VsZCBub3QgZW5kIGFmdGVyIHNvdXJjZWBcbiAgICAgICAgKTtcblxuICAgICAgICBzZXNzaW9uLnN0ZXBOZXh0KCk7XG4gICAgICB9IHdoaWxlKCFzZXNzaW9uLmZpbmlzaGVkKTtcblxuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHRlc3QvYXN0LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInBhdGhcIlxuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJmcy1leHRyYVwiXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJhc3luY1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImFzeW5jXCJcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtd29ya2Zsb3ctY29tcGlsZVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtd29ya2Zsb3ctY29tcGlsZVwiXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0cnVmZmxlLWRlYnVnLXV0aWxzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHJ1ZmZsZS1kZWJ1Zy11dGlsc1wiXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0cnVmZmxlLWFydGlmYWN0b3JcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0cnVmZmxlLWFydGlmYWN0b3JcIlxuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHJ1ZmZsZS1taWdyYXRlXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHJ1ZmZsZS1taWdyYXRlXCJcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtYm94XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHJ1ZmZsZS1ib3hcIlxuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHJ1ZmZsZS1yZXNvbHZlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtcmVzb2x2ZXJcIlxuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNlc3Npb25cIik7XG5cbmltcG9ydCB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCBhc3QgZnJvbSBcImxpYi9hc3Qvc2VsZWN0b3JzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcblxuaW1wb3J0IGNvbmZpZ3VyZVN0b3JlIGZyb20gXCJsaWIvc3RvcmVcIjtcblxuaW1wb3J0ICogYXMgY29udHJvbGxlciBmcm9tIFwibGliL2NvbnRyb2xsZXIvYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5cbmltcG9ydCByb290U2FnYSBmcm9tIFwiLi9zYWdhc1wiO1xuaW1wb3J0IHJlZHVjZXIgZnJvbSBcIi4vcmVkdWNlcnNcIjtcblxuLyoqXG4gKiBEZWJ1Z2dlciBTZXNzaW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlc3Npb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxDb250cmFjdD59IGNvbnRyYWN0cyAtIGNvbnRyYWN0IGRlZmluaXRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gZmlsZXMgLSBhcnJheSBvZiBmaWxlbmFtZXMgZm9yIHNvdXJjZU1hcCBpbmRleGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eEhhc2ggLSB0cmFuc2FjdGlvbiBoYXNoXG4gICAqIEBwYXJhbSB7V2ViM1Byb3ZpZGVyfSBwcm92aWRlciAtIHdlYjMgcHJvdmlkZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRyYWN0cywgZmlsZXMsIHR4SGFzaCwgcHJvdmlkZXIpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3N0b3JlID0gY29uZmlndXJlU3RvcmUocmVkdWNlciwgcm9vdFNhZ2EpO1xuXG4gICAgbGV0IHsgY29udGV4dHMsIHNvdXJjZXMgfSA9IFNlc3Npb24ubm9ybWFsaXplKGNvbnRyYWN0cywgZmlsZXMpO1xuXG4gICAgLy8gcmVjb3JkIGNvbnRyYWN0c1xuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbnMucmVjb3JkQ29udHJhY3RzKGNvbnRleHRzLCBzb3VyY2VzKSk7XG5cbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnN0YXJ0KHR4SGFzaCwgcHJvdmlkZXIpKTtcbiAgfVxuXG4gIHJlYWR5KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSggKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9zdG9yZS5zdWJzY3JpYmUoICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2Vzc2lvbiA9PSBcIkFDVElWRVwiKSB7XG4gICAgICAgICAgYWNjZXB0KClcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5zdGF0ZS5zZXNzaW9uID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICByZWplY3QodGhpcy5zdGF0ZS5zZXNzaW9uLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdXAgYXJ0aWZhY3RzIGludG8gXCJjb250ZXh0c1wiIGFuZCBcInNvdXJjZXNcIiwgZGl2aWRpbmcgYXJ0aWZhY3RcbiAgICogZGF0YSBpbnRvIGFwcHJvcHJpYXRlIGJ1Y2tldHMuXG4gICAqXG4gICAqIE11bHRpcGxlIGNvbnRyYWN0cyBjYW4gYmUgZGVmaW5lZCBpbiB0aGUgc2FtZSBzb3VyY2UgZmlsZSwgYnV0IGhhdmVcbiAgICogZGlmZmVyZW50IGJ5dGVjb2Rlcy5cbiAgICpcbiAgICogVGhpcyBpdGVyYXRlcyBvdmVyIHRoZSBjb250cmFjdHMgYW5kIGNvbGxlY3RzIGJpbmFyaWVzIHNlcGFyYXRlbHlcbiAgICogZnJvbSBzb3VyY2VzLCB1c2luZyB0aGUgb3B0aW9uYWwgYGZpbGVzYCBhcmd1bWVudCB0byBmb3JjZVxuICAgKiBzb3VyY2Ugb3JkZXJpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplKGNvbnRyYWN0cywgZmlsZXMgPSBudWxsKSB7XG4gICAgbGV0IHNvdXJjZXNCeVBhdGggPSB7fTtcbiAgICBsZXQgY29udGV4dHMgPSBbXTtcbiAgICBsZXQgc291cmNlcztcblxuICAgIGZvciAobGV0IGNvbnRyYWN0IG9mIGNvbnRyYWN0cykge1xuICAgICAgbGV0IHtcbiAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICBiaW5hcnksXG4gICAgICAgIHNvdXJjZU1hcCxcbiAgICAgICAgZGVwbG95ZWRCaW5hcnksXG4gICAgICAgIGRlcGxveWVkU291cmNlTWFwLFxuICAgICAgICBzb3VyY2VQYXRoLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGFzdFxuICAgICAgfSA9IGNvbnRyYWN0O1xuXG4gICAgICBzb3VyY2VzQnlQYXRoW3NvdXJjZVBhdGhdID0geyBzb3VyY2VQYXRoLCBzb3VyY2UsIGFzdCB9O1xuXG4gICAgICBpZiAoYmluYXJ5ICYmIGJpbmFyeSAhPSBcIjB4XCIpIHtcbiAgICAgICAgY29udGV4dHMucHVzaCh7XG4gICAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICAgIGJpbmFyeSxcbiAgICAgICAgICBzb3VyY2VNYXBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZXBsb3llZEJpbmFyeSAmJiBkZXBsb3llZEJpbmFyeSAhPSBcIjB4XCIpIHtcbiAgICAgICAgY29udGV4dHMucHVzaCh7XG4gICAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICAgIGJpbmFyeTogZGVwbG95ZWRCaW5hcnksXG4gICAgICAgICAgc291cmNlTWFwOiBkZXBsb3llZFNvdXJjZU1hcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZpbGVzKSB7XG4gICAgICBzb3VyY2VzID0gT2JqZWN0LnZhbHVlcyhzb3VyY2VzQnlQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlcyA9IGZpbGVzLm1hcChmaWxlID0+IHNvdXJjZXNCeVBhdGhbZmlsZV0pO1xuICAgIH1cblxuICAgIHJldHVybiB7IGNvbnRleHRzLCBzb3VyY2VzIH07XG4gIH1cblxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLmdldFN0YXRlKCk7XG4gIH1cblxuICB2aWV3KHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yKHRoaXMuc3RhdGUpO1xuICB9XG5cbiAgZ2V0IGZpbmlzaGVkKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnNlc3Npb24gPT0gXCJGSU5JU0hFRFwiO1xuICB9XG5cbiAgZ2V0IGZhaWxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hlZCAmJiB0aGlzLnZpZXcoZXZtLmN1cnJlbnQuY2FsbHN0YWNrKS5sZW5ndGhcbiAgfVxuXG4gIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICh0aGlzLmZpbmlzaGVkKSB7XG4gICAgICBkZWJ1ZyhcImZpbmlzaGVkOiBpbnRlcmNlcHRpbmcgYWN0aW9uICVvXCIsIGFjdGlvbik7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb24pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbnRlcnJ1cHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5pbnRlcnJ1cHQoKSk7XG4gIH1cblxuICBhZHZhbmNlKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuYWR2YW5jZSgpKTtcbiAgfVxuXG4gIHN0ZXBOZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuc3RlcE5leHQoKSk7XG4gIH1cblxuICBzdGVwT3ZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChjb250cm9sbGVyLnN0ZXBPdmVyKCkpO1xuICB9XG5cbiAgc3RlcEludG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5zdGVwSW50bygpKTtcbiAgfVxuXG4gIHN0ZXBPdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5zdGVwT3V0KCkpO1xuICB9XG5cbiAgY29udGludWVVbnRpbCguLi5icmVha3BvaW50cykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuY29udGludWVVbnRpbCguLi5icmVha3BvaW50cykpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3Nlc3Npb24vaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3ZhbHVlc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvdmFsdWVzXCJcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtc29saWRpdHktdXRpbHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0cnVmZmxlLXNvbGlkaXR5LXV0aWxzXCJcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtY29kZS11dGlsc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtY29kZS11dGlsc1wiXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuLy8gQW4gYXVnbWVudGVkIEFWTCBUcmVlIHdoZXJlIGVhY2ggbm9kZSBtYWludGFpbnMgYSBsaXN0IG9mIHJlY29yZHMgYW5kIHRoZWlyIHNlYXJjaCBpbnRlcnZhbHMuXHJcbi8vIFJlY29yZCBpcyBjb21wb3NlZCBvZiBhbiBpbnRlcnZhbCBhbmQgaXRzIHVuZGVybHlpbmcgZGF0YSwgc2VudCBieSBhIGNsaWVudC4gVGhpcyBhbGxvd3MgdGhlXHJcbi8vIGludGVydmFsIHRyZWUgdG8gaGF2ZSB0aGUgc2FtZSBpbnRlcnZhbCBpbnNlcnRlZCBtdWx0aXBsZSB0aW1lcywgYXMgbG9uZyBpdHMgZGF0YSBpcyBkaWZmZXJlbnQuXHJcbi8vIEJvdGggaW5zZXJ0aW9uIGFuZCBkZWxldGlvbiByZXF1aXJlIE8obG9nIG4pIHRpbWUuIFNlYXJjaGluZyByZXF1aXJlcyBPKGsqbG9nbikgdGltZSwgd2hlcmUgYGtgXHJcbi8vIGlzIHRoZSBudW1iZXIgb2YgaW50ZXJ2YWxzIGluIHRoZSBvdXRwdXQgbGlzdC5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgaXNTYW1lID0gcmVxdWlyZShcInNoYWxsb3dlcXVhbFwiKTtcclxuZnVuY3Rpb24gaGVpZ2h0KG5vZGUpIHtcclxuICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbm9kZS5oZWlnaHQ7XHJcbiAgICB9XHJcbn1cclxudmFyIE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb2RlKGludGVydmFsVHJlZSwgcmVjb3JkKSB7XHJcbiAgICAgICAgdGhpcy5pbnRlcnZhbFRyZWUgPSBpbnRlcnZhbFRyZWU7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRzID0gW107XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMua2V5ID0gcmVjb3JkLmxvdztcclxuICAgICAgICB0aGlzLm1heCA9IHJlY29yZC5oaWdoO1xyXG4gICAgICAgIC8vIFNhdmUgdGhlIGFycmF5IG9mIGFsbCByZWNvcmRzIHdpdGggdGhlIHNhbWUga2V5IGZvciB0aGlzIG5vZGVcclxuICAgICAgICB0aGlzLnJlY29yZHMucHVzaChyZWNvcmQpO1xyXG4gICAgfVxyXG4gICAgLy8gR2V0cyB0aGUgaGlnaGVzdCByZWNvcmQuaGlnaCB2YWx1ZSBmb3IgdGhpcyBub2RlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5nZXROb2RlSGlnaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaGlnaCA9IHRoaXMucmVjb3Jkc1swXS5oaWdoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5yZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY29yZHNbaV0uaGlnaCA+IGhpZ2gpIHtcclxuICAgICAgICAgICAgICAgIGhpZ2ggPSB0aGlzLnJlY29yZHNbaV0uaGlnaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGlnaDtcclxuICAgIH07XHJcbiAgICAvLyBVcGRhdGVzIGhlaWdodCB2YWx1ZSBvZiB0aGUgbm9kZS4gQ2FsbGVkIGR1cmluZyBpbnNlcnRpb24sIHJlYmFsYW5jZSwgcmVtb3ZhbFxyXG4gICAgTm9kZS5wcm90b3R5cGUudXBkYXRlSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0KHRoaXMubGVmdCksIGhlaWdodCh0aGlzLnJpZ2h0KSkgKyAxO1xyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgdGhlIG1heCB2YWx1ZSBvZiBhbGwgdGhlIHBhcmVudHMgYWZ0ZXIgaW5zZXJ0aW5nIGludG8gYWxyZWFkeSBleGlzdGluZyBub2RlLCBhcyB3ZWxsIGFzXHJcbiAgICAvLyByZW1vdmluZyB0aGUgbm9kZSBjb21wbGV0ZWx5IG9yIHJlbW92aW5nIHRoZSByZWNvcmQgb2YgYW4gYWxyZWFkeSBleGlzdGluZyBub2RlLiBTdGFydHMgd2l0aFxyXG4gICAgLy8gdGhlIHBhcmVudCBvZiBhbiBhZmZlY3RlZCBub2RlIGFuZCBidWJibGVzIHVwIHRvIHJvb3RcclxuICAgIE5vZGUucHJvdG90eXBlLnVwZGF0ZU1heE9mUGFyZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRoaXNIaWdoID0gdGhpcy5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heChNYXRoLm1heCh0aGlzLmxlZnQubWF4LCB0aGlzLnJpZ2h0Lm1heCksIHRoaXNIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5sZWZ0Lm1heCwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLnJpZ2h0Lm1heCwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzSGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgTGVmdC1MZWZ0IGNhc2U6XHJcbiAgXHJcbiAgICAgICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeVxyXG4gICAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgIFxcXHJcbiAgICAgICAgIHkgICBUNCAgICAgIFJpZ2h0IFJvdGF0ZSAoeikgICAgICAgICAgeCAgICAgelxyXG4gICAgICAgIC8gXFwgICAgICAgICAgLSAtIC0gLSAtIC0gLSAtIC0+ICAgICAgIC8gXFwgICAvIFxcXHJcbiAgICAgICB4ICAgVDMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFQxIFQyIFQzIFQ0XHJcbiAgICAgIC8gXFxcclxuICAgIFQxICAgVDJcclxuICBcclxuICAgIExlZnQtUmlnaHQgY2FzZTpcclxuICBcclxuICAgICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgeFxyXG4gICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAvICAgXFxcclxuICAgICAgIHkgICBUNCAgTGVmdCBSb3RhdGUgKHkpICAgICAgICAgeCAgVDQgIFJpZ2h0IFJvdGF0ZSh6KSAgICAgeSAgICAgelxyXG4gICAgICAvIFxcICAgICAgLSAtIC0gLSAtIC0gLSAtIC0+ICAgICAvIFxcICAgICAgLSAtIC0gLSAtIC0gLSAtPiAgLyBcXCAgIC8gXFxcclxuICAgIFQxICAgeCAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgIFQzICAgICAgICAgICAgICAgICAgICAgIFQxIFQyIFQzIFQ0XHJcbiAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAvIFxcXHJcbiAgICAgIFQyICAgVDMgICAgICAgICAgICAgICAgICAgICAgVDEgVDJcclxuICAgICovXHJcbiAgICAvLyBIYW5kbGVzIExlZnQtTGVmdCBjYXNlIGFuZCBMZWZ0LVJpZ2h0IGNhc2UgYWZ0ZXIgcmViYWxhbmNpbmcgQVZMIHRyZWVcclxuICAgIE5vZGUucHJvdG90eXBlLl91cGRhdGVNYXhBZnRlclJpZ2h0Um90YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB2YXIgbGVmdCA9IHBhcmVudC5sZWZ0O1xyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgbGVmdCBzaWJsaW5nICh4IGluIGZpcnN0IGNhc2UsIHkgaW4gc2Vjb25kKVxyXG4gICAgICAgIHZhciB0aGlzUGFyZW50TGVmdEhpZ2ggPSBsZWZ0LmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKGxlZnQubGVmdCA9PT0gdW5kZWZpbmVkICYmIGxlZnQucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IE1hdGgubWF4KHRoaXNQYXJlbnRMZWZ0SGlnaCwgbGVmdC5yaWdodC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsZWZ0LmxlZnQgIT09IHVuZGVmaW5lZCAmJiBsZWZ0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVmdC5tYXggPSBNYXRoLm1heCh0aGlzUGFyZW50TGVmdEhpZ2gsIGxlZnQubGVmdC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsZWZ0LmxlZnQgPT09IHVuZGVmaW5lZCAmJiBsZWZ0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVmdC5tYXggPSB0aGlzUGFyZW50TGVmdEhpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IE1hdGgubWF4KE1hdGgubWF4KGxlZnQubGVmdC5tYXgsIGxlZnQucmlnaHQubWF4KSwgdGhpc1BhcmVudExlZnRIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBpdHNlbGYgKHopXHJcbiAgICAgICAgdmFyIHRoaXNIaWdoID0gdGhpcy5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzSGlnaCwgdGhpcy5yaWdodC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzSGlnaCwgdGhpcy5sZWZ0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHRoaXNIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heChNYXRoLm1heCh0aGlzLmxlZnQubWF4LCB0aGlzLnJpZ2h0Lm1heCksIHRoaXNIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBwYXJlbnQgKHkgaW4gZmlyc3QgY2FzZSwgeCBpbiBzZWNvbmQpXHJcbiAgICAgICAgcGFyZW50Lm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHBhcmVudC5sZWZ0Lm1heCwgcGFyZW50LnJpZ2h0Lm1heCksIHBhcmVudC5nZXROb2RlSGlnaCgpKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgUmlnaHQtUmlnaHQgY2FzZTpcclxuICBcclxuICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5XHJcbiAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgXFxcclxuICAgIFQxICB5ICAgICBMZWZ0IFJvdGF0ZSh6KSAgICAgICB6ICAgICB4XHJcbiAgICAgICAvIFxcICAgLSAtIC0gLSAtIC0gLSAtPiAgICAgLyBcXCAgIC8gXFxcclxuICAgICAgVDIgIHggICAgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgICAgLyBcXFxyXG4gICAgICAgIFQzIFQ0XHJcbiAgXHJcbiAgICBSaWdodC1MZWZ0IGNhc2U6XHJcbiAgXHJcbiAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICAgeFxyXG4gICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgIC8gICBcXFxyXG4gICAgIFQxICB5ICAgUmlnaHQgUm90YXRlICh5KSAgICAgVDEgIHggICAgICBMZWZ0IFJvdGF0ZSh6KSAgIHogICAgIHlcclxuICAgICAgICAvIFxcICAtIC0gLSAtIC0gLSAtIC0gLT4gICAgICAvIFxcICAgLSAtIC0gLSAtIC0gLSAtPiAgLyBcXCAgIC8gXFxcclxuICAgICAgIHggIFQ0ICAgICAgICAgICAgICAgICAgICAgICAgVDIgIHkgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFxcclxuICAgIFQyICAgVDMgICAgICAgICAgICAgICAgICAgICAgICAgICBUMyBUNFxyXG4gICAgKi9cclxuICAgIC8vIEhhbmRsZXMgUmlnaHQtUmlnaHQgY2FzZSBhbmQgUmlnaHQtTGVmdCBjYXNlIGluIHJlYmFsYW5jaW5nIEFWTCB0cmVlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5fdXBkYXRlTWF4QWZ0ZXJMZWZ0Um90YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB2YXIgcmlnaHQgPSBwYXJlbnQucmlnaHQ7XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiByaWdodCBzaWJsaW5nICh4IGluIGZpcnN0IGNhc2UsIHkgaW4gc2Vjb25kKVxyXG4gICAgICAgIHZhciB0aGlzUGFyZW50UmlnaHRIaWdoID0gcmlnaHQuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAocmlnaHQubGVmdCA9PT0gdW5kZWZpbmVkICYmIHJpZ2h0LnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmlnaHQubWF4ID0gTWF0aC5tYXgodGhpc1BhcmVudFJpZ2h0SGlnaCwgcmlnaHQucmlnaHQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmlnaHQubGVmdCAhPT0gdW5kZWZpbmVkICYmIHJpZ2h0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmlnaHQubWF4ID0gTWF0aC5tYXgodGhpc1BhcmVudFJpZ2h0SGlnaCwgcmlnaHQubGVmdC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyaWdodC5sZWZ0ID09PSB1bmRlZmluZWQgJiYgcmlnaHQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSB0aGlzUGFyZW50UmlnaHRIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmlnaHQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgocmlnaHQubGVmdC5tYXgsIHJpZ2h0LnJpZ2h0Lm1heCksIHRoaXNQYXJlbnRSaWdodEhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIGl0c2VsZiAoeilcclxuICAgICAgICB2YXIgdGhpc0hpZ2ggPSB0aGlzLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLnJpZ2h0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLmxlZnQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gdGhpc0hpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHRoaXMubGVmdC5tYXgsIHRoaXMucmlnaHQubWF4KSwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHBhcmVudCAoeSBpbiBmaXJzdCBjYXNlLCB4IGluIHNlY29uZClcclxuICAgICAgICBwYXJlbnQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgocGFyZW50LmxlZnQubWF4LCByaWdodC5tYXgpLCBwYXJlbnQuZ2V0Tm9kZUhpZ2goKSk7XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUuX2xlZnRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJpZ2h0Q2hpbGQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgIHJpZ2h0Q2hpbGQucGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHJpZ2h0Q2hpbGQucGFyZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbFRyZWUucm9vdCA9IHJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocmlnaHRDaGlsZC5wYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRDaGlsZC5wYXJlbnQubGVmdCA9IHJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRDaGlsZC5wYXJlbnQucmlnaHQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0Q2hpbGQucGFyZW50LnJpZ2h0ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHRDaGlsZC5sZWZ0O1xyXG4gICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yaWdodC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByaWdodENoaWxkLmxlZnQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgIHJpZ2h0Q2hpbGQudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUuX3JpZ2h0Um90YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsZWZ0Q2hpbGQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgbGVmdENoaWxkLnBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmIChsZWZ0Q2hpbGQucGFyZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbFRyZWUucm9vdCA9IGxlZnRDaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0Q2hpbGQucGFyZW50LmxlZnQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRDaGlsZC5wYXJlbnQubGVmdCA9IGxlZnRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsZWZ0Q2hpbGQucGFyZW50LnJpZ2h0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0Q2hpbGQucGFyZW50LnJpZ2h0ID0gbGVmdENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnRDaGlsZC5yaWdodDtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxlZnRDaGlsZC5yaWdodCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBsZWZ0Q2hpbGQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICBsZWZ0Q2hpbGQudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmViYWxhbmNlcyB0aGUgdHJlZSBpZiB0aGUgaGVpZ2h0IHZhbHVlIGJldHdlZW4gdHdvIG5vZGVzIG9mIHRoZSBzYW1lIHBhcmVudCBpcyBncmVhdGVyIHRoYW5cclxuICAgIC8vIHR3by4gVGhlcmUgYXJlIDQgY2FzZXMgdGhhdCBjYW4gaGFwcGVuIHdoaWNoIGFyZSBvdXRsaW5lZCBpbiB0aGUgZ3JhcGhpY3MgYWJvdmVcclxuICAgIE5vZGUucHJvdG90eXBlLl9yZWJhbGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGhlaWdodCh0aGlzLmxlZnQpID49IDIgKyBoZWlnaHQodGhpcy5yaWdodCkpIHtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgIGlmIChoZWlnaHQobGVmdC5sZWZ0KSA+PSBoZWlnaHQobGVmdC5yaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIExlZnQtTGVmdCBjYXNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTWF4QWZ0ZXJSaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTGVmdC1SaWdodCBjYXNlXHJcbiAgICAgICAgICAgICAgICBsZWZ0Ll9sZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTWF4QWZ0ZXJSaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhlaWdodCh0aGlzLnJpZ2h0KSA+PSAyICsgaGVpZ2h0KHRoaXMubGVmdCkpIHtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgaWYgKGhlaWdodChyaWdodC5yaWdodCkgPj0gaGVpZ2h0KHJpZ2h0LmxlZnQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSaWdodC1SaWdodCBjYXNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlckxlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFJpZ2h0LUxlZnQgY2FzZVxyXG4gICAgICAgICAgICAgICAgcmlnaHQuX3JpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlckxlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgaWYgKHJlY29yZC5sb3cgPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICAvLyBJbnNlcnQgaW50byBsZWZ0IHN1YnRyZWVcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQgPSBuZXcgTm9kZSh0aGlzLmludGVydmFsVHJlZSwgcmVjb3JkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0Lmluc2VydChyZWNvcmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJbnNlcnQgaW50byByaWdodCBzdWJ0cmVlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQgPSBuZXcgTm9kZSh0aGlzLmludGVydmFsVHJlZSwgcmVjb3JkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuaW5zZXJ0KHJlY29yZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBtYXggdmFsdWUgb2YgdGhpcyBhbmNlc3RvciBpZiBuZWVkZWRcclxuICAgICAgICBpZiAodGhpcy5tYXggPCByZWNvcmQuaGlnaCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHJlY29yZC5oaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgaGVpZ2h0IG9mIGVhY2ggbm9kZVxyXG4gICAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgLy8gUmViYWxhbmNlIHRoZSB0cmVlIHRvIGVuc3VyZSBhbGwgb3BlcmF0aW9ucyBhcmUgZXhlY3V0ZWQgaW4gTyhsb2duKSB0aW1lLiBUaGlzIGlzIGVzcGVjaWFsbHlcclxuICAgICAgICAvLyBpbXBvcnRhbnQgaW4gc2VhcmNoaW5nLCBhcyB0aGUgdHJlZSBoYXMgYSBoaWdoIGNoYW5jZSBvZiBkZWdlbmVyYXRpbmcgd2l0aG91dCB0aGUgcmViYWxhbmNpbmdcclxuICAgICAgICB0aGlzLl9yZWJhbGFuY2UoKTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5fZ2V0T3ZlcmxhcHBpbmdSZWNvcmRzID0gZnVuY3Rpb24gKGN1cnJlbnROb2RlLCBsb3csIGhpZ2gpIHtcclxuICAgICAgICBpZiAoY3VycmVudE5vZGUua2V5IDw9IGhpZ2ggJiYgbG93IDw9IGN1cnJlbnROb2RlLmdldE5vZGVIaWdoKCkpIHtcclxuICAgICAgICAgICAgLy8gTm9kZXMgYXJlIG92ZXJsYXBwaW5nLCBjaGVjayBpZiBpbmRpdmlkdWFsIHJlY29yZHMgaW4gdGhlIG5vZGUgYXJlIG92ZXJsYXBwaW5nXHJcbiAgICAgICAgICAgIHZhciB0ZW1wUmVzdWx0cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnROb2RlLnJlY29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5yZWNvcmRzW2ldLmhpZ2ggPj0gbG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFJlc3VsdHMucHVzaChjdXJyZW50Tm9kZS5yZWNvcmRzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGVtcFJlc3VsdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgLy8gRG9uJ3Qgc2VhcmNoIG5vZGVzIHRoYXQgZG9uJ3QgZXhpc3RcclxuICAgICAgICBpZiAodGhpcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxlZnRTZWFyY2ggPSBbXTtcclxuICAgICAgICB2YXIgb3duU2VhcmNoID0gW107XHJcbiAgICAgICAgdmFyIHJpZ2h0U2VhcmNoID0gW107XHJcbiAgICAgICAgLy8gSWYgaW50ZXJ2YWwgaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgcG9pbnQgb2YgYW55IGludGVydmFsIGluIHRoaXMgbm9kZSBhbmQgYWxsIGl0c1xyXG4gICAgICAgIC8vIGNoaWxkcmVuLCB0aGVyZSB3b24ndCBiZSBhbnkgbWF0Y2hlc1xyXG4gICAgICAgIGlmIChsb3cgPiB0aGlzLm1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNlYXJjaCBsZWZ0IGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGVmdC5tYXggPj0gbG93KSB7XHJcbiAgICAgICAgICAgIGxlZnRTZWFyY2ggPSB0aGlzLmxlZnQuc2VhcmNoKGxvdywgaGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIHRoaXMgbm9kZVxyXG4gICAgICAgIG93blNlYXJjaCA9IHRoaXMuX2dldE92ZXJsYXBwaW5nUmVjb3Jkcyh0aGlzLCBsb3csIGhpZ2gpO1xyXG4gICAgICAgIC8vIElmIGludGVydmFsIGlzIHRvIHRoZSBsZWZ0IG9mIHRoZSBzdGFydCBvZiB0aGlzIGludGVydmFsLCB0aGVuIGl0IGNhbid0IGJlIGluIGFueSBjaGlsZCB0b1xyXG4gICAgICAgIC8vIHRoZSByaWdodFxyXG4gICAgICAgIGlmIChoaWdoIDwgdGhpcy5rZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnRTZWFyY2guY29uY2F0KG93blNlYXJjaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2VhcmNoIHJpZ2h0IGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodFNlYXJjaCA9IHRoaXMucmlnaHQuc2VhcmNoKGxvdywgaGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJldHVybiBhY2N1bXVsYXRlZCByZXN1bHRzLCBpZiBhbnlcclxuICAgICAgICByZXR1cm4gbGVmdFNlYXJjaC5jb25jYXQob3duU2VhcmNoLCByaWdodFNlYXJjaCk7XHJcbiAgICB9O1xyXG4gICAgLy8gU2VhcmNoZXMgZm9yIGEgbm9kZSBieSBhIGBrZXlgIHZhbHVlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5zZWFyY2hFeGlzdGluZyA9IGZ1bmN0aW9uIChsb3cpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmtleSA9PT0gbG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsb3cgPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuc2VhcmNoRXhpc3RpbmcobG93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuc2VhcmNoRXhpc3RpbmcobG93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgdGhlIHNtYWxsZXN0IG5vZGUgb2YgdGhlIHN1YnRyZWVcclxuICAgIE5vZGUucHJvdG90eXBlLl9taW5WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0Ll9taW5WYWx1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAobm9kZS5rZXkgPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICAvLyBOb2RlIHRvIGJlIHJlbW92ZWQgaXMgb24gdGhlIGxlZnQgc2lkZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLmtleSA+IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIC8vIE5vZGUgdG8gYmUgcmVtb3ZlZCBpcyBvbiB0aGUgcmlnaHQgc2lkZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIGhhcyB0d28gY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIHZhciBtaW5WYWx1ZSA9IHRoaXMucmlnaHQuX21pblZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtleSA9IG1pblZhbHVlLmtleTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkcyA9IG1pblZhbHVlLnJlY29yZHM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5yZW1vdmUodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50LmxlZnQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9uZSBjaGlsZCBvciBubyBjaGlsZCBjYXNlIG9uIGxlZnQgc2lkZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gdGhpcy5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5fcmViYWxhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnQucmlnaHQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9uZSBjaGlsZCBvciBubyBjaGlsZCBjYXNlIG9uIHJpZ2h0IHNpZGVcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gdGhpcy5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5fcmViYWxhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTm9kZTtcclxufSgpKTtcclxuZXhwb3J0cy5Ob2RlID0gTm9kZTtcclxudmFyIEludGVydmFsVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEludGVydmFsVHJlZSgpIHtcclxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgIH1cclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIGlmIChyZWNvcmQubG93ID4gcmVjb3JkLmhpZ2gpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgbG93YCB2YWx1ZSBtdXN0IGJlIGxvd2VyIG9yIGVxdWFsIHRvIGBoaWdoYCB2YWx1ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gQmFzZSBjYXNlOiBUcmVlIGlzIGVtcHR5LCBuZXcgbm9kZSBiZWNvbWVzIHJvb3RcclxuICAgICAgICAgICAgdGhpcy5yb290ID0gbmV3IE5vZGUodGhpcywgcmVjb3JkKTtcclxuICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgY2hlY2sgaWYgbm9kZSBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoZSBzYW1lIGtleVxyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucm9vdC5zZWFyY2hFeGlzdGluZyhyZWNvcmQubG93KTtcclxuICAgICAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJlY29yZHMgaW4gdGhpcyBub2RlIGlmIHRoZXJlIGFscmVhZHkgaXMgdGhlIG9uZSB3aXRoIHNhbWUgbG93LCBoaWdoLCBkYXRhXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucmVjb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWUobm9kZS5yZWNvcmRzW2ldLCByZWNvcmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVjb3JkIGlzIHNhbWUgYXMgdGhlIG9uZSB3ZSdyZSB0cnlpbmcgdG8gaW5zZXJ0OyByZXR1cm4gZmFsc2UgdG8gaW5kaWNhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZyBoYXMgYmVlbiBpbnNlcnRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSByZWNvcmQgdG8gdGhlIG5vZGVcclxuICAgICAgICAgICAgICAgIG5vZGUucmVjb3Jkcy5wdXNoKHJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHRoZSBub2RlIGFuZCBpdHMgcGFyZW50cyBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuaGlnaCA+IG5vZGUubWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSByZWNvcmQuaGlnaDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQudXBkYXRlTWF4T2ZQYXJlbnRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHdpdGggdGhpcyBrZXkgZG9lc24ndCBhbHJlYWR5IGV4aXN0LiBDYWxsIGluc2VydCBmdW5jdGlvbiBvbiByb290J3Mgbm9kZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290Lmluc2VydChyZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFRyZWUgaXMgZW1wdHk7IHJldHVybiBlbXB0eSBhcnJheVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LnNlYXJjaChsb3csIGhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gVHJlZSBpcyBlbXB0eTsgbm90aGluZyB0byByZW1vdmVcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnJvb3Quc2VhcmNoRXhpc3RpbmcocmVjb3JkLmxvdyk7XHJcbiAgICAgICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnJlY29yZHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRSZWNvcmQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHdpdGggdGhpcyBrZXkgaGFzIDIgb3IgbW9yZSByZWNvcmRzLiBGaW5kIHRoZSBvbmUgd2UgbmVlZCBhbmQgcmVtb3ZlIGl0XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucmVjb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWUobm9kZS5yZWNvcmRzW2ldLCByZWNvcmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWRSZWNvcmQgPSBub2RlLnJlY29yZHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVjb3Jkcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkUmVjb3JkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFJlY29yZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHRoYXQgbm9kZSBhbmQgaXRzIHBhcmVudHMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5oaWdoID09PSBub2RlLm1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUhpZ2ggPSBub2RlLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlZnQgIT09IHVuZGVmaW5lZCAmJiBub2RlLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgobm9kZS5sZWZ0Lm1heCwgbm9kZS5yaWdodC5tYXgpLCBub2RlSGlnaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgbm9kZS5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1heCA9IE1hdGgubWF4KG5vZGUubGVmdC5tYXgsIG5vZGVIaWdoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmxlZnQgPT09IHVuZGVmaW5lZCAmJiBub2RlLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gTWF0aC5tYXgobm9kZS5yaWdodC5tYXgsIG5vZGVIaWdoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gbm9kZUhpZ2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5yZWNvcmRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9kZSB3aXRoIHRoaXMga2V5IGhhcyBvbmx5IDEgcmVjb3JkLiBDaGVjayBpZiB0aGUgcmVtYWluaW5nIHJlY29yZCBpbiB0aGlzIG5vZGUgaXNcclxuICAgICAgICAgICAgICAgIC8vIGFjdHVhbGx5IHRoZSBvbmUgd2Ugd2FudCB0byByZW1vdmVcclxuICAgICAgICAgICAgICAgIGlmIChpc1NhbWUobm9kZS5yZWNvcmRzWzBdLCByZWNvcmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyByZWNvcmQgaXMgdGhlIG9uZSB3ZSB3YW50IHRvIHJlbW92ZS4gUmVtb3ZlIHRoZSB3aG9sZSBub2RlIGZyb20gdGhlIHRyZWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yb290LmtleSA9PT0gbm9kZS5rZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgcmVtb3ZpbmcgdGhlIHJvb3QgZWxlbWVudC4gQ3JlYXRlIGEgZHVtbXkgbm9kZSB0aGF0IHdpbGwgdGVtcG9yYXJpbHkgdGFrZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByb290J3MgcGFyZW50IHJvbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RQYXJlbnQgPSBuZXcgTm9kZSh0aGlzLCB7IGxvdzogcmVjb3JkLmxvdywgaGlnaDogcmVjb3JkLmxvdyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFBhcmVudC5sZWZ0ID0gdGhpcy5yb290O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QucGFyZW50ID0gcm9vdFBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZWROb2RlID0gdGhpcy5yb290LnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gcm9vdFBhcmVudC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yb290ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdC5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZWROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkTm9kZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZE5vZGUgPSB0aGlzLnJvb3QucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWROb2RlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIHJlY29yZCBpcyBub3QgdGhlIG9uZSB3ZSB3YW50IHRvIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIHJlY29yZHMgYXQgYWxsIGluIHRoaXMgbm9kZT8hIFNob3VsZG4ndCBoYXBwZW5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLmluT3JkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbk9yZGVyKHRoaXMucm9vdCk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5wcmVPcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZU9yZGVyKHRoaXMucm9vdCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEludGVydmFsVHJlZTtcclxufSgpKTtcclxuZXhwb3J0cy5JbnRlcnZhbFRyZWUgPSBJbnRlcnZhbFRyZWU7XHJcbnZhciBEYXRhSW50ZXJ2YWxUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGF0YUludGVydmFsVHJlZSgpIHtcclxuICAgICAgICB0aGlzLnRyZWUgPSBuZXcgSW50ZXJ2YWxUcmVlKCk7XHJcbiAgICB9XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAobG93LCBoaWdoLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5pbnNlcnQoeyBsb3c6IGxvdywgaGlnaDogaGlnaCwgZGF0YTogZGF0YSB9KTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobG93LCBoaWdoLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5yZW1vdmUoeyBsb3c6IGxvdywgaGlnaDogaGlnaCwgZGF0YTogZGF0YSB9KTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5zZWFyY2gobG93LCBoaWdoKS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuZGF0YTsgfSk7XHJcbiAgICB9O1xyXG4gICAgRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUuaW5PcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLmluT3JkZXIoKTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5wcmVPcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnByZU9yZGVyKCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLCBcImNvdW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5jb3VudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBEYXRhSW50ZXJ2YWxUcmVlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXRhSW50ZXJ2YWxUcmVlO1xyXG52YXIgSW5PcmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEluT3JkZXIoc3RhcnROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xyXG4gICAgICAgIGlmIChzdGFydE5vZGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2goc3RhcnROb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBJbk9yZGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFdpbGwgb25seSBoYXBwZW4gaWYgc3RhY2sgaXMgZW1wdHkgYW5kIHBvcCBpcyBjYWxsZWRcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJvY2VzcyB0aGlzIG5vZGVcclxuICAgICAgICBpZiAodGhpcy5pIDwgdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzW3RoaXMuaSsrXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5jdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNaWdodCBwb3AgdGhlIGxhc3QgYW5kIHNldCB0aGlzLmN1cnJlbnROb2RlID0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIHRoaXMucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHQoKTtcclxuICAgIH07XHJcbiAgICBJbk9yZGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLmkgPSAwO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmN1cnJlbnROb2RlLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5jdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSB0aGlzLmN1cnJlbnROb2RlLmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEluT3JkZXIucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gdGhpcy5zdGFjay5wb3AoKTtcclxuICAgICAgICB0aGlzLmkgPSAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJbk9yZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLkluT3JkZXIgPSBJbk9yZGVyO1xyXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgSW5PcmRlci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XHJcbn1cclxudmFyIFByZU9yZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJlT3JkZXIoc3RhcnROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHN0YXJ0Tm9kZTtcclxuICAgIH1cclxuICAgIFByZU9yZGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFdpbGwgb25seSBoYXBwZW4gaWYgc3RhY2sgaXMgZW1wdHkgYW5kIHBvcCBpcyBjYWxsZWQsXHJcbiAgICAgICAgLy8gd2hpY2ggb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHJpZ2h0IG5vZGUgKGkuZSB3ZSBhcmUgZG9uZSlcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJvY2VzcyB0aGlzIG5vZGVcclxuICAgICAgICBpZiAodGhpcy5pIDwgdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzW3RoaXMuaSsrXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5jdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5jdXJyZW50Tm9kZS5sZWZ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wb3AoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0KCk7XHJcbiAgICB9O1xyXG4gICAgUHJlT3JkZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHRoaXMuc3RhY2sucHVzaChub2RlKTtcclxuICAgIH07XHJcbiAgICBQcmVPcmRlci5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByZU9yZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLlByZU9yZGVyID0gUHJlT3JkZXI7XHJcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBQcmVPcmRlci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9ub2RlLWludGVydmFsLXRyZWUvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCLCBjb21wYXJlLCBjb21wYXJlQ29udGV4dCkge1xuICB2YXIgcmV0ID0gY29tcGFyZSA/IGNvbXBhcmUuY2FsbChjb21wYXJlQ29udGV4dCwgb2JqQSwgb2JqQikgOiB2b2lkIDA7XG5cbiAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuICEhcmV0O1xuICB9XG5cbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCAhb2JqQSB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCAhb2JqQikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYkhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5iaW5kKG9iakIpO1xuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGtleXNBLmxlbmd0aDsgaWR4KyspIHtcbiAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcblxuICAgIGlmICghYkhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVBID0gb2JqQVtrZXldO1xuICAgIHZhciB2YWx1ZUIgPSBvYmpCW2tleV07XG5cbiAgICByZXQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCB2YWx1ZUEsIHZhbHVlQiwga2V5KSA6IHZvaWQgMDtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlIHx8IChyZXQgPT09IHZvaWQgMCAmJiB2YWx1ZUEgIT09IHZhbHVlQikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL3NoYWxsb3dlcXVhbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcHJvZHVjdGlvblwiKTtcbn0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT0gXCJ0ZXN0XCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi90ZXN0XCIpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9kZXZlbG9wbWVudFwiKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc3RvcmUvaW5kZXguanMiLCJpbXBvcnQgY29uZmlndXJlU3RvcmUgZnJvbSBcIi4vY29tbW9uXCI7XG5leHBvcnQgZGVmYXVsdCBjb25maWd1cmVTdG9yZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc3RvcmUvdGVzdC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpzdG9yZTpjb21tb25cIik7XG5jb25zdCByZWR1eERlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpyZWR1eFwiKTtcblxuaW1wb3J0IHsgY29tcG9zZSwgY3JlYXRlU3RvcmUsIGFwcGx5TWlkZGxld2FyZSB9IGZyb20gXCJyZWR1eFwiO1xuaW1wb3J0IGNyZWF0ZVNhZ2FNaWRkbGV3YXJlIGZyb20gXCJyZWR1eC1zYWdhXCI7XG5pbXBvcnQgY3JlYXRlTG9nZ2VyIGZyb20gXCJyZWR1eC1jbGktbG9nZ2VyXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBhYmJyZXZpYXRlVmFsdWVzKHZhbHVlLCBvcHRpb25zID0ge30sIGRlcHRoID0gMCkge1xuICBvcHRpb25zLnN0cmluZ0xpbWl0ID0gb3B0aW9ucy5zdHJpbmdMaW1pdCB8fCA2NjtcbiAgb3B0aW9ucy5hcnJheUxpbWl0ID0gb3B0aW9ucy5hcnJheUxpbWl0IHx8IDg7XG4gIG9wdGlvbnMucmVjdXJzZUxpbWl0ID0gb3B0aW9ucy5yZWN1cnNlTGltaXQgfHwgNDtcblxuICBpZiAoZGVwdGggPiBvcHRpb25zLnJlY3Vyc2VMaW1pdCkge1xuICAgIHJldHVybiBcIi4uLlwiO1xuICB9XG5cbiAgY29uc3QgcmVjdXJzZSA9IChjaGlsZCkgPT4gYWJicmV2aWF0ZVZhbHVlcyhjaGlsZCwgb3B0aW9ucywgZGVwdGggKyAxKTtcblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPiBvcHRpb25zLmFycmF5TGltaXQpIHtcbiAgICAgIHZhbHVlID0gW1xuICAgICAgICAuLi52YWx1ZS5zbGljZSgwLCBvcHRpb25zLmFycmF5TGltaXQgLyAyKSxcbiAgICAgICAgXCIuLi5cIixcbiAgICAgICAgLi4udmFsdWUuc2xpY2UodmFsdWUubGVuZ3RoIC0gb3B0aW9ucy5hcnJheUxpbWl0IC8gMiArIDEpXG4gICAgICBdO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS5tYXAocmVjdXJzZSk7XG5cbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgLi4uT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcChcbiAgICAgICAgKFtrLCB2XSkgPT4gKHsgW3JlY3Vyc2UoayldOiByZWN1cnNlKHYpIH0pXG4gICAgICApXG4gICAgKTtcblxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5sZW5ndGggPiBvcHRpb25zLnN0cmluZ0xpbWl0KSB7XG4gICAgbGV0IGlubmVyID0gXCIuLi5cIjtcbiAgICBsZXQgZXh0cmFjdEFtb3VudCA9IChvcHRpb25zLnN0cmluZ0xpbWl0IC0gaW5uZXIubGVuZ3RoKSAvIDI7XG4gICAgbGV0IGxlYWRpbmcgPSB2YWx1ZS5zbGljZSgwLCBNYXRoLmNlaWwoZXh0cmFjdEFtb3VudCkpO1xuICAgIGxldCB0cmFpbGluZyA9IHZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aCAtIE1hdGguZmxvb3IoZXh0cmFjdEFtb3VudCkpO1xuICAgIHJldHVybiBgJHtsZWFkaW5nfSR7aW5uZXJ9JHt0cmFpbGluZ31gO1xuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbmZpZ3VyZVN0b3JlIChyZWR1Y2VyLCBzYWdhLCBpbml0aWFsU3RhdGUsIGNvbXBvc2VFbmhhbmNlcnMpIHtcbiAgY29uc3Qgc2FnYU1pZGRsZXdhcmUgPSBjcmVhdGVTYWdhTWlkZGxld2FyZSgpO1xuXG4gIGlmICghY29tcG9zZUVuaGFuY2Vycykge1xuICAgIGNvbXBvc2VFbmhhbmNlcnMgPSBjb21wb3NlO1xuICB9XG5cbiAgY29uc3QgbG9nZ2VyTWlkZGxld2FyZSA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgbG9nOiByZWR1eERlYnVnLFxuICAgIHN0YXRlVHJhbnNmb3JtZXI6IChzdGF0ZSkgPT4gYWJicmV2aWF0ZVZhbHVlcyhzdGF0ZSwge1xuICAgICAgYXJyYXlMaW1pdDogNCxcbiAgICAgIHJlY3Vyc2VMaW1pdDogM1xuICAgIH0pLFxuICAgIGFjdGlvblRyYW5zZm9ybWVyOiBhYmJyZXZpYXRlVmFsdWVzLFxuICB9KTtcblxuICBsZXQgc3RvcmUgPSBjcmVhdGVTdG9yZShcbiAgICByZWR1Y2VyLCBpbml0aWFsU3RhdGUsXG5cbiAgICBjb21wb3NlRW5oYW5jZXJzKFxuICAgICAgYXBwbHlNaWRkbGV3YXJlKFxuICAgICAgICBzYWdhTWlkZGxld2FyZSxcbiAgICAgICAgbG9nZ2VyTWlkZGxld2FyZVxuICAgICAgKVxuICAgIClcbiAgKTtcblxuICBzYWdhTWlkZGxld2FyZS5ydW4oc2FnYSk7XG5cbiAgcmV0dXJuIHN0b3JlO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zdG9yZS9jb21tb24uanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWR1eC1zYWdhXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVkdXgtc2FnYVwiXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWR1eC1jbGktbG9nZ2VyXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVkdXgtY2xpLWxvZ2dlclwiXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6c2Vzc2lvbjpzYWdhc1wiKTtcblxuaW1wb3J0IHsgY2FuY2VsLCBjYWxsLCBhbGwsIGZvcmssIHRha2UsIHB1dCB9IGZyb20gJ3JlZHV4LXNhZ2EvZWZmZWN0cyc7XG5cbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgYXN0IGZyb20gXCJsaWIvYXN0L3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBjb250cm9sbGVyIGZyb20gXCJsaWIvY29udHJvbGxlci9zYWdhc1wiO1xuaW1wb3J0ICogYXMgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgZXZtIGZyb20gXCJsaWIvZXZtL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBkYXRhIGZyb20gXCJsaWIvZGF0YS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgd2ViMyBmcm9tIFwibGliL3dlYjMvc2FnYXNcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gKnNhZ2EgKCkge1xuICBkZWJ1ZyhcInN0YXJ0aW5nIGxpc3RlbmVyc1wiKTtcbiAgbGV0IGxpc3RlbmVycyA9IHlpZWxkICpmb3JrTGlzdGVuZXJzKCk7XG5cbiAgLy8gcmVjZWl2aW5nICYgc2F2aW5nIGNvbnRyYWN0cyBpbnRvIHN0YXRlXG4gIGRlYnVnKFwid2FpdGluZyBmb3IgY29udHJhY3QgaW5mb3JtYXRpb25cIik7XG4gIGxldCB7IGNvbnRleHRzLCBzb3VyY2VzIH0gPSB5aWVsZCB0YWtlKGFjdGlvbnMuUkVDT1JEX0NPTlRSQUNUUyk7XG5cbiAgZGVidWcoXCJyZWNvcmRpbmcgY29udHJhY3QgYmluYXJpZXNcIik7XG4gIHlpZWxkICpyZWNvcmRDb250ZXh0cyguLi5jb250ZXh0cyk7XG5cbiAgZGVidWcoXCJyZWNvcmRpbmcgY29udHJhY3Qgc291cmNlc1wiKTtcbiAgeWllbGQgKnJlY29yZFNvdXJjZXMoLi4uc291cmNlcyk7XG5cbiAgZGVidWcoXCJ3YWl0aW5nIGZvciBzdGFydFwiKTtcbiAgLy8gd2FpdCBmb3Igc3RhcnQgc2lnbmFsXG4gIGxldCB7dHhIYXNoLCBwcm92aWRlcn0gPSB5aWVsZCB0YWtlKGFjdGlvbnMuU1RBUlQpO1xuICBkZWJ1ZyhcInN0YXJ0aW5nXCIpO1xuXG4gIC8vIHByb2Nlc3MgdHJhbnNhY3Rpb25cbiAgZGVidWcoXCJmZXRjaGluZyB0cmFuc2FjdGlvbiBpbmZvXCIpO1xuICBsZXQgZXJyID0geWllbGQgKmZldGNoVHgodHhIYXNoLCBwcm92aWRlcik7XG4gIGlmIChlcnIpIHtcbiAgICBkZWJ1ZyhcImVycm9yICVvXCIsIGVycik7XG4gICAgeWllbGQgKmVycm9yKGVycik7XG5cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZyhcInZpc2l0aW5nIEFTVHNcIik7XG4gICAgLy8gdmlzaXQgYXN0c1xuICAgIHlpZWxkICphc3QudmlzaXRBbGwoKTtcblxuICAgIGRlYnVnKFwicmVhZHlpbmdcIik7XG4gICAgLy8gc2lnbmFsIHRoYXQgc3RlcHBpbmcgY2FuIGJlZ2luXG4gICAgeWllbGQgKnJlYWR5KCk7XG5cbiAgICBkZWJ1ZyhcIndhaXRpbmcgZm9yIHRyYWNlIEVPVFwiKTtcbiAgICAvLyB3YWl0IHVudGlsIHRyYWNlIGhpdHMgRU9UXG4gICAgeWllbGQgKnRyYWNlLndhaXQoKTtcblxuICAgIGRlYnVnKFwiZmluaXNoaW5nXCIpO1xuICAgIC8vIGZpbmlzaFxuICAgIHlpZWxkIHB1dChhY3Rpb25zLmZpbmlzaCgpKTtcbiAgfVxuXG4gIGRlYnVnKFwic3RvcHBpbmcgbGlzdGVuZXJzXCIpO1xuICB5aWVsZCBhbGwoXG4gICAgbGlzdGVuZXJzLm1hcCh0YXNrID0+IGNhbmNlbCh0YXNrKSlcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcInNlc3Npb25cIiwgc2FnYSk7XG5cblxuZnVuY3Rpb24gKmZvcmtMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiB5aWVsZCBhbGwoXG4gICAgW2FzdCwgY29udHJvbGxlciwgZGF0YSwgZXZtLCBzb2xpZGl0eSwgdHJhY2UsIHdlYjNdXG4gICAgICAubWFwKCBhcHAgPT4gZm9yayhhcHAuc2FnYSkgKVxuICApO1xufVxuXG5mdW5jdGlvbiogZmV0Y2hUeCh0eEhhc2gsIHByb3ZpZGVyKSB7XG4gIGxldCByZXN1bHQgPSB5aWVsZCAqd2ViMy5pbnNwZWN0VHJhbnNhY3Rpb24odHhIYXNoLCBwcm92aWRlcik7XG5cbiAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgIHJldHVybiByZXN1bHQuZXJyb3I7XG4gIH1cblxuICB5aWVsZCAqZXZtLmJlZ2luKHJlc3VsdCk7XG5cbiAgbGV0IGFkZHJlc3NlcyA9IHlpZWxkICp0cmFjZS5wcm9jZXNzVHJhY2UocmVzdWx0LnRyYWNlKTtcbiAgaWYgKHJlc3VsdC5hZGRyZXNzICYmIGFkZHJlc3Nlcy5pbmRleE9mKHJlc3VsdC5hZGRyZXNzKSA9PSAtMSkge1xuICAgIGFkZHJlc3Nlcy5wdXNoKHJlc3VsdC5hZGRyZXNzKTtcbiAgfVxuXG4gIGxldCBiaW5hcmllcyA9IHlpZWxkICp3ZWIzLm9idGFpbkJpbmFyaWVzKGFkZHJlc3Nlcyk7XG5cbiAgeWllbGQgYWxsKFxuICAgIGFkZHJlc3Nlcy5tYXAoIChhZGRyZXNzLCBpKSA9PiBjYWxsKHJlY29yZEluc3RhbmNlLCBhZGRyZXNzLCBiaW5hcmllc1tpXSkgKVxuICApO1xufVxuXG5mdW5jdGlvbiogcmVjb3JkQ29udGV4dHMoLi4uY29udGV4dHMpIHtcbiAgZm9yIChsZXQgeyBjb250cmFjdE5hbWUsIGJpbmFyeSwgc291cmNlTWFwIH0gb2YgY29udGV4dHMpIHtcbiAgICB5aWVsZCAqZXZtLmFkZENvbnRleHQoY29udHJhY3ROYW1lLCBiaW5hcnkpO1xuXG4gICAgaWYgKHNvdXJjZU1hcCkge1xuICAgICAgeWllbGQgKnNvbGlkaXR5LmFkZFNvdXJjZU1hcChiaW5hcnksIHNvdXJjZU1hcCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uKiByZWNvcmRTb3VyY2VzKC4uLnNvdXJjZXMpIHtcbiAgZm9yIChsZXQgeyBzb3VyY2VQYXRoLCBzb3VyY2UsIGFzdCB9IG9mIHNvdXJjZXMpIHtcbiAgICB5aWVsZCAqc29saWRpdHkuYWRkU291cmNlKHNvdXJjZSwgc291cmNlUGF0aCwgYXN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiAqcmVjb3JkSW5zdGFuY2UoYWRkcmVzcywgYmluYXJ5KSB7XG4gIHlpZWxkICpldm0uYWRkSW5zdGFuY2UoYWRkcmVzcywgYmluYXJ5KTtcbn1cblxuZnVuY3Rpb24gKnJlYWR5KCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZWFkeSgpKTtcbn1cblxuZnVuY3Rpb24gKmVycm9yKGVycikge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5lcnJvcihlcnIpKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc2Vzc2lvbi9zYWdhcy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjphc3Q6c2FnYXNcIik7XG5cbmltcG9ydCB7IGFsbCwgY2FsbCwgcmFjZSwgZm9yaywgam9pbiwgdGFrZSwgdGFrZUV2ZXJ5LCBwdXQsIHNlbGVjdCB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcblxuaW1wb3J0IHsgcHJlZml4TmFtZSB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBkYXRhIGZyb20gXCJsaWIvZGF0YS9zYWdhc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5cbmltcG9ydCBhc3QgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5cbmZ1bmN0aW9uICp3YWxrKHNvdXJjZUlkLCBub2RlLCBwb2ludGVyID0gXCJcIiwgcGFyZW50SWQgPSBudWxsKSB7XG4gIGRlYnVnKFwid2Fsa2luZyAlbyAlb1wiLCBwb2ludGVyLCBub2RlKTtcblxuICB5aWVsZCAqaGFuZGxlRW50ZXIoc291cmNlSWQsIG5vZGUsIHBvaW50ZXIsIHBhcmVudElkKTtcblxuICBpZiAobm9kZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgZm9yIChsZXQgW2ksIGNoaWxkXSBvZiBub2RlLmVudHJpZXMoKSkge1xuICAgICAgeWllbGQgY2FsbCh3YWxrLCBzb3VyY2VJZCwgY2hpbGQsIGAke3BvaW50ZXJ9LyR7aX1gLCBwYXJlbnRJZCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICBmb3IgKGxldCBba2V5LCBjaGlsZF0gb2YgT2JqZWN0LmVudHJpZXMobm9kZSkpIHtcbiAgICAgIHlpZWxkIGNhbGwod2Fsaywgc291cmNlSWQsIGNoaWxkLCBgJHtwb2ludGVyfS8ke2tleX1gLCBub2RlLmlkKTtcbiAgICB9XG4gIH1cblxuICB5aWVsZCAqaGFuZGxlRXhpdChzb3VyY2VJZCwgbm9kZSwgcG9pbnRlcik7XG59XG5cbmZ1bmN0aW9uICpoYW5kbGVFbnRlcihzb3VyY2VJZCwgbm9kZSwgcG9pbnRlciwgcGFyZW50SWQpIHtcbiAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkZWJ1ZyhcImVudGVyaW5nICVzXCIsIHBvaW50ZXIpO1xuXG4gIGlmIChub2RlLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWJ1ZyhcIiVzIHJlY29yZGluZyBzY29wZSAlc1wiLCBwb2ludGVyLCBub2RlLmlkKTtcbiAgICB5aWVsZCAqZGF0YS5zY29wZShub2RlLmlkLCBwb2ludGVyLCBwYXJlbnRJZCwgc291cmNlSWQpO1xuICB9XG5cbiAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjpcbiAgICAgIGRlYnVnKFwiJXMgcmVjb3JkaW5nIHZhcmlhYmxlICVvXCIsIHBvaW50ZXIsIG5vZGUpO1xuICAgICAgeWllbGQgKmRhdGEuZGVjbGFyZShub2RlKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uICpoYW5kbGVFeGl0KHNvdXJjZUlkLCBub2RlLCBwb2ludGVyKSB7XG4gIGRlYnVnKFwiZXhpdGluZyAlc1wiLCBwb2ludGVyKTtcblxuICAvLyBuby1vcCByaWdodCBub3dcbn1cblxuZnVuY3Rpb24gKndhbGtTYWdhKHtzb3VyY2VJZCwgYXN0fSkge1xuICB5aWVsZCB3YWxrKHNvdXJjZUlkLCBhc3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gKnZpc2l0QWxsKGlkeCkge1xuICBsZXQgc291cmNlcyA9IHlpZWxkIHNlbGVjdChhc3Qudmlld3Muc291cmNlcyk7XG5cbiAgbGV0IHRhc2tzID0geWllbGQgYWxsKFxuICAgIE9iamVjdC5lbnRyaWVzKHNvdXJjZXMpXG4gICAgICAuZmlsdGVyKCAoW2lkLCB7YXN0fV0pID0+ICEhYXN0IClcbiAgICAgIC5tYXAoIChbaWQsIHthc3R9XSkgPT4gZm9yayggKCkgPT4gcHV0KGFjdGlvbnMudmlzaXQoaWQsIGFzdCkpKSApXG4gIClcblxuICBpZiAodGFza3MubGVuZ3RoID4gMCkge1xuICAgIHlpZWxkIGpvaW4oLi4udGFza3MpO1xuICB9XG5cbiAgeWllbGQgcHV0KGFjdGlvbnMuZG9uZVZpc2l0aW5nKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EoKSB7XG4gIHlpZWxkIHJhY2Uoe1xuICAgIHZpc2l0b3I6IHRha2VFdmVyeShhY3Rpb25zLlZJU0lULCB3YWxrU2FnYSksXG4gICAgZG9uZTogdGFrZShhY3Rpb25zLkRPTkVfVklTSVRJTkcpXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwiYXN0XCIsIHNhZ2EpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9hc3Qvc2FnYXMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZGF0YTpkZWNvZGVcIik7XG5cbmltcG9ydCB7QmlnTnVtYmVyfSBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XG5cbmltcG9ydCAqIGFzIG1lbW9yeSBmcm9tIFwiLi9tZW1vcnlcIjtcbmltcG9ydCAqIGFzIHN0b3JhZ2UgZnJvbSBcIi4vc3RvcmFnZVwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IFdPUkRfU0laRSB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkKHBvaW50ZXIsIHN0YXRlKSB7XG4gIGlmIChwb2ludGVyLnN0YWNrICE9IHVuZGVmaW5lZCAmJiBzdGF0ZS5zdGFjayAmJiBwb2ludGVyLnN0YWNrIDwgc3RhdGUuc3RhY2subGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlLnN0YWNrW3BvaW50ZXIuc3RhY2tdO1xuICB9IGVsc2UgaWYgKHBvaW50ZXIuc3RvcmFnZSAhPSB1bmRlZmluZWQgJiYgc3RhdGUuc3RvcmFnZSkge1xuICAgIHJldHVybiBzdG9yYWdlLnJlYWRSYW5nZShzdGF0ZS5zdG9yYWdlLCBwb2ludGVyLnN0b3JhZ2UpO1xuICB9IGVsc2UgaWYgKHBvaW50ZXIubWVtb3J5ICE9IHVuZGVmaW5lZCAmJiBzdGF0ZS5tZW1vcnkpIHtcbiAgICByZXR1cm4gbWVtb3J5LnJlYWRCeXRlcyhzdGF0ZS5tZW1vcnksIHBvaW50ZXIubWVtb3J5LnN0YXJ0LCBwb2ludGVyLm1lbW9yeS5sZW5ndGgpO1xuICB9IGVsc2UgaWYgKHBvaW50ZXIubGl0ZXJhbCkge1xuICAgIHJldHVybiBwb2ludGVyLmxpdGVyYWw7XG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVmFsdWUoZGVmaW5pdGlvbiwgcG9pbnRlciwgc3RhdGUsIC4uLmFyZ3MpIHtcbiAgZGVidWcoXG4gICAgXCJkZWNvZGluZyB2YWx1ZSwgcG9pbnRlcjogJW8sIHR5cGVDbGFzczogJXNcIixcbiAgICBwb2ludGVyLCB1dGlscy50eXBlQ2xhc3MoZGVmaW5pdGlvbilcbiAgKTtcbiAgbGV0IGJ5dGVzID0gcmVhZChwb2ludGVyLCBzdGF0ZSk7XG4gIGlmICghYnl0ZXMpIHtcbiAgICBkZWJ1ZyhcInNlZ2ZhdWx0LCBzdGF0ZTogJU9cIiwgc3RhdGUpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBzd2l0Y2ggKHV0aWxzLnR5cGVDbGFzcyhkZWZpbml0aW9uKSkge1xuICAgIGNhc2UgXCJib29sXCI6XG4gICAgICByZXR1cm4gIXV0aWxzLnRvQmlnTnVtYmVyKGJ5dGVzKS5pc1plcm8oKTtcblxuICAgIGNhc2UgXCJ1aW50XCI6XG4gICAgICByZXR1cm4gdXRpbHMudG9CaWdOdW1iZXIoYnl0ZXMpO1xuXG4gICAgY2FzZSBcImludFwiOlxuICAgICAgcmV0dXJuIHV0aWxzLnRvU2lnbmVkQmlnTnVtYmVyKGJ5dGVzKTtcblxuICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICByZXR1cm4gdXRpbHMudG9IZXhTdHJpbmcoYnl0ZXMsIHRydWUpO1xuXG4gICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICBkZWJ1ZyhcInR5cGVJZGVudGlmaWVyICVzICVvXCIsIHV0aWxzLnR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pLCBieXRlcyk7XG4gICAgICBsZXQgbGVuZ3RoID0gdXRpbHMuc3BlY2lmaWVkU2l6ZShkZWZpbml0aW9uKTtcbiAgICAgIHJldHVybiB1dGlscy50b0hleFN0cmluZyhieXRlcywgbGVuZ3RoKTtcblxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGRlYnVnKFwidHlwZUlkZW50aWZpZXIgJXMgJW9cIiwgdXRpbHMudHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbiksIGJ5dGVzKTtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcblxuICAgIGNhc2UgXCJyYXRpb25hbFwiOlxuICAgICAgZGVidWcoXCJ0eXBlSWRlbnRpZmllciAlcyAlb1wiLCB1dGlscy50eXBlSWRlbnRpZmllcihkZWZpbml0aW9uKSwgYnl0ZXMpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRvQmlnTnVtYmVyKGJ5dGVzKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBkZWJ1ZyhcIlVua25vd24gdmFsdWUgdHlwZTogJXNcIiwgdXRpbHMudHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbikpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU1lbW9yeVJlZmVyZW5jZShkZWZpbml0aW9uLCBwb2ludGVyLCBzdGF0ZSwgLi4uYXJncykge1xuICBsZXQgcmF3VmFsdWUgPSB1dGlscy50b0JpZ051bWJlcihyZWFkKHBvaW50ZXIsIHN0YXRlKSkudG9OdW1iZXIoKTtcblxuICB2YXIgYnl0ZXM7XG4gIHN3aXRjaCAodXRpbHMudHlwZUNsYXNzKGRlZmluaXRpb24pKSB7XG5cbiAgICBjYXNlIFwiYnl0ZXNcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBieXRlcyA9IHJlYWQoe1xuICAgICAgICBtZW1vcnk6IHsgc3RhcnQ6IHJhd1ZhbHVlLCBsZW5ndGg6IFdPUkRfU0laRX1cbiAgICAgIH0sIHN0YXRlKTsgLy8gYnl0ZXMgY29udGFpbiBsZW5ndGhcblxuICAgICAgcmV0dXJuIGRlY29kZVZhbHVlKGRlZmluaXRpb24sIHtcbiAgICAgICAgbWVtb3J5OiB7IHN0YXJ0OiByYXdWYWx1ZSArIFdPUkRfU0laRSwgbGVuZ3RoOiBieXRlcyB9XG4gICAgICB9LCBzdGF0ZSwgLi4uYXJncyk7XG5cbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIGJ5dGVzID0gdXRpbHMudG9CaWdOdW1iZXIocmVhZCh7XG4gICAgICAgIG1lbW9yeTogeyBzdGFydDogcmF3VmFsdWUsIGxlbmd0aDogV09SRF9TSVpFIH0sXG4gICAgICB9LCBzdGF0ZSkpLnRvTnVtYmVyKCk7ICAvLyBieXRlcyBjb250YWluIGFycmF5IGxlbmd0aFxuXG4gICAgICBieXRlcyA9IHJlYWQoeyBtZW1vcnk6IHtcbiAgICAgICAgc3RhcnQ6IHJhd1ZhbHVlICsgV09SRF9TSVpFLCBsZW5ndGg6IGJ5dGVzICogV09SRF9TSVpFXG4gICAgICB9fSwgc3RhdGUpOyAvLyBub3cgYnl0ZXMgY29udGFpbiBpdGVtc1xuXG4gICAgICByZXR1cm4gbWVtb3J5LmNodW5rKGJ5dGVzLCBXT1JEX1NJWkUpXG4gICAgICAgIC5tYXAoXG4gICAgICAgICAgKGNodW5rKSA9PiBkZWNvZGUodXRpbHMuYmFzZURlZmluaXRpb24oZGVmaW5pdGlvbiksIHtcbiAgICAgICAgICAgIGxpdGVyYWw6IGNodW5rXG4gICAgICAgICAgfSwgc3RhdGUsIC4uLmFyZ3MpXG4gICAgICAgIClcblxuICAgIGNhc2UgXCJzdHJ1Y3RcIjpcbiAgICAgIGxldCBbcmVmc10gPSBhcmdzO1xuICAgICAgbGV0IHN0cnVjdERlZmluaXRpb24gPSByZWZzW2RlZmluaXRpb24udHlwZU5hbWUucmVmZXJlbmNlZERlY2xhcmF0aW9uXTtcbiAgICAgIGxldCBzdHJ1Y3RWYXJpYWJsZXMgPSBzdHJ1Y3REZWZpbml0aW9uLnZhcmlhYmxlcyB8fCBbXTtcblxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LCAuLi5zdHJ1Y3RWYXJpYWJsZXNcbiAgICAgICAgICAubWFwKFxuICAgICAgICAgICAgKHtuYW1lLCBpZH0sIGkpID0+IHtcbiAgICAgICAgICAgICAgbGV0IG1lbWJlckRlZmluaXRpb24gPSByZWZzW2lkXS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgICBsZXQgbWVtYmVyUG9pbnRlciA9IHtcbiAgICAgICAgICAgICAgICBtZW1vcnk6IHsgc3RhcnQ6IHJhd1ZhbHVlICsgaSAqIFdPUkRfU0laRSwgbGVuZ3RoOiBXT1JEX1NJWkUgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAvLyBsZXQgbWVtYmVyUG9pbnRlciA9IG1lbW9yeS5yZWFkKHN0YXRlLm1lbW9yeSwgcG9pbnRlciArIGkgKiBXT1JEX1NJWkUpO1xuXG4gICAgICAgICAgICAgIC8vIEhBQ0tcbiAgICAgICAgICAgICAgbWVtYmVyRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAuLi5tZW1iZXJEZWZpbml0aW9uLFxuXG4gICAgICAgICAgICAgICAgdHlwZURlc2NyaXB0aW9uczoge1xuICAgICAgICAgICAgICAgICAgLi4ubWVtYmVyRGVmaW5pdGlvbi50eXBlRGVzY3JpcHRpb25zLFxuXG4gICAgICAgICAgICAgICAgICB0eXBlSWRlbnRpZmllcjpcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyRGVmaW5pdGlvbi50eXBlRGVzY3JpcHRpb25zLnR5cGVJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL19zdG9yYWdlXy9nLCBcIl9tZW1vcnlfXCIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgW25hbWVdOiBkZWNvZGUoXG4gICAgICAgICAgICAgICAgICBtZW1iZXJEZWZpbml0aW9uLCBtZW1iZXJQb2ludGVyLCBzdGF0ZSwgLi4uYXJnc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICApO1xuXG5cbiAgICBkZWZhdWx0OlxuICAgICAgZGVidWcoXCJVbmtub3duIG1lbW9yeSByZWZlcmVuY2UgdHlwZTogJXNcIiwgdXRpbHMudHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbikpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgfVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdG9yYWdlUmVmZXJlbmNlKGRlZmluaXRpb24sIHBvaW50ZXIsIHN0YXRlLCAuLi5hcmdzKSB7XG4gIHZhciBkYXRhO1xuICB2YXIgYnl0ZXM7XG4gIHZhciBsZW5ndGg7XG4gIHZhciBzbG90O1xuXG4gIHN3aXRjaCAodXRpbHMudHlwZUNsYXNzKGRlZmluaXRpb24pKSB7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICBkZWJ1ZyhcInN0b3JhZ2UgYXJyYXkhICVvXCIsIHBvaW50ZXIpO1xuICAgICAgZGF0YSA9IHJlYWQocG9pbnRlciwgc3RhdGUpO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSB1dGlscy50b0JpZ051bWJlcihkYXRhKS50b051bWJlcigpO1xuICAgICAgZGVidWcoXCJsZW5ndGggJW9cIiwgbGVuZ3RoKTtcblxuICAgICAgY29uc3QgYmFzZVNpemUgPSB1dGlscy5zdG9yYWdlU2l6ZSh1dGlscy5iYXNlRGVmaW5pdGlvbihkZWZpbml0aW9uKSk7XG4gICAgICBjb25zdCBwZXJXb3JkID0gTWF0aC5mbG9vcihXT1JEX1NJWkUgLyBiYXNlU2l6ZSk7XG4gICAgICBkZWJ1ZyhcImJhc2VTaXplICVvXCIsIGJhc2VTaXplKTtcbiAgICAgIGRlYnVnKFwicGVyV29yZCAlZFwiLCBwZXJXb3JkKTtcblxuICAgICAgY29uc3Qgb2Zmc2V0ID0gKGkpID0+IHtcbiAgICAgICAgaWYgKHBlcldvcmQgPT0gMSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoaSAqIGJhc2VTaXplIC8gV09SRF9TSVpFKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSAoaSkgPT4ge1xuICAgICAgICBpZiAocGVyV29yZCA9PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFdPUkRfU0laRSAtIGJhc2VTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwZXJXb3JkIC0gaSAlIHBlcldvcmQgLSAxO1xuICAgICAgICByZXR1cm4gcG9zaXRpb24gKiBiYXNlU2l6ZTtcbiAgICAgIH1cblxuICAgICAgZGVidWcoXCJwb2ludGVyOiAlb1wiLCBwb2ludGVyKTtcbiAgICAgIHJldHVybiBbLi4uQXJyYXkobGVuZ3RoKS5rZXlzKCldXG4gICAgICAgIC5tYXAoIChpKSA9PiB7XG4gICAgICAgICAgbGV0IGNoaWxkRnJvbSA9IHBvaW50ZXIuc3RvcmFnZS5mcm9tLm9mZnNldCAhPSB1bmRlZmluZWQgP1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzbG90OiBbXCIweFwiICsgdXRpbHMudG9CaWdOdW1iZXIoXG4gICAgICAgICAgICAgICAgdXRpbHMua2VjY2FrMjU2KC4uLnBvaW50ZXIuc3RvcmFnZS5mcm9tLnNsb3QpXG4gICAgICAgICAgICAgICkucGx1cyhwb2ludGVyLnN0b3JhZ2UuZnJvbS5vZmZzZXQpLnRvU3RyaW5nKDE2KV0sXG4gICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0KGkpLFxuICAgICAgICAgICAgICBpbmRleDogaW5kZXgoaSlcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHNsb3Q6IFtwb2ludGVyLnN0b3JhZ2UuZnJvbS5zbG90XSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQoaSksXG4gICAgICAgICAgICAgIGluZGV4OiBpbmRleChpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gY2hpbGRGcm9tO1xuICAgICAgICB9KVxuICAgICAgICAubWFwKCAoY2hpbGRGcm9tLCBpZHgpID0+IHtcbiAgICAgICAgICBkZWJ1ZyhcImNoaWxkRnJvbSAlZCwgJW9cIiwgaWR4LCBjaGlsZEZyb20pO1xuICAgICAgICAgIHJldHVybiBkZWNvZGUodXRpbHMuYmFzZURlZmluaXRpb24oZGVmaW5pdGlvbiksIHsgc3RvcmFnZToge1xuICAgICAgICAgICAgZnJvbTogY2hpbGRGcm9tLFxuICAgICAgICAgICAgbGVuZ3RoOiBiYXNlU2l6ZVxuICAgICAgICAgIH19LCBzdGF0ZSwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuXG4gICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgZGVidWcoXCJzdHJpbmcgcG9pbnRlciAlT1wiLCBwb2ludGVyKTtcbiAgICAgIGRlYnVnKFwic3RvcmFnZSAlb1wiLCBzdGF0ZS5zdG9yYWdlKTtcbiAgICAgIGRhdGEgPSByZWFkKHBvaW50ZXIsIHN0YXRlKTtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZGVidWcoXCJkYXRhICVPXCIsIGRhdGEpO1xuICAgICAgaWYgKGRhdGFbV09SRF9TSVpFIC0gMV0gJSAyID09IDApIHtcbiAgICAgICAgLy8gc3RyaW5nIGxpdmVzIGluIHdvcmQsIGxlbmd0aCBpcyBsYXN0IGJ5dGUgLyAyXG4gICAgICAgIGxlbmd0aCA9IGRhdGFbV09SRF9TSVpFIC0gMV0gLyAyO1xuICAgICAgICBkZWJ1ZyhcImluLXdvcmQ7IGxlbmd0aCAlb1wiLCBsZW5ndGgpO1xuICAgICAgICBpZiAobGVuZ3RoID09IDApIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWNvZGVWYWx1ZShkZWZpbml0aW9uLCB7IHN0b3JhZ2U6IHtcbiAgICAgICAgICBmcm9tOiB7IHNsb3Q6IHBvaW50ZXIuc3RvcmFnZS5mcm9tLnNsb3QsIGluZGV4OiAwIH0sXG4gICAgICAgICAgdG86IHsgc2xvdDogcG9pbnRlci5zdG9yYWdlLmZyb20uc2xvdCwgaW5kZXg6IGxlbmd0aCAtIDF9XG4gICAgICAgIH19LCBzdGF0ZSwgLi4uYXJncyk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbmd0aCA9IHV0aWxzLnRvQmlnTnVtYmVyKGRhdGEpLm1pbnVzKDEpLmRpdigyKS50b051bWJlcigpO1xuICAgICAgICBkZWJ1ZyhcIm5ldy13b3JkLCBsZW5ndGggJW9cIiwgbGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gZGVjb2RlVmFsdWUoZGVmaW5pdGlvbiwgeyBzdG9yYWdlOiB7XG4gICAgICAgICAgZnJvbTogeyBzbG90OiBbcG9pbnRlci5zdG9yYWdlLmZyb20uc2xvdF0sIGluZGV4OiAwIH0sXG4gICAgICAgICAgbGVuZ3RoXG4gICAgICAgIH19LCBzdGF0ZSwgLi4uYXJncyk7XG4gICAgICB9XG5cbiAgICBjYXNlIFwic3RydWN0XCI6XG4gICAgICBsZXQgW3JlZnNdID0gYXJncztcblxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LCAuLi5PYmplY3QuZW50cmllcyhwb2ludGVyLnN0b3JhZ2UuY2hpbGRyZW4pXG4gICAgICAgICAgLm1hcCggKFtpZCwgY2hpbGRQb2ludGVyXSkgPT4gKHtcbiAgICAgICAgICAgIFtjaGlsZFBvaW50ZXIubmFtZV06IGRlY29kZShcbiAgICAgICAgICAgICAgcmVmc1tpZF0uZGVmaW5pdGlvbiwgeyBzdG9yYWdlOiBjaGlsZFBvaW50ZXIgfSwgc3RhdGUsIC4uLmFyZ3NcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KSlcbiAgICAgICk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgZGVidWcoXCJVbmtub3duIHN0b3JhZ2UgcmVmZXJlbmNlIHR5cGU6ICVzXCIsIHV0aWxzLnR5cGVJZGVudGlmaWVyKGRlZmluaXRpb24pKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU1hcHBpbmcoZGVmaW5pdGlvbiwgcG9pbnRlciwgLi4uYXJncykge1xuICBpZiAoZGVmaW5pdGlvbi5yZWZlcmVuY2VkRGVjbGFyYXRpb24pIHtcbiAgICAvLyBhdHRlbXB0aW5nIHRvIGRlY29kZSByZWZlcmVuY2UgdG8gbWFwcGluZywgdGh1cyBtaXNzaW5nIHZhbGlkIHBvaW50ZXJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGRlYnVnKFwibWFwcGluZyAlT1wiLCBwb2ludGVyKTtcbiAgZGVidWcoXCJtYXBwaW5nIGRlZmluaXRpb24gJU9cIiwgZGVmaW5pdGlvbik7XG4gIGxldCB7IGtleXMgfSA9IHBvaW50ZXI7XG4gIGtleXMgPSBrZXlzIHx8IFtdO1xuICBkZWJ1ZyhcImtub3duIGtleXMgJW9cIiwga2V5cyk7XG5cbiAgbGV0IGtleURlZmluaXRpb24gPSBkZWZpbml0aW9uLnR5cGVOYW1lLmtleVR5cGU7XG4gIGxldCB2YWx1ZURlZmluaXRpb24gPSBkZWZpbml0aW9uLnR5cGVOYW1lLnZhbHVlVHlwZTtcblxuICBsZXQgYmFzZVNsb3QgPSBwb2ludGVyLnN0b3JhZ2UuZnJvbS5zbG90O1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYmFzZVNsb3QpKSB7XG4gICAgYmFzZVNsb3QgPSBbYmFzZVNsb3RdO1xuICB9XG5cbiAgbGV0IG1hcHBpbmcgPSB7fTtcbiAgZGVidWcoXCJtYXBwaW5nICVPXCIsIG1hcHBpbmcpO1xuICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgIGxldCBrZXlQb2ludGVyID0geyBcImxpdGVyYWxcIjoga2V5IH07XG4gICAgbGV0IHZhbHVlUG9pbnRlciA9IHtcbiAgICAgIHN0b3JhZ2U6IHtcbiAgICAgICAgZnJvbToge1xuICAgICAgICAgIHNsb3Q6IFtrZXksIC4uLmJhc2VTbG90XSxcbiAgICAgICAgICBpbmRleDogMFxuICAgICAgICB9LFxuICAgICAgICB0bzoge1xuICAgICAgICAgIHNsb3Q6IFtrZXksIC4uLmJhc2VTbG90XSxcbiAgICAgICAgICBpbmRleDogMzFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBOT1RFIG1hcHBpbmcga2V5cyBhcmUgcG90ZW50aWFsbHkgbG9zc3kgYmVjYXVzZSBKUyBvbmx5IGxpa2VzIHN0cmluZ3NcbiAgICBsZXQga2V5VmFsdWUgPSBkZWNvZGUoa2V5RGVmaW5pdGlvbiwga2V5UG9pbnRlciwgLi4uYXJncyk7XG4gICAgaWYgKGtleVZhbHVlICE9IHVuZGVmaW5lZCkge1xuICAgICAgbWFwcGluZ1trZXlWYWx1ZS50b1N0cmluZygpXSA9XG4gICAgICAgIGRlY29kZSh2YWx1ZURlZmluaXRpb24sIHZhbHVlUG9pbnRlciwgLi4uYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hcHBpbmc7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVjb2RlKGRlZmluaXRpb24sIHBvaW50ZXIsIC4uLmFyZ3MpIHtcbiAgaWYgKHBvaW50ZXIubGl0ZXJhbCkge1xuICAgIHJldHVybiBwb2ludGVyLmxpdGVyYWw7XG4gIH1cblxuICBjb25zdCBpZGVudGlmaWVyID0gdXRpbHMudHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbik7XG4gIGlmICh1dGlscy5pc1JlZmVyZW5jZShkZWZpbml0aW9uKSkge1xuICAgIHN3aXRjaCAodXRpbHMucmVmZXJlbmNlVHlwZShkZWZpbml0aW9uKSkge1xuICAgICAgY2FzZSBcIm1lbW9yeVwiOlxuICAgICAgICBkZWJ1ZyhcImRlY29kaW5nIG1lbW9yeSByZWZlcmVuY2UsIHR5cGU6ICVzXCIsIGlkZW50aWZpZXIpO1xuICAgICAgICByZXR1cm4gZGVjb2RlTWVtb3J5UmVmZXJlbmNlKGRlZmluaXRpb24sIHBvaW50ZXIsIC4uLmFyZ3MpO1xuICAgICAgY2FzZSBcInN0b3JhZ2VcIjpcbiAgICAgICAgZGVidWcoXCJkZWNvZGluZyBzdG9yYWdlIHJlZmVyZW5jZSwgdHlwZTogJXNcIiwgaWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybiBkZWNvZGVTdG9yYWdlUmVmZXJlbmNlKGRlZmluaXRpb24sIHBvaW50ZXIsIC4uLmFyZ3MpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZGVidWcoXCJVbmtub3duIHJlZmVyZW5jZSBjYXRlZ29yeTogJXNcIiwgdXRpbHMudHlwZUlkZW50aWZpZXIoZGVmaW5pdGlvbikpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1dGlscy5pc01hcHBpbmcoZGVmaW5pdGlvbikpIHtcbiAgICBkZWJ1ZyhcImRlY29kaW5nIG1hcHBpbmcsIHR5cGU6ICVzXCIsIGlkZW50aWZpZXIpO1xuICAgIHJldHVybiBkZWNvZGVNYXBwaW5nKGRlZmluaXRpb24sIHBvaW50ZXIsIC4uLmFyZ3MpO1xuICB9XG5cbiAgZGVidWcoXCJkZWNvZGluZyB2YWx1ZSwgdHlwZTogJXNcIiwgaWRlbnRpZmllcik7XG4gIHJldHVybiBkZWNvZGVWYWx1ZShkZWZpbml0aW9uLCBwb2ludGVyLCAuLi5hcmdzKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGF0YS9kZWNvZGUvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZGF0YTpkZWNvZGU6bWVtb3J5XCIpO1xuXG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBXT1JEX1NJWkUgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG4vKipcbiAqIHJlYWQgd29yZCBmcm9tIG1lbW9yeVxuICpcbiAqIHJlcXVpcmVzIGBieXRlYCB0byBiZSBhIG11bHRpcGxlIG9mIFdPUkRfU0laRSAoMzIpXG4gKlxuICogQHBhcmFtIG1lbW9yeSAtIFVpbnQ4QXJyYXlcbiAqIEByZXR1cm4ge0JpZ051bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWQobWVtb3J5LCBieXRlKSB7XG4gIHJldHVybiByZWFkQnl0ZXMobWVtb3J5LCBieXRlLCBXT1JEX1NJWkUpO1xufVxuXG4vKipcbiAqIHJlYWQgPGJ5dGVzPiBhbW91bnQgb2YgYnl0ZXMgZnJvbSBtZW1vcnksIHN0YXJ0aW5nIGF0IGJ5dGUgPHN0YXJ0PlxuICpcbiAqIEBwYXJhbSBtZW1vcnkgLSBVaW50OEFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkQnl0ZXMobWVtb3J5LCBieXRlLCBsZW5ndGgpIHtcbiAgYnl0ZSA9IHV0aWxzLnRvQmlnTnVtYmVyKGJ5dGUpO1xuICBsZW5ndGggPSB1dGlscy50b0JpZ051bWJlcihsZW5ndGgpO1xuXG4gIGlmIChieXRlLnRvTnVtYmVyKCkgPj0gbWVtb3J5Lmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShsZW5ndGggPyBsZW5ndGgudG9OdW1iZXIoKSA6IDApO1xuICB9XG5cbiAgaWYgKGxlbmd0aCA9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobWVtb3J5LmJ1ZmZlciwgYnl0ZS50b051bWJlcigpKTtcbiAgfVxuXG4gIC8vIGdyYWIgYGxlbmd0aGAgYnl0ZXMgbm8gbWF0dGVyIHdoYXQsIGhlcmUgZmlsbCB0aGlzIGFycmF5XG4gIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aC50b051bWJlcigpKTtcblxuICAvLyBpZiB3ZSdyZSByZWFkaW5nIHBhc3QgdGhlIGVuZCBvZiBtZW1vcnksIHRydW5jYXRlIHRoZSBsZW5ndGggdG8gcmVhZFxuICBsZXQgZXhjZXNzID0gYnl0ZS5wbHVzKGxlbmd0aCkubWludXMobWVtb3J5Lmxlbmd0aCkudG9OdW1iZXIoKTtcbiAgaWYgKGV4Y2VzcyA+IDApIHtcbiAgICBsZW5ndGggPSBuZXcgQmlnTnVtYmVyKG1lbW9yeS5sZW5ndGgpLm1pbnVzKGJ5dGUpO1xuICB9XG5cbiAgbGV0IGV4aXN0aW5nID0gbmV3IFVpbnQ4QXJyYXkobWVtb3J5LmJ1ZmZlciwgYnl0ZS50b051bWJlcigpLCBsZW5ndGgudG9OdW1iZXIoKSk7XG5cbiAgYnl0ZXMuc2V0KGV4aXN0aW5nKTtcblxuICByZXR1cm4gYnl0ZXM7XG59XG5cbi8qKlxuICogU3BsaXQgbWVtb3J5IGludG8gY2h1bmtzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaHVuayhtZW1vcnksIHNpemUgPSBXT1JEX1NJWkUpIHtcbiAgbGV0IGNodW5rcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWVtb3J5Lmxlbmd0aDsgaSArPSBzaXplKSB7XG4gICAgbGV0IGNodW5rID0gcmVhZEJ5dGVzKG1lbW9yeSwgaSwgc2l6ZSk7XG4gICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rcztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGF0YS9kZWNvZGUvbWVtb3J5LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmRhdGE6ZGVjb2RlOnN0b3JhZ2VcIik7XG5cbmltcG9ydCB7IFdPUkRfU0laRSB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi91dGlsc1wiO1xuXG4vKipcbiAqIGNvbnZlcnQgYSBzbG90IHRvIGEgd29yZCBjb3JyZXNwb25kaW5nIHRvIGFjdHVhbCBzdG9yYWdlIGFkZHJlc3NcbiAqXG4gKiBpZiBgc2xvdGAgaXMgYW4gYXJyYXksIHJldHVybiBoYXNoIG9mIGFycmF5IHZhbHVlcy5cbiAqIGlmIGBzbG90YCBhcnJheSBpcyBuZXN0ZWQsIHJlY3Vyc2Ugb24gc3ViLWFycmF5c1xuICpcbiAqIEBwYXJhbSBzbG90IC0gbnVtYmVyIG9yIHBvc3NpYmx5LW5lc3RlZCBhcnJheSBvZiBudW1iZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbG90QWRkcmVzcyhzbG90KSB7XG4gIGlmIChzbG90IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXR1cm4gdXRpbHMua2VjY2FrMjU2KC4uLnNsb3QubWFwKHNsb3RBZGRyZXNzKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHV0aWxzLnRvQmlnTnVtYmVyKHNsb3QpO1xuICB9XG59XG5cbi8qKlxuICogcmVhZCBzbG90IGZyb20gc3RvcmFnZVxuICpcbiAqIEBwYXJhbSBzbG90IC0gYmlnIG51bWJlciBvciBhcnJheSBvZiByZWd1bGFyIG51bWJlcnNcbiAqIEBwYXJhbSBvZmZzZXQgLSBmb3IgYXJyYXksIG9mZnNldCBmcm9tIHRoZSBrZWNjYWsgZGV0ZXJtaW5lZCBsb2NhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZChzdG9yYWdlLCBzbG90LCBvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IGFkZHJlc3MgPSBzbG90QWRkcmVzcyhzbG90KS5wbHVzKG9mZnNldCk7XG5cbiAgZGVidWcoXCJyZWFkaW5nIHNsb3Q6ICVvXCIsIHV0aWxzLnRvSGV4U3RyaW5nKGFkZHJlc3MpKTtcblxuICBsZXQgd29yZCA9IHN0b3JhZ2VbdXRpbHMudG9IZXhTdHJpbmcoYWRkcmVzcywgV09SRF9TSVpFKV0gfHxcbiAgICBuZXcgVWludDhBcnJheShXT1JEX1NJWkUpO1xuXG4gIGRlYnVnKFwid29yZCAlb1wiLCB3b3JkKTtcbiAgcmV0dXJuIHdvcmRcbn1cblxuLyoqXG4gKiByZWFkIGFsbCBieXRlcyBpbiBzb21lIHJhbmdlLlxuICpcbiAqIHBhcmFtZXRlcnMgYGZyb21gIGFuZCBgdG9gIGFyZSBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgc2xvdCAtIChyZXF1aXJlZCkgZWl0aGVyIGEgYmlnbnVtYmVyIG9yIGEgXCJwYXRoXCIgYXJyYXkgb2YgaW50ZWdlciBvZmZzZXRzXG4gKlxuICogICAgIHBhdGggYXJyYXkgdmFsdWVzIGdldCBjb252ZXJ0ZWQgaW50byBrZWNjYWsyNTYgaGFzaCBhcyBwZXIgc29saWRpdHlcbiAqICAgICBzdG9yYWdlIGFsbG9jYXRpb24gbWV0aG9kXG4gKlxuICogICAgIHJlZjogaHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIzL21pc2NlbGxhbmVvdXMuaHRtbCNsYXlvdXQtb2Ytc3RhdGUtdmFyaWFibGVzLWluLXN0b3JhZ2VcbiAqICAgICAoc2VhcmNoIFwiY29uY2F0ZW5hdGlvblwiKVxuICpcbiAqICBvZmZzZXQgLSAoZGVmYXVsdDogMCkgc2xvdCBvZmZzZXRcbiAqXG4gKiAgaW5kZXggLSAoZGVmYXVsdDogMCkgYnl0ZSBpbmRleCBpbiB3b3JkXG4gKlxuICogQHBhcmFtIGZyb20gLSBsb2NhdGlvbiAoc2VlIF4pXG4gKiBAcGFyYW0gdG8gLSBsb2NhdGlvbiAoc2VlIF4pLiBpbmNsdXNpdmUuXG4gKiBAcGFyYW0gbGVuZ3RoIC0gaW5zdGVhZCBvZiBgdG9gLCBudW1iZXIgb2YgYnl0ZXMgYWZ0ZXIgYGZyb21gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkUmFuZ2Uoc3RvcmFnZSwge2Zyb20sIHRvLCBsZW5ndGh9KSB7XG4gIGlmICghbGVuZ3RoICYmICF0byB8fCBsZW5ndGggJiYgdG8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdXN0IHNwZWNpZnkgZXhhY3RseSBvbmUgYHRvYHxgbGVuZ3RoYFwiKTtcbiAgfVxuXG4gIGZyb20gPSB7XG4gICAgLi4uZnJvbSxcbiAgICBvZmZzZXQ6IGZyb20ub2Zmc2V0IHx8IDBcbiAgfTtcblxuICBpZiAobGVuZ3RoKSB7XG4gICAgdG8gPSB7XG4gICAgICBzbG90OiBmcm9tLnNsb3QsXG4gICAgICBvZmZzZXQ6IGZyb20ub2Zmc2V0ICsgTWF0aC5mbG9vcigoZnJvbS5pbmRleCArIGxlbmd0aCAtIDEpIC8gV09SRF9TSVpFKSxcbiAgICAgIGluZGV4OiAoZnJvbS5pbmRleCArIGxlbmd0aCAtIDEpICUgV09SRF9TSVpFXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0byA9IHtcbiAgICAgIC4uLnRvLFxuICAgICAgb2Zmc2V0OiB0by5vZmZzZXQgfHwgMFxuICAgIH1cbiAgfVxuXG4gIGRlYnVnKFwicmVhZFJhbmdlICVvXCIsIHtmcm9tLHRvfSk7XG5cbiAgY29uc3QgdG90YWxXb3JkcyA9IHRvLm9mZnNldCAtIGZyb20ub2Zmc2V0ICsgMTtcbiAgZGVidWcoXCJ0b3RhbFdvcmRzICVvXCIsIHRvdGFsV29yZHMpO1xuXG4gIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodG90YWxXb3JkcyAqIFdPUkRfU0laRSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFdvcmRzOyBpKyspIHtcbiAgICBsZXQgb2Zmc2V0ID0gaSArIGZyb20ub2Zmc2V0O1xuICAgIGRhdGEuc2V0KHJlYWQoc3RvcmFnZSwgZnJvbS5zbG90LCBvZmZzZXQpLCBpICogV09SRF9TSVpFKTtcbiAgfVxuICBkZWJ1ZyhcIndvcmRzICVvXCIsIGRhdGEpO1xuXG4gIGRhdGEgPSBkYXRhLnNsaWNlKGZyb20uaW5kZXgsICh0b3RhbFdvcmRzIC0gMSkgKiBXT1JEX1NJWkUgKyB0by5pbmRleCArIDEpO1xuXG4gIGRlYnVnKFwiZGF0YTogJW9cIiwgZGF0YSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGF0YS9kZWNvZGUvc3RvcmFnZS5qcyIsImV4cG9ydCBjb25zdCBWSVNJVCA9IFwiVklTSVRcIjtcbmV4cG9ydCBmdW5jdGlvbiB2aXNpdChzb3VyY2VJZCwgYXN0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogVklTSVQsXG4gICAgc291cmNlSWQsIGFzdFxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBET05FX1ZJU0lUSU5HID0gXCJET05FX1ZJU0lUSU5HXCI7XG5leHBvcnQgZnVuY3Rpb24gZG9uZVZpc2l0aW5nKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IERPTkVfVklTSVRJTkdcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvYXN0L2FjdGlvbnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6Y29udHJvbGxlcjpzYWdhc1wiKTtcblxuaW1wb3J0IHsgcHV0LCBjYWxsLCByYWNlLCB0YWtlLCBzZWxlY3QgfSBmcm9tICdyZWR1eC1zYWdhL2VmZmVjdHMnO1xuXG5pbXBvcnQgeyBwcmVmaXhOYW1lIH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCAqIGFzIHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2FnYXNcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuXG5pbXBvcnQgY29udHJvbGxlciBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cbmNvbnN0IENPTlRST0xfU0FHQVMgPSB7XG4gIFthY3Rpb25zLkFEVkFOQ0VdOiBhZHZhbmNlLFxuICBbYWN0aW9ucy5TVEVQX05FWFRdOiBzdGVwTmV4dCxcbiAgW2FjdGlvbnMuU1RFUF9PVkVSXTogc3RlcE92ZXIsXG4gIFthY3Rpb25zLlNURVBfSU5UT106IHN0ZXBJbnRvLFxuICBbYWN0aW9ucy5TVEVQX09VVF06IHN0ZXBPdXQsXG4gIFthY3Rpb25zLkNPTlRJTlVFX1VOVElMXTogY29udGludWVVbnRpbFxufTtcblxuLyoqIEFTVCBub2RlIHR5cGVzIHRoYXQgYXJlIHNraXBwZWQgdG8gZmlsdGVyIG91dCBzb21lIG5vaXNlICovXG5jb25zdCBTS0lQUEVEX1RZUEVTID0gbmV3IFNldChbXG4gIFwiQ29udHJhY3REZWZpbml0aW9uXCIsXG4gIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFxuXSk7XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBkZWJ1ZyhcIndhaXRpbmcgZm9yIGNvbnRyb2wgYWN0aW9uXCIpO1xuICAgIGxldCBhY3Rpb24gPSB5aWVsZCB0YWtlKE9iamVjdC5rZXlzKENPTlRST0xfU0FHQVMpKTtcbiAgICBkZWJ1ZyhcImdvdCBjb250cm9sIGFjdGlvblwiKTtcbiAgICBsZXQgc2FnYSA9IENPTlRST0xfU0FHQVNbYWN0aW9uLnR5cGVdO1xuXG4gICAgeWllbGQgcHV0KGFjdGlvbnMuYmVnaW5TdGVwKGFjdGlvbi50eXBlKSk7XG5cbiAgICB5aWVsZCByYWNlKHtcbiAgICAgIGV4ZWM6IGNhbGwoc2FnYSwgYWN0aW9uKSxcbiAgICAgIGludGVycnVwdDogdGFrZShhY3Rpb25zLklOVEVSUlVQVClcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwiY29udHJvbGxlclwiLCBzYWdhKTtcblxuLyoqXG4gKiBBZHZhbmNlIHRoZSBzdGF0ZSBieSBvbmUgaW5zdHJ1Y3Rpb25cbiAqL1xuZnVuY3Rpb24qIGFkdmFuY2UoKSB7XG4gIC8vIHNlbmQgYWN0aW9uIHRvIGFkdmFuY2UgdHJhY2VcbiAgeWllbGQgKnRyYWNlLmFkdmFuY2UoKTtcbn1cblxuLyoqXG4gKiBzdGVwTmV4dCAtIHN0ZXAgdG8gdGhlIG5leHQgbG9naWNhbCBjb2RlIHNlZ21lbnRcbiAqXG4gKiBOb3RlOiBJdCBtaWdodCB0YWtlIG11bHRpcGxlIGluc3RydWN0aW9ucyB0byBleHByZXNzIHRoZSBzYW1lIHNlY3Rpb24gb2YgY29kZS5cbiAqIFwiU3RlcHBpbmdcIiwgdGhlbiwgaXMgc3RlcHBpbmcgdG8gdGhlIG5leHQgbG9naWNhbCBpdGVtLCBub3Qgc3RlcHBpbmcgdG8gdGhlIG5leHRcbiAqIGluc3RydWN0aW9uLiBTZWUgYWR2YW5jZSgpIGlmIHlvdSdkIGxpa2UgdG8gYWR2YW5jZSBieSBvbmUgaW5zdHJ1Y3Rpb24uXG4gKi9cbmZ1bmN0aW9uKiBzdGVwTmV4dCAoKSB7XG4gIGNvbnN0IHN0YXJ0aW5nUmFuZ2UgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLnNvdXJjZVJhbmdlKTtcblxuICB2YXIgdXBjb21pbmc7XG5cbiAgZG8ge1xuICAgIC8vIGFkdmFuY2UgYXQgbGVhc3Qgb25jZSBzdGVwXG4gICAgeWllbGQqIGFkdmFuY2UoKTtcblxuICAgIC8vIGFuZCBjaGVjayB0aGUgbmV4dCBzb3VyY2UgcmFuZ2VcbiAgICB1cGNvbWluZyA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24pO1xuXG4gICAgLy8gaWYgdGhlIG5leHQgc3RlcCdzIHNvdXJjZSByYW5nZSBpcyBzdGlsbCB0aGUgc2FtZSwga2VlcCBnb2luZ1xuICB9IHdoaWxlIChcbiAgICAhdXBjb21pbmcubm9kZSB8fFxuICAgIFNLSVBQRURfVFlQRVMuaGFzKHVwY29taW5nLm5vZGUubm9kZVR5cGUpIHx8XG5cbiAgICB1cGNvbWluZy5zb3VyY2VSYW5nZS5zdGFydCA9PSBzdGFydGluZ1JhbmdlLnN0YXJ0ICYmXG4gICAgdXBjb21pbmcuc291cmNlUmFuZ2UubGVuZ3RoID09IHN0YXJ0aW5nUmFuZ2UubGVuZ3RoXG4gICk7XG59XG5cbi8qKlxuICogc3RlcEludG8gLSBzdGVwIGludG8gdGhlIGN1cnJlbnQgZnVuY3Rpb25cbiAqXG4gKiBDb25jZXB0dWFsbHkgdGhpcyBpcyBlYXN5LCBidXQgZnJvbSBhIHByb2dyYW1taW5nIHN0YW5kcG9pbnQgaXQncyBoYXJkLlxuICogQ29kZSBsaWtlIGBnZXRCYWxhbmNlKG1zZy5zZW5kZXIpYCBtaWdodCBiZSBoaWdobGlnaHRlZCwgYnV0IHRoZXJlIGNvdWxkXG4gKiBiZSBhIG51bWJlciBvZiBkaWZmZXJlbnQgaW50ZXJtZWRpYXRlIHN0ZXBzIChsaWtlIGV2YWx1YXRpbmcgYG1zZy5zZW5kZXJgKVxuICogYmVmb3JlIGBnZXRCYWxhbmNlYCBpcyBzdGVwcGVkIGludG8uIFRoaXMgZnVuY3Rpb24gd2lsbCBzdGVwIGludG8gdGhlIGZpcnN0XG4gKiBmdW5jdGlvbiBhdmFpbGFibGUgKHdoZXJlIGluc3RydWN0aW9uLmp1bXAgPT0gXCJpXCIpLCBpZ25vcmluZyBhbnkgaW50ZXJtZWRpYXRlXG4gKiBzdGVwcyB0aGF0IGZhbGwgd2l0aGluIHRoZSBzYW1lIGNvZGUgcmFuZ2UuIElmIHRoZXJlJ3MgYSBzdGVwIGVuY291bnRlcmVkXG4gKiB0aGF0IGV4aXN0cyBvdXRzaWRlIG9mIHRoZSByYW5nZSwgdGhlbiBzdGVwSW50byB3aWxsIG9ubHkgZXhlY3V0ZSB1bnRpbCB0aGF0XG4gKiBzdGVwLlxuICovXG5mdW5jdGlvbiogc3RlcEludG8gKCkge1xuICBpZiAoeWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC53aWxsSnVtcCkpIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLmlzTXVsdGlsaW5lKSkge1xuICAgIHlpZWxkKiBzdGVwT3ZlcigpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RhcnRpbmdEZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gIGNvbnN0IHN0YXJ0aW5nUmFuZ2UgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLnNvdXJjZVJhbmdlKTtcbiAgdmFyIGN1cnJlbnREZXB0aDtcbiAgdmFyIGN1cnJlbnRSYW5nZTtcblxuICBkbyB7XG4gICAgeWllbGQqIHN0ZXBOZXh0KCk7XG5cbiAgICBjdXJyZW50RGVwdGggPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpO1xuICAgIGN1cnJlbnRSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuXG4gIH0gd2hpbGUgKFxuICAgIC8vIHRoZSBmdW5jdGlvbiBzdGFjayBoYXMgbm90IGluY3JlYXNlZCxcbiAgICBjdXJyZW50RGVwdGggPD0gc3RhcnRpbmdEZXB0aCAmJlxuXG4gICAgLy8gdGhlIGN1cnJlbnQgc291cmNlIHJhbmdlIGJlZ2lucyBvbiBvciBhZnRlciB0aGUgc3RhcnRpbmcgcmFuZ2VcbiAgICBjdXJyZW50UmFuZ2Uuc3RhcnQgPj0gc3RhcnRpbmdSYW5nZS5zdGFydCAmJlxuXG4gICAgLy8gYW5kIHRoZSBjdXJyZW50IHJhbmdlIGVuZHMgb24gb3IgYmVmb3JlIHRoZSBzdGFydGluZyByYW5nZSBlbmRzXG4gICAgKGN1cnJlbnRSYW5nZS5zdGFydCArIGN1cnJlbnRSYW5nZS5sZW5ndGgpIDw9XG4gICAgICAoc3RhcnRpbmdSYW5nZS5zdGFydCArIHN0YXJ0aW5nUmFuZ2UubGVuZ3RoKVxuICApO1xufVxuXG4vKipcbiAqIFN0ZXAgb3V0IG9mIHRoZSBjdXJyZW50IGZ1bmN0aW9uXG4gKlxuICogVGhpcyB3aWxsIHJ1biB1bnRpbCB0aGUgZGVidWdnZXIgZW5jb3VudGVycyBhIGRlY3JlYXNlIGluIGZ1bmN0aW9uIGRlcHRoLlxuICovXG5mdW5jdGlvbiogc3RlcE91dCAoKSB7XG4gIGlmICh5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLmlzTXVsdGlsaW5lKSkge1xuICAgIHlpZWxkICpzdGVwT3ZlcigpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RhcnRpbmdEZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gIHZhciBjdXJyZW50RGVwdGg7XG5cbiAgZG8ge1xuICAgIHlpZWxkKiBzdGVwTmV4dCgpO1xuXG4gICAgY3VycmVudERlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcblxuICB9IHdoaWxlKGN1cnJlbnREZXB0aCA+PSBzdGFydGluZ0RlcHRoKTtcbn1cblxuLyoqXG4gKiBzdGVwT3ZlciAtIHN0ZXAgb3ZlciB0aGUgY3VycmVudCBsaW5lXG4gKlxuICogU3RlcCBvdmVyIHRoZSBjdXJyZW50IGxpbmUuIFRoaXMgd2lsbCBzdGVwIHRvIHRoZSBuZXh0IGluc3RydWN0aW9uIHRoYXRcbiAqIGV4aXN0cyBvbiBhIGRpZmZlcmVudCBsaW5lIG9mIGNvZGUgd2l0aGluIHRoZSBzYW1lIGZ1bmN0aW9uIGRlcHRoLlxuICovXG5mdW5jdGlvbiogc3RlcE92ZXIgKCkge1xuICBjb25zdCBzdGFydGluZ0RlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgY29uc3Qgc3RhcnRpbmdSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuICB2YXIgY3VycmVudERlcHRoO1xuICB2YXIgY3VycmVudFJhbmdlO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIGN1cnJlbnREZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gICAgY3VycmVudFJhbmdlID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5zb3VyY2VSYW5nZSk7XG5cbiAgfSB3aGlsZSAoXG4gICAgLy8ga2VlcCBzdGVwcGluZyBwcm92aWRlZDpcbiAgICAvL1xuICAgIC8vIHdlIGhhdmVuJ3QganVtcGVkIG91dFxuICAgICEoY3VycmVudERlcHRoIDwgc3RhcnRpbmdEZXB0aCkgJiZcblxuICAgIC8vIGVpdGhlcjogZnVuY3Rpb24gZGVwdGggaXMgZ3JlYXRlciB0aGFuIHN0YXJ0aW5nIChpZ25vcmUgZnVuY3Rpb24gY2FsbHMpXG4gICAgLy8gb3IsIGlmIHdlJ3JlIGF0IHRoZSBzYW1lIGRlcHRoLCBrZWVwIHN0ZXBwaW5nIHVudGlsIHdlJ3JlIG9uIGEgbmV3XG4gICAgLy8gbGluZS5cbiAgICAoY3VycmVudERlcHRoID4gc3RhcnRpbmdEZXB0aCB8fFxuICAgICAgY3VycmVudFJhbmdlLmxpbmVzLnN0YXJ0LmxpbmUgPT0gc3RhcnRpbmdSYW5nZS5saW5lcy5zdGFydC5saW5lKVxuICApXG59XG5cbi8qKlxuICogY29udGludWVVbnRpbCAtIHN0ZXAgdGhyb3VnaCBleGVjdXRpb24gdW50aWwgYSBicmVha3BvaW50XG4gKlxuICogQHBhcmFtIGJyZWFrcG9pbnRzIC0gYXJyYXkgb2YgYnJlYWtwb2ludHMgKHsgLi4uY2FsbCwgbGluZSB9KVxuICovXG5mdW5jdGlvbiAqY29udGludWVVbnRpbCAoe2JyZWFrcG9pbnRzfSkge1xuICB2YXIgY3VycmVudENhbGw7XG4gIHZhciBjdXJyZW50TG9jYXRpb247XG5cbiAgbGV0IGJyZWFrcG9pbnRIaXQgPSBmYWxzZTtcblxuICBkbyB7XG4gICAgeWllbGQqIHN0ZXBOZXh0KCk7XG5cbiAgICBjdXJyZW50Q2FsbCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZXhlY3V0aW9uQ29udGV4dCk7XG4gICAgY3VycmVudExvY2F0aW9uID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbik7XG5cbiAgICBicmVha3BvaW50SGl0ID0gYnJlYWtwb2ludHNcbiAgICAgIC5maWx0ZXIoICh7YWRkcmVzcywgYmluYXJ5LCBsaW5lLCBub2RlfSkgPT5cbiAgICAgICAgKFxuICAgICAgICAgIGFkZHJlc3MgPT0gY3VycmVudENhbGwuYWRkcmVzcyB8fFxuICAgICAgICAgIGJpbmFyeSA9PSBjdXJyZW50Q2FsbC5iaW5hcnlcbiAgICAgICAgKSAmJiAoXG4gICAgICAgICAgbGluZSA9PSBjdXJyZW50TG9jYXRpb24uc291cmNlUmFuZ2UubGluZXMuc3RhcnQubGluZSB8fFxuICAgICAgICAgIG5vZGUgPT0gY3VycmVudExvY2F0aW9uLm5vZGUuaWRcbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgLmxlbmd0aCA+IDA7XG5cbiAgfSB3aGlsZSAoIWJyZWFrcG9pbnRIaXQpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9jb250cm9sbGVyL3NhZ2FzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmNvbnRyb2xsZXI6c2FnYXNcIik7XG5cbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yVHJlZSwgY3JlYXRlTGVhZiB9IGZyb20gXCJyZXNlbGVjdC10cmVlXCI7XG5cbmltcG9ydCBldm0gZnJvbSBcImxpYi9ldm0vc2VsZWN0b3JzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcbmltcG9ydCBhc3QgZnJvbSBcImxpYi9hc3Qvc2VsZWN0b3JzXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaWRlbnRpdHkgPSAoeCkgPT4geFxuXG4vKipcbiAqIGNvbnRyb2xsZXJcbiAqL1xuY29uc3QgY29udHJvbGxlciA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG5cbiAgLyoqXG4gICAqIGNvbnRyb2xsZXIuY3VycmVudFxuICAgKi9cbiAgY3VycmVudDoge1xuICAgIC8qKlxuICAgICAqIGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoXG4gICAgICovXG4gICAgZnVuY3Rpb25EZXB0aDogY3JlYXRlTGVhZihbc29saWRpdHkuY3VycmVudC5mdW5jdGlvbkRlcHRoXSwgaWRlbnRpdHkpLFxuXG4gICAgLyoqXG4gICAgICogY29udHJvbGxlci5jdXJyZW50LmV4ZWN1dGlvbkNvbnRleHRcbiAgICAgKi9cbiAgICBleGVjdXRpb25Db250ZXh0OiBjcmVhdGVMZWFmKFtldm0uY3VycmVudC5jYWxsXSwgaWRlbnRpdHkpLFxuXG4gICAgLyoqXG4gICAgICogY29udHJvbGxlci5jdXJyZW50LndpbGxKdW1wXG4gICAgICovXG4gICAgd2lsbEp1bXA6IGNyZWF0ZUxlYWYoW2V2bS5jdXJyZW50LnN0ZXAuaXNKdW1wXSwgaWRlbnRpdHkpLFxuXG4gICAgLyoqXG4gICAgICogY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uXG4gICAgICovXG4gICAgbG9jYXRpb246IHtcbiAgICAgIC8qKlxuICAgICAgICogY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLnNvdXJjZVJhbmdlXG4gICAgICAgKi9cbiAgICAgIHNvdXJjZVJhbmdlOiBjcmVhdGVMZWFmKFtzb2xpZGl0eS5jdXJyZW50LnNvdXJjZVJhbmdlXSwgaWRlbnRpdHkpLFxuXG4gICAgICAvKipcbiAgICAgICAqIGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5ub2RlXG4gICAgICAgKi9cbiAgICAgIG5vZGU6IGNyZWF0ZUxlYWYoW2FzdC5jdXJyZW50Lm5vZGVdLCBpZGVudGl0eSksXG5cbiAgICAgIC8qKlxuICAgICAgICogY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLmlzTXVsdGlsaW5lXG4gICAgICAgKi9cbiAgICAgIGlzTXVsdGlsaW5lOiBjcmVhdGVMZWFmKFtzb2xpZGl0eS5jdXJyZW50LmlzTXVsdGlsaW5lXSwgaWRlbnRpdHkpLFxuICAgIH1cbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRyb2xsZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2NvbnRyb2xsZXIvc2VsZWN0b3JzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNvbGlkaXR5OnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBjYWxsLCBwdXQsIHRha2UsIHNlbGVjdCB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuaW1wb3J0IHsgVElDSyB9IGZyb20gXCJsaWIvdHJhY2UvYWN0aW9uc1wiO1xuXG5pbXBvcnQgc29saWRpdHkgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gKmFkZFNvdXJjZShzb3VyY2UsIHNvdXJjZVBhdGgsIGFzdCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5hZGRTb3VyY2Uoc291cmNlLCBzb3VyY2VQYXRoLCBhc3QpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uICphZGRTb3VyY2VNYXAoYmluYXJ5LCBzb3VyY2VNYXApIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuYWRkU291cmNlTWFwKGJpbmFyeSwgc291cmNlTWFwKSk7XG59XG5cbmZ1bmN0aW9uKiBmdW5jdGlvbkRlcHRoU2FnYSAoKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgeWllbGQgdGFrZShUSUNLKTtcbiAgICBkZWJ1ZyhcImdvdCBUSUNLXCIpO1xuICAgIGxldCBpbnN0cnVjdGlvbiA9IHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50Lmluc3RydWN0aW9uKTtcbiAgICBkZWJ1ZyhcImluc3RydWN0aW9uOiAlb1wiLCBpbnN0cnVjdGlvbik7XG5cbiAgICBpZiAoeWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQud2lsbEp1bXApKSB7XG4gICAgICBsZXQganVtcERpcmVjdGlvbiA9IHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50Lmp1bXBEaXJlY3Rpb24pO1xuXG5cbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmp1bXAoanVtcERpcmVjdGlvbikpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EgKCkge1xuICB5aWVsZCBjYWxsKGZ1bmN0aW9uRGVwdGhTYWdhKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcInNvbGlkaXR5XCIsIHNhZ2EpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zb2xpZGl0eS9zYWdhcy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpldm06c2FnYXNcIik7XG5cbmltcG9ydCB7IGNhbGwsIHB1dCwgdGFrZSwgc2VsZWN0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuaW1wb3J0IHsgcHJlZml4TmFtZSwga2VjY2FrMjU2IH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCB7IFRJQ0sgfSBmcm9tIFwibGliL3RyYWNlL2FjdGlvbnNcIjtcbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cbi8qKlxuICogQWRkcyBFVk0gYnl0ZWNvZGUgY29udGV4dFxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gSUQgKDB4LXByZWZpeGVkIGtlY2NhayBvZiBiaW5hcnkpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAqYWRkQ29udGV4dChjb250cmFjdE5hbWUsIGJpbmFyeSkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5hZGRDb250ZXh0KGNvbnRyYWN0TmFtZSwgYmluYXJ5KSk7XG5cbiAgcmV0dXJuIGtlY2NhazI1NihiaW5hcnkpO1xufVxuXG4vKipcbiAqIEFkZHMga25vd24gZGVwbG95ZWQgaW5zdGFuY2Ugb2YgYmluYXJ5IGF0IGFkZHJlc3NcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEICgweC1wcmVmaXhlZCBrZWNjYWsgb2YgYmluYXJ5KVxuICovXG5leHBvcnQgZnVuY3Rpb24gKmFkZEluc3RhbmNlKGFkZHJlc3MsIGJpbmFyeSkge1xuICBsZXQgc2VhcmNoID0geWllbGQgc2VsZWN0KGV2bS5pbmZvLmJpbmFyaWVzLnNlYXJjaCk7XG4gIGlmIChiaW5hcnkgIT0gXCIweDBcIikge1xuICAgIGxldCB7IGNvbnRleHQgfSA9IHNlYXJjaChiaW5hcnkpO1xuXG4gICAgeWllbGQgcHV0KGFjdGlvbnMuYWRkSW5zdGFuY2UoYWRkcmVzcywgY29udGV4dCwgYmluYXJ5KSk7XG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIGJlZ2luKHsgYWRkcmVzcywgYmluYXJ5IH0pIHtcbiAgaWYgKGFkZHJlc3MpIHtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5jYWxsKGFkZHJlc3MpKTtcbiAgfSBlbHNlIHtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5jcmVhdGUoYmluYXJ5KSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBjYWxsc3RhY2tTYWdhICgpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB5aWVsZCB0YWtlKFRJQ0spO1xuICAgIGRlYnVnKFwiZ290IFRJQ0tcIik7XG5cbiAgICBpZiAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuaXNDYWxsKSkge1xuICAgICAgZGVidWcoXCJnb3QgY2FsbFwiKTtcbiAgICAgIGxldCBhZGRyZXNzID0geWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuY2FsbEFkZHJlc3MpO1xuXG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5jYWxsKGFkZHJlc3MpKTtcblxuICAgIH0gZWxzZSBpZiAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuaXNDcmVhdGUpKSB7XG4gICAgICBkZWJ1ZyhcImdvdCBjcmVhdGVcIik7XG4gICAgICBsZXQgYmluYXJ5ID0geWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuY3JlYXRlQmluYXJ5KTtcblxuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuY3JlYXRlKGJpbmFyeSkpO1xuXG4gICAgfSBlbHNlIGlmICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5pc0hhbHRpbmcpKSB7XG4gICAgICBkZWJ1ZyhcImdvdCByZXR1cm5cIik7XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5yZXR1cm5DYWxsKCkpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EgKCkge1xuICB5aWVsZCBjYWxsKGNhbGxzdGFja1NhZ2EpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwiZXZtXCIsIHNhZ2EpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9ldm0vc2FnYXMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6d2ViMzpzYWdhc1wiKTtcblxuaW1wb3J0IHsgYWxsLCB0YWtlRXZlcnksIGFwcGx5LCBmb3JrLCBqb2luLCB0YWtlLCBwdXQsIHNlbGVjdCB9IGZyb20gJ3JlZHV4LXNhZ2EvZWZmZWN0cyc7XG5pbXBvcnQgeyBwcmVmaXhOYW1lIH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuaW1wb3J0IFdlYjNBZGFwdGVyIGZyb20gXCIuLi9hZGFwdGVyXCI7XG5cbmZ1bmN0aW9uKiBmZXRjaFRyYW5zYWN0aW9uSW5mbyhhZGFwdGVyLCB7dHhIYXNofSkge1xuICBkZWJ1ZyhcImluc3BlY3RpbmcgdHJhbnNhY3Rpb25cIik7XG4gIHZhciB0cmFjZTtcbiAgdHJ5IHtcbiAgICB0cmFjZSA9IHlpZWxkIGFwcGx5KGFkYXB0ZXIsIGFkYXB0ZXIuZ2V0VHJhY2UsIFt0eEhhc2hdKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgZGVidWcoXCJwdXR0aW5nIGVycm9yXCIpO1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmVycm9yKGUpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBkZWJ1ZyhcImdvdCB0cmFjZVwiKTtcbiAgeWllbGQgcHV0KGFjdGlvbnMucmVjZWl2ZVRyYWNlKHRyYWNlKSk7XG5cbiAgbGV0IHR4ID0geWllbGQgYXBwbHkoYWRhcHRlciwgYWRhcHRlci5nZXRUcmFuc2FjdGlvbiwgW3R4SGFzaF0pO1xuICBpZiAodHgudG8gJiYgdHgudG8gIT0gXCIweDBcIikge1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLnJlY2VpdmVDYWxsKHthZGRyZXNzOiB0eC50b30pKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgcmVjZWlwdCA9IHlpZWxkIGFwcGx5KGFkYXB0ZXIsIGFkYXB0ZXIuZ2V0UmVjZWlwdCwgW3R4SGFzaF0pO1xuICBpZiAocmVjZWlwdC5jb250cmFjdEFkZHJlc3MpIHtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlQ2FsbCh7YmluYXJ5OiB0eC5pbnB1dH0pKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgXCJDb3VsZCBub3QgZmluZCBjb250cmFjdCBhc3NvY2lhdGVkIHdpdGggdHJhbnNhY3Rpb24uIFwiICtcbiAgICBcIlBsZWFzZSBtYWtlIHN1cmUgeW91J3JlIGRlYnVnZ2luZyBhIHRyYW5zYWN0aW9uIHRoYXQgZXhlY3V0ZXMgYSBcIiArXG4gICAgXCJjb250cmFjdCBmdW5jdGlvbiBvciBjcmVhdGVzIGEgbmV3IGNvbnRyYWN0LlwiXG4gICk7XG59XG5cbmZ1bmN0aW9uKiBmZXRjaEJpbmFyeShhZGFwdGVyLCB7YWRkcmVzc30pIHtcbiAgZGVidWcoXCJmZXRjaGluZyBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuICBsZXQgYmluYXJ5ID0geWllbGQgYXBwbHkoYWRhcHRlciwgYWRhcHRlci5nZXREZXBsb3llZENvZGUsIFthZGRyZXNzXSk7XG5cbiAgZGVidWcoXCJyZWNlaXZlZCBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlQmluYXJ5KGFkZHJlc3MsIGJpbmFyeSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gKmluc3BlY3RUcmFuc2FjdGlvbih0eEhhc2gsIHByb3ZpZGVyKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmluaXQocHJvdmlkZXIpKTtcbiAgeWllbGQgcHV0KGFjdGlvbnMuaW5zcGVjdCh0eEhhc2gpKTtcblxuICBsZXQgYWN0aW9uID0geWllbGQgdGFrZSggKHt0eXBlfSkgPT5cbiAgICB0eXBlID09IGFjdGlvbnMuUkVDRUlWRV9UUkFDRSB8fCB0eXBlID09IGFjdGlvbnMuRVJST1JfV0VCM1xuICApO1xuICBkZWJ1ZyhcImFjdGlvbiAlb1wiLCBhY3Rpb24pO1xuXG4gIHZhciB0cmFjZTtcbiAgaWYgKGFjdGlvbi50eXBlID09IGFjdGlvbnMuUkVDRUlWRV9UUkFDRSkge1xuICAgIHRyYWNlID0gYWN0aW9uLnRyYWNlO1xuICAgIGRlYnVnKFwicmVjZWl2ZWQgdHJhY2VcIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGFjdGlvbi5lcnJvciB9O1xuICB9XG5cbiAgbGV0IHthZGRyZXNzLCBiaW5hcnl9ID0geWllbGQgdGFrZShhY3Rpb25zLlJFQ0VJVkVfQ0FMTCk7XG4gIGRlYnVnKFwicmVjZWl2ZWQgY2FsbFwiKTtcblxuICByZXR1cm4geyB0cmFjZSwgYWRkcmVzcywgYmluYXJ5IH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAqb2J0YWluQmluYXJpZXMoYWRkcmVzc2VzKSB7XG4gIGxldCB0YXNrcyA9IHlpZWxkIGFsbChcbiAgICBhZGRyZXNzZXMubWFwKCAoYWRkcmVzcykgPT4gZm9yayhyZWNlaXZlQmluYXJ5LCBhZGRyZXNzKSApXG4gICk7XG5cbiAgZGVidWcoXCJyZXF1ZXN0aW5nIGJpbmFyaWVzXCIpO1xuICB5aWVsZCBhbGwoXG4gICAgYWRkcmVzc2VzLm1hcCggKGFkZHJlc3MpID0+IHB1dChhY3Rpb25zLmZldGNoQmluYXJ5KGFkZHJlc3MpKSApXG4gICk7XG5cbiAgbGV0IGJpbmFyaWVzID0gW107XG4gIGJpbmFyaWVzID0geWllbGQgYWxsKFxuICAgIHRhc2tzLm1hcCh0YXNrID0+IGpvaW4odGFzaykpXG4gICk7XG5cbiAgZGVidWcoXCJiaW5hcmllcyAlb1wiLCBiaW5hcmllcyk7XG5cbiAgcmV0dXJuIGJpbmFyaWVzO1xufVxuXG5mdW5jdGlvbiAqcmVjZWl2ZUJpbmFyeShhZGRyZXNzKSB7XG4gIGxldCB7YmluYXJ5fSA9IHlpZWxkIHRha2UoKGFjdGlvbikgPT4gKFxuICAgIGFjdGlvbi50eXBlID09IGFjdGlvbnMuUkVDRUlWRV9CSU5BUlkgJiZcbiAgICBhY3Rpb24uYWRkcmVzcyA9PSBhZGRyZXNzXG4gICkpO1xuICBkZWJ1ZyhcImdvdCBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuXG4gIHJldHVybiBiaW5hcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgLy8gd2FpdCBmb3Igd2ViMyBpbml0IHNpZ25hbFxuICBsZXQge3Byb3ZpZGVyfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5JTklUX1dFQjMpO1xuICBsZXQgYWRhcHRlciA9IG5ldyBXZWIzQWRhcHRlcihwcm92aWRlcik7XG5cbiAgeWllbGQgdGFrZUV2ZXJ5KGFjdGlvbnMuSU5TUEVDVCwgZmV0Y2hUcmFuc2FjdGlvbkluZm8sIGFkYXB0ZXIpO1xuICB5aWVsZCB0YWtlRXZlcnkoYWN0aW9ucy5GRVRDSF9CSU5BUlksIGZldGNoQmluYXJ5LCBhZGFwdGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcIndlYjNcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3dlYjMvc2FnYXMvaW5kZXguanMiLCJleHBvcnQgY29uc3QgSU5JVF9XRUIzID0gXCJJTklUX1dFQjNcIjtcbmV4cG9ydCBmdW5jdGlvbiBpbml0KHByb3ZpZGVyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogSU5JVF9XRUIzLFxuICAgIHByb3ZpZGVyXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IElOU1BFQ1QgPSBcIklOU1BFQ1RfVFJBTlNBQ1RJT05cIjtcbmV4cG9ydCBmdW5jdGlvbiBpbnNwZWN0KHR4SGFzaCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IElOU1BFQ1QsXG4gICAgdHhIYXNoXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEZFVENIX0JJTkFSWSA9IFwiRkVUQ0hfQklOQVJZXCI7XG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hCaW5hcnkoYWRkcmVzcykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEZFVENIX0JJTkFSWSxcbiAgICBhZGRyZXNzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRUNFSVZFX0JJTkFSWSA9IFwiUkVDRUlWRV9CSU5BUllcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWNlaXZlQmluYXJ5KGFkZHJlc3MsIGJpbmFyeSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFQ0VJVkVfQklOQVJZLFxuICAgIGFkZHJlc3MsIGJpbmFyeVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBSRUNFSVZFX1RSQUNFID0gXCJSRUNFSVZFX1RSQUNFXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVjZWl2ZVRyYWNlKHRyYWNlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDRUlWRV9UUkFDRSxcbiAgICB0cmFjZVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBSRUNFSVZFX0NBTEwgPSBcIlJFQ0VJVkVfQ0FMTFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlY2VpdmVDYWxsKHthZGRyZXNzLCBiaW5hcnl9KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDRUlWRV9DQUxMLFxuICAgIGFkZHJlc3MsIGJpbmFyeVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBFUlJPUl9XRUIzID0gXCJFUlJPUl9XRUIzXCI7XG5leHBvcnQgZnVuY3Rpb24gZXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBFUlJPUl9XRUIzLFxuICAgIGVycm9yXG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3dlYjMvYWN0aW9ucy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcblxuaW1wb3J0IFdlYjMgZnJvbSBcIndlYjNcIjtcblxuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOndlYjM6YWRhcHRlclwiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViM0FkYXB0ZXIge1xuICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgIHRoaXMud2ViMyA9IG5ldyBXZWIzKHByb3ZpZGVyKTtcbiAgfVxuXG4gIGFzeW5jIGdldFRyYWNlKHR4SGFzaCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSggKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLndlYjMuY3VycmVudFByb3ZpZGVyLnNlbmQoe1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBtZXRob2Q6IFwiZGVidWdfdHJhY2VUcmFuc2FjdGlvblwiLFxuICAgICAgICBwYXJhbXM6IFt0eEhhc2gsIHt9XSxcbiAgICAgICAgaWQ6IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICB9LCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICBpZiAocmVzdWx0LmVycm9yKSByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSkpO1xuICAgICAgICBkZWJ1ZyhcInJlc3VsdDogJW9cIiwgcmVzdWx0KTtcbiAgICAgICAgYWNjZXB0KHJlc3VsdC5yZXN1bHQuc3RydWN0TG9ncyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBhc3luYyBnZXRUcmFuc2FjdGlvbih0eEhhc2gpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoIChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy53ZWIzLmV0aC5nZXRUcmFuc2FjdGlvbih0eEhhc2gsIChlcnIsIHR4KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcblxuICAgICAgICByZXR1cm4gYWNjZXB0KHR4KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGFzeW5jIGdldFJlY2VpcHQodHhIYXNoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCAoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMud2ViMy5ldGguZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCwgKGVyciwgcmVjZWlwdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG5cbiAgICAgICAgcmV0dXJuIGFjY2VwdChyZWNlaXB0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBnZXREZXBsb3llZENvZGUgLSBnZXQgdGhlIGRlcGxveWVkIGNvZGUgZm9yIGFuIGFkZHJlc3MgZnJvbSB0aGUgY2xpZW50XG4gICAqIEBwYXJhbSAge1N0cmluZ30gYWRkcmVzc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgZGVwbG95ZWRCaW5hcnlcbiAgICovXG4gIGFzeW5jIGdldERlcGxveWVkQ29kZShhZGRyZXNzKSB7XG4gICAgZGVidWcoXCJnZXR0aW5nIGRlcGxveWVkIGNvZGUgZm9yICVzXCIsIGFkZHJlc3MpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMud2ViMy5ldGguZ2V0Q29kZShhZGRyZXNzLCAoZXJyLCBkZXBsb3llZEJpbmFyeSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSBkZWJ1ZyhcImVycm9yOiAlb1wiLCBlcnIpO1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIGRlYnVnKFwiZ290IGRlcGxveWVkIGNvZGUgZm9yICVzXCIsIGFkZHJlc3MpO1xuICAgICAgICBhY2NlcHQoZGVwbG95ZWRCaW5hcnkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3dlYjMvYWRhcHRlci5qcyIsImltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gXCJyZWR1eFwiO1xuXG5pbXBvcnQgZGF0YSBmcm9tIFwibGliL2RhdGEvcmVkdWNlcnNcIjtcbmltcG9ydCBldm0gZnJvbSBcImxpYi9ldm0vcmVkdWNlcnNcIjtcbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3JlZHVjZXJzXCI7XG5pbXBvcnQgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9yZWR1Y2Vyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuZXhwb3J0IGNvbnN0IFdBSVRJTkcgPSBcIldBSVRJTkdcIjtcbmV4cG9ydCBjb25zdCBBQ1RJVkUgPSBcIkFDVElWRVwiO1xuZXhwb3J0IGNvbnN0IEVSUk9SID0gXCJFUlJPUlwiO1xuZXhwb3J0IGNvbnN0IEZJTklTSEVEID0gXCJGSU5JU0hFRFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gc2Vzc2lvbihzdGF0ZSA9IFdBSVRJTkcsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlJFQURZOlxuICAgICAgcmV0dXJuIEFDVElWRTtcblxuICAgIGNhc2UgYWN0aW9ucy5FUlJPUjpcbiAgICAgIHJldHVybiB7IGVycm9yOiBhY3Rpb24uZXJyb3IgfTtcblxuICAgIGNhc2UgYWN0aW9ucy5GSU5JU0g6XG4gICAgICByZXR1cm4gRklOSVNIRUQ7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IHJlZHVjZVN0YXRlID0gY29tYmluZVJlZHVjZXJzKHtcbiAgc2Vzc2lvbixcbiAgZGF0YSxcbiAgZXZtLFxuICBzb2xpZGl0eSxcbiAgdHJhY2UsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlU3RhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3Nlc3Npb24vcmVkdWNlcnMuanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZGF0YTpyZWR1Y2Vyc1wiKTtcblxuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuXG5jb25zdCBERUZBVUxUX1NDT1BFUyA9IHtcbiAgYnlJZDoge31cbn07XG5cbmZ1bmN0aW9uIHNjb3BlcyhzdGF0ZSA9IERFRkFVTFRfU0NPUEVTLCBhY3Rpb24pIHtcbiAgdmFyIGNvbnRleHQ7XG4gIHZhciBzY29wZTtcbiAgdmFyIHZhcmlhYmxlcztcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlNDT1BFOlxuICAgICAgc2NvcGUgPSBzdGF0ZS5ieUlkW2FjdGlvbi5pZF0gfHwge307XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5SWQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUlkLFxuXG4gICAgICAgICAgW2FjdGlvbi5pZF06IHtcbiAgICAgICAgICAgIC4uLnNjb3BlLFxuXG4gICAgICAgICAgICBpZDogYWN0aW9uLmlkLFxuICAgICAgICAgICAgc291cmNlSWQ6IGFjdGlvbi5zb3VyY2VJZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBhY3Rpb24ucGFyZW50SWQsXG4gICAgICAgICAgICBwb2ludGVyOiBhY3Rpb24ucG9pbnRlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgY2FzZSBhY3Rpb25zLkRFQ0xBUkU6XG4gICAgICBzY29wZSA9IHN0YXRlLmJ5SWRbYWN0aW9uLm5vZGUuc2NvcGVdIHx8IHt9O1xuICAgICAgdmFyaWFibGVzID0gc2NvcGUudmFyaWFibGVzIHx8IFtdO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBieUlkOiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlJZCxcblxuICAgICAgICAgIFthY3Rpb24ubm9kZS5zY29wZV06IHtcbiAgICAgICAgICAgIC4uLnNjb3BlLFxuXG4gICAgICAgICAgICB2YXJpYWJsZXM6IFtcbiAgICAgICAgICAgICAgLi4udmFyaWFibGVzLFxuXG4gICAgICAgICAgICAgIHtuYW1lOiBhY3Rpb24ubm9kZS5uYW1lLCBpZDogYWN0aW9uLm5vZGUuaWR9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IGluZm8gPSBjb21iaW5lUmVkdWNlcnMoe1xuICBzY29wZXNcbn0pO1xuXG5jb25zdCBERUZBVUxUX0FTU0lHTk1FTlRTID0ge1xuICBieUlkOiB7fVxufTtcblxuZnVuY3Rpb24gYXNzaWdubWVudHMoc3RhdGUgPSBERUZBVUxUX0FTU0lHTk1FTlRTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5BU1NJR046XG4gICAgICByZXR1cm4ge1xuICAgICAgICBieUlkOiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlJZCxcblxuICAgICAgICAgIC4uLk9iamVjdC5hc3NpZ24oe30sXG4gICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhhY3Rpb24uYXNzaWdubWVudHMpLm1hcChcbiAgICAgICAgICAgICAgKFtpZCwgcmVmXSkgPT4gKHtcbiAgICAgICAgICAgICAgICBbaWRdOiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZS5ieUlkW2lkXSxcbiAgICAgICAgICAgICAgICAgIHJlZlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59O1xuXG5jb25zdCBwcm9jID0gY29tYmluZVJlZHVjZXJzKHtcbiAgYXNzaWdubWVudHNcbn0pO1xuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgaW5mbyxcbiAgcHJvY1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvcmVkdWNlcnMuanMiLCJpbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuY29uc3QgREVGQVVMVF9DT05URVhUUyA9IHtcbiAgYnlDb250ZXh0OiB7fSxcbiAgYnlCaW5hcnk6IHt9XG59O1xuXG5mdW5jdGlvbiBjb250ZXh0cyhzdGF0ZSA9IERFRkFVTFRfQ09OVEVYVFMsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgLypcbiAgICAgKiBBZGRpbmcgYSBuZXcgY29udGV4dFxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfQ09OVEVYVDpcbiAgICAgIGxldCB7IGNvbnRyYWN0TmFtZSwgYmluYXJ5IH0gPSBhY3Rpb247XG5cbiAgICAgIGlmIChzdGF0ZS5ieUJpbmFyeVtiaW5hcnldKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGNvbnRleHQgPSBrZWNjYWsyNTYoYmluYXJ5KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlDb250ZXh0OiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlDb250ZXh0LFxuXG4gICAgICAgICAgW2NvbnRleHRdOiB7IGNvbnRleHQsIGJpbmFyeSwgY29udHJhY3ROYW1lIH1cbiAgICAgICAgfSxcblxuICAgICAgICBieUJpbmFyeToge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5QmluYXJ5LFxuXG4gICAgICAgICAgW2JpbmFyeV06IHsgY29udGV4dDogY29udGV4dCB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAvKlxuICAgICAqIERlZmF1bHQgY2FzZVxuICAgICAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9JTlNUQU5DRVMgPSB7XG4gIGJ5QWRkcmVzczoge30sXG4gIGJ5Q29udGV4dDoge31cbn1cblxuZnVuY3Rpb24gaW5zdGFuY2VzKHN0YXRlID0gREVGQVVMVF9JTlNUQU5DRVMsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgLypcbiAgICAgKiBBZGRpbmcgYSBuZXcgYWRkcmVzcyBmb3IgY29udGV4dFxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfSU5TVEFOQ0U6XG4gICAgICBsZXQgeyBhZGRyZXNzLCBjb250ZXh0LCBiaW5hcnkgfSA9IGFjdGlvbjtcblxuICAgICAgLy8gZ2V0IGtub3duIGFkZHJlc3NlcyBmb3IgdGhpcyBjb250ZXh0XG4gICAgICBsZXQgb3RoZXJJbnN0YW5jZXMgPSBzdGF0ZS5ieUNvbnRleHRbY29udGV4dF0gfHwgW107XG4gICAgICBsZXQgb3RoZXJBZGRyZXNzZXMgPSBvdGhlckluc3RhbmNlcy5tYXAoKHthZGRyZXNzfSkgPT4gYWRkcmVzcyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5QWRkcmVzczoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5QWRkcmVzcyxcblxuICAgICAgICAgIFthZGRyZXNzXTogeyBjb250ZXh0LCBiaW5hcnkgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJ5Q29udGV4dDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5Q29udGV4dCxcblxuICAgICAgICAgIC8vIHJlY29uc3RydWN0IGNvbnRleHQgaW5zdGFuY2VzIHRvIGluY2x1ZGUgbmV3IGFkZHJlc3NcbiAgICAgICAgICBbY29udGV4dF06IEFycmF5LmZyb20obmV3IFNldChvdGhlckFkZHJlc3NlcykuYWRkKGFkZHJlc3MpKVxuICAgICAgICAgICAgLm1hcCgoYWRkcmVzcykgPT4gKHthZGRyZXNzfSkpXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAvKlxuICAgICAqIERlZmF1bHQgY2FzZVxuICAgICAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxufVxuXG5jb25zdCBpbmZvID0gY29tYmluZVJlZHVjZXJzKHtcbiAgY29udGV4dHMsXG4gIGluc3RhbmNlc1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsc3RhY2soc3RhdGUgPSBbXSwgYWN0aW9uKSB7XG4gIHN3aXRjaChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5DQUxMOlxuICAgICAgbGV0IGFkZHJlc3MgPSBhY3Rpb24uYWRkcmVzcztcbiAgICAgIHJldHVybiBzdGF0ZS5jb25jYXQoWyB7YWRkcmVzc30gXSk7XG5cbiAgICBjYXNlIGFjdGlvbnMuQ1JFQVRFOlxuICAgICAgY29uc3QgYmluYXJ5ID0gYWN0aW9uLmJpbmFyeTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb25jYXQoWyB7YmluYXJ5fSBdKTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVRVUk46XG4gICAgICByZXR1cm4gc3RhdGUuc2xpY2UoMCwgLTEpOyAvLyBwb3BcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH07XG59XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBjYWxsc3RhY2tcbn0pO1xuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgaW5mbyxcbiAgcHJvY1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2V2bS9yZWR1Y2Vycy5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb21cIlxuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuY29uc3QgREVGQVVMVF9TT1VSQ0VTID0ge1xuICBieUlkOiB7fVxufTtcblxuZnVuY3Rpb24gc291cmNlcyhzdGF0ZSA9IERFRkFVTFRfU09VUkNFUywgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAvKlxuICAgICAqIEFkZGluZyBhIG5ldyBzb3VyY2VcbiAgICAgKi9cbiAgICBjYXNlIGFjdGlvbnMuQUREX1NPVVJDRTpcbiAgICAgIGxldCB7IGFzdCwgc291cmNlLCBzb3VyY2VQYXRoIH0gPSBhY3Rpb247XG5cbiAgICAgIGxldCBpZCA9IE9iamVjdC5rZXlzKHN0YXRlLmJ5SWQpLmxlbmd0aDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlJZDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5SWQsXG5cbiAgICAgICAgICBbaWRdOiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGFzdCxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHNvdXJjZVBhdGhcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8qXG4gICAgICogRGVmYXVsdCBjYXNlXG4gICAgICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5cbmNvbnN0IERFRkFVTFRfU09VUkNFTUFQUyA9IHtcbiAgYnlDb250ZXh0OiB7fVxufTtcblxuZnVuY3Rpb24gc291cmNlTWFwcyhzdGF0ZSA9IERFRkFVTFRfU09VUkNFTUFQUywgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAvKlxuICAgICAqIEFkZGluZyBhIG5ldyBzb3VyY2VNYXBcbiAgICAgKi9cbiAgICBjYXNlIGFjdGlvbnMuQUREX1NPVVJDRU1BUDpcbiAgICAgIGxldCB7IGJpbmFyeSwgc291cmNlTWFwIH0gPSBhY3Rpb247XG4gICAgICBsZXQgY29udGV4dCA9IGtlY2NhazI1NihiaW5hcnkpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBieUNvbnRleHQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUNvbnRleHQsXG5cbiAgICAgICAgICBbY29udGV4dF06IHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBzb3VyY2VNYXBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAvKlxuICAgICAqIERlZmF1bHQgQ2FzZVxuICAgICAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgaW5mbyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHNvdXJjZXMsXG4gIHNvdXJjZU1hcHNcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gZnVuY3Rpb25EZXB0aChzdGF0ZSA9IDEsIGFjdGlvbikge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuSlVNUCkge1xuICAgIGNvbnN0IGRlbHRhID0gc3BlbHVuayhhY3Rpb24uanVtcERpcmVjdGlvbilcbiAgICByZXR1cm4gc3RhdGUgKyBkZWx0YTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3BlbHVuayhqdW1wKSB7XG4gIGlmIChqdW1wID09IFwiaVwiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoanVtcCA9PSBcIm9cIikge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG5jb25zdCBwcm9jID0gY29tYmluZVJlZHVjZXJzKHtcbiAgZnVuY3Rpb25EZXB0aFxufSk7XG5cbmNvbnN0IHJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBpbmZvLFxuICBwcm9jXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc29saWRpdHkvcmVkdWNlcnMuanMiLCJpbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmRleChzdGF0ZSA9IDAsIGFjdGlvbikge1xuICBpZiAoYWN0aW9uLnR5cGUgPT0gYWN0aW9ucy5UT0NLIHx8IGFjdGlvbi50eXBlID09IGFjdGlvbnMuRU5EX09GX1RSQUNFKSB7XG4gICAgcmV0dXJuIHN0YXRlICsgMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBzKHN0YXRlID0gbnVsbCwgYWN0aW9uKSB7XG4gIGlmIChhY3Rpb24udHlwZSA9PSBhY3Rpb25zLlNBVkVfU1RFUFMpIHtcbiAgICByZXR1cm4gYWN0aW9uLnN0ZXBzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBpbmZvID0gY29tYmluZVJlZHVjZXJzKHtcbiAgc3RlcHNcbn0pXG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBpbmRleFxufSlcblxuY29uc3QgcmVkdWNlciA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGluZm8sXG4gIHByb2Ncbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZWR1Y2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi90cmFjZS9yZWR1Y2Vycy5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJ0ZXN0OmNvbnRleHRcIik7XG5cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCJjaGFpXCI7XG5cbmltcG9ydCBHYW5hY2hlIGZyb20gXCJnYW5hY2hlLWNsaVwiO1xuaW1wb3J0IFdlYjMgZnJvbSBcIndlYjNcIjtcblxuaW1wb3J0IHsgcHJlcGFyZUNvbnRyYWN0cyB9IGZyb20gXCIuL2hlbHBlcnNcIjtcbmltcG9ydCBEZWJ1Z2dlciBmcm9tIFwibGliL2RlYnVnZ2VyXCI7XG5cbmltcG9ydCBzZXNzaW9uU2VsZWN0b3IgZnJvbSBcImxpYi9zZXNzaW9uL3NlbGVjdG9yc1wiO1xuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2VsZWN0b3JzXCI7XG5cbmNvbnN0IF9fT1VURVIgPSBgXG5wcmFnbWEgc29saWRpdHkgXjAuNC4xODtcblxuaW1wb3J0IFwiLi9Jbm5lckNvbnRyYWN0LnNvbFwiO1xuXG5jb250cmFjdCBPdXRlckNvbnRyYWN0IHtcbiAgZXZlbnQgT3V0ZXIoKTtcblxuICBJbm5lckNvbnRyYWN0IGlubmVyO1xuXG4gIGZ1bmN0aW9uIE91dGVyQ29udHJhY3QoYWRkcmVzcyBfaW5uZXIpIHB1YmxpYyB7XG4gICAgaW5uZXIgPSBJbm5lckNvbnRyYWN0KF9pbm5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBydW4oKSBwdWJsaWMge1xuICAgIGlubmVyLnJ1bigpO1xuXG4gICAgT3V0ZXIoKTtcbiAgfVxufVxuYDtcblxuY29uc3QgX19JTk5FUiA9IGBcbnByYWdtYSBzb2xpZGl0eSBeMC40LjE4O1xuXG5jb250cmFjdCBJbm5lckNvbnRyYWN0IHtcbiAgZXZlbnQgSW5uZXIoKTtcblxuICBmdW5jdGlvbiBydW4oKSBwdWJsaWMge1xuICAgIElubmVyKCk7XG4gIH1cbn1cbmA7XG5cbmNvbnN0IF9fTUlHUkFUSU9OID0gYFxubGV0IE91dGVyQ29udHJhY3QgPSBhcnRpZmFjdHMucmVxdWlyZShcIk91dGVyQ29udHJhY3RcIik7XG5sZXQgSW5uZXJDb250cmFjdCA9IGFydGlmYWN0cy5yZXF1aXJlKFwiSW5uZXJDb250cmFjdFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkZXBsb3llcikge1xuICByZXR1cm4gZGVwbG95ZXJcbiAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkZXBsb3llci5kZXBsb3koSW5uZXJDb250cmFjdCk7XG4gICAgfSlcbiAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJbm5lckNvbnRyYWN0LmRlcGxveWVkKCk7XG4gICAgfSlcbiAgICAudGhlbihmdW5jdGlvbihpbm5lcikge1xuICAgICAgcmV0dXJuIGRlcGxveWVyLmRlcGxveShPdXRlckNvbnRyYWN0LCBpbm5lci5hZGRyZXNzKTtcbiAgICB9KTtcbn07XG5gO1xuXG5sZXQgbWlncmF0aW9ucyA9IHtcbiAgXCIyX2RlcGxveV9jb250cmFjdHMuanNcIjogX19NSUdSQVRJT04sXG59O1xuXG5sZXQgc291cmNlcyA9IHtcbiAgXCJPdXRlckxpYnJhcnkuc29sXCI6IF9fT1VURVIsXG4gIFwiSW5uZXJDb250cmFjdC5zb2xcIjogX19JTk5FUixcbn07XG5cblxuZGVzY3JpYmUoXCJDb250ZXh0c1wiLCBmdW5jdGlvbiAoKSB7XG4gIHZhciBwcm92aWRlcjtcbiAgdmFyIHdlYjM7XG5cbiAgdmFyIGFic3RyYWN0aW9ucztcbiAgdmFyIGFydGlmYWN0cztcblxuICBiZWZvcmUoXCJDcmVhdGUgUHJvdmlkZXJcIiwgYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgcHJvdmlkZXIgPSBHYW5hY2hlLnByb3ZpZGVyKHtzZWVkOiBcImRlYnVnZ2VyXCIsIGdhc0xpbWl0OiA3MDAwMDAwfSk7XG4gICAgd2ViMyA9IG5ldyBXZWIzKHByb3ZpZGVyKTtcbiAgfSk7XG5cbiAgYmVmb3JlKFwiUHJlcGFyZSBjb250cmFjdHMgYW5kIGFydGlmYWN0c1wiLCBhc3luYyBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRpbWVvdXQoMzAwMDApO1xuXG4gICAgbGV0IHByZXBhcmVkID0gYXdhaXQgcHJlcGFyZUNvbnRyYWN0cyhwcm92aWRlciwgc291cmNlcywgbWlncmF0aW9ucyk7XG4gICAgYWJzdHJhY3Rpb25zID0gcHJlcGFyZWQuYWJzdHJhY3Rpb25zO1xuICAgIGFydGlmYWN0cyA9IHByZXBhcmVkLmFydGlmYWN0cztcbiAgfSk7XG5cbiAgaXQoXCJyZXR1cm5zIHZpZXcgb2YgYWRkcmVzc2VzIGFmZmVjdGVkXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgb3V0ZXIgPSBhd2FpdCBhYnN0cmFjdGlvbnMuT3V0ZXJDb250cmFjdC5kZXBsb3llZCgpO1xuICAgIGxldCBpbm5lciA9IGF3YWl0IGFic3RyYWN0aW9ucy5Jbm5lckNvbnRyYWN0LmRlcGxveWVkKCk7XG5cbiAgICAvLyBydW4gb3V0ZXIgY29udHJhY3QgbWV0aG9kXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IG91dGVyLnJ1bigpO1xuXG4gICAgYXNzZXJ0LmVxdWFsKDIsIHJlc3VsdC5yZWNlaXB0LmxvZ3MubGVuZ3RoLCBcIlRoZXJlIHNob3VsZCBiZSB0d28gbG9nc1wiKTtcblxuICAgIGxldCB0eEhhc2ggPSByZXN1bHQudHg7XG5cbiAgICBsZXQgYnVnZ2VyID0gYXdhaXQgRGVidWdnZXIuZm9yVHgodHhIYXNoLCB7XG4gICAgICBwcm92aWRlcixcbiAgICAgIGNvbnRyYWN0czogYXJ0aWZhY3RzXG4gICAgfSk7XG4gICAgZGVidWcoXCJkZWJ1Z2dlciByZWFkeVwiKTtcblxuICAgIGxldCBzZXNzaW9uID0gYnVnZ2VyLmNvbm5lY3QoKTtcblxuICAgIGxldCBhZmZlY3RlZEluc3RhbmNlcyA9IHNlc3Npb24udmlldyhzZXNzaW9uU2VsZWN0b3IuaW5mby5hZmZlY3RlZEluc3RhbmNlcyk7XG4gICAgZGVidWcoXCJhZmZlY3RlZEluc3RhbmNlczogJW9cIiwgYWZmZWN0ZWRJbnN0YW5jZXMpO1xuXG4gICAgbGV0IGFmZmVjdGVkQWRkcmVzc2VzID0gT2JqZWN0LmtleXMoYWZmZWN0ZWRJbnN0YW5jZXMpLm1hcChhZGRyZXNzID0+IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG5cbiAgICBhc3NlcnQuZXF1YWwoMiwgYWZmZWN0ZWRBZGRyZXNzZXMubGVuZ3RoKTtcblxuICAgIGFzc2VydC5pbmNsdWRlKFxuICAgICAgYWZmZWN0ZWRBZGRyZXNzZXMsIG91dGVyLmFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICAgIFwiT3V0ZXJDb250cmFjdCBzaG91bGQgYmUgYW4gYWZmZWN0ZWQgYWRkcmVzc1wiXG4gICAgKTtcblxuICAgIGFzc2VydC5pbmNsdWRlKFxuICAgICAgYWZmZWN0ZWRBZGRyZXNzZXMsIGlubmVyLmFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICAgIFwiSW5uZXJDb250cmFjdCBzaG91bGQgYmUgYW4gYWZmZWN0ZWQgYWRkcmVzc1wiXG4gICAgKTtcbiAgfSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB0ZXN0L2NvbnRleHQuanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwidGVzdDpkYXRhOmRlY29kZVwiKTtcblxuaW1wb3J0IGZha2VyIGZyb20gXCJmYWtlclwiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3NlbGVjdG9yc1wiO1xuXG5pbXBvcnQge1xuICBnZW5lcmF0ZVVpbnRzLCBkZXNjcmliZURlY29kaW5nXG59IGZyb20gXCIuL2hlbHBlcnNcIjtcblxuXG5jb25zdCB1aW50cyA9IGdlbmVyYXRlVWludHMoKTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVBcnJheShsZW5ndGgpIHtcbiAgcmV0dXJuIFsuLi5BcnJheShsZW5ndGgpXVxuICAgIC5tYXAoKCkgPT4gdWludHMubmV4dCgpLnZhbHVlKVxufVxuXG5jb25zdCBjb21tb25GaXh0dXJlcyA9IFt7XG4gIG5hbWU6IFwibXVsdGlwbGVGdWxsV29yZEFycmF5XCIsXG4gIHR5cGU6IFwidWludFtdXCIsXG4gIHZhbHVlOiBnZW5lcmF0ZUFycmF5KDMpICAvLyB0YWtlcyB1cCAzIHdob2xlIHdvcmRzXG59LCB7XG4gIG5hbWU6IFwid2l0aGluV29yZEFycmF5XCIsXG4gIHR5cGU6IFwidWludDE2W11cIixcbiAgdmFsdWU6IGdlbmVyYXRlQXJyYXkoMTApICAvLyB0YWtlcyB1cCA+MS8yIHdvcmRcbn0sIHtcbiAgbmFtZTogXCJtdWx0aXBsZVBhcnRXb3JkQXJyYXlcIixcbiAgdHlwZTogXCJ1aW50NjRbXVwiLFxuICB2YWx1ZTogZ2VuZXJhdGVBcnJheSg5KSAgLy8gdGFrZXMgdXAgMi4yNSB3b3Jkc1xufSwge1xuICBuYW1lOiBcImluY29udmVuaWVudGx5V29yZE9mZnNldEFycmF5XCIsXG4gIHR5cGU6IFwidWludDI0MFtdXCIsXG4gIHZhbHVlOiBnZW5lcmF0ZUFycmF5KDMpICAvLyB0YWtlcyB1cCB+Mi44IHdvcmRzXG59LCB7XG4gIG5hbWU6IFwic2hvcnRTdHJpbmdcIixcbiAgdHlwZTogXCJzdHJpbmdcIixcbiAgdmFsdWU6IFwiaGVsbG8gd29ybGRcIlxufSwge1xuICBuYW1lOiBcImxvbmdTdHJpbmdcIixcbiAgdHlwZTogXCJzdHJpbmdcIixcbiAgdmFsdWU6IFwic29saWRpdHkgYWxsb2NhdGlvbiBpcyBhIGZ1biBsZXNzb24gaW4gZW5kaWFubmVzc1wiXG59XTtcblxuY29uc3QgbWFwcGluZ0ZpeHR1cmVzID0gW3tcbiAgLy8gbmFtZTogXCJzaW1wbGVNYXBwaW5nXCIsXG4gIC8vIHR5cGU6IHtcbiAgLy8gICBmcm9tOiBcInVpbnQyNTZcIixcbiAgLy8gICB0bzogXCJ1aW50MjU2XCJcbiAgLy8gfSxcbiAgLy8gdmFsdWU6IHtcbiAgLy8gICAuLi5PYmplY3QuYXNzaWduKHt9LCAuLi5nZW5lcmF0ZUFycmF5KDUpLm1hcChcbiAgLy8gICAgICh2YWx1ZSwgaWR4KSA9PiAoeyBbaWR4XTogdmFsdWUgfSlcbiAgLy8gICApKVxuICAvLyB9XG4vLyB9LCB7XG4gIC8vIG5hbWU6IFwibnVtYmVyZWRTdHJpbmdzXCIsXG4gIC8vIHR5cGU6IHtcbiAgLy8gICBmcm9tOiBcInVpbnQyNTZcIixcbiAgLy8gICB0bzogXCJzdHJpbmdcIlxuICAvLyB9LFxuICAvLyB2YWx1ZToge1xuICAvLyAgIC4uLk9iamVjdC5hc3NpZ24oe30sIC4uLmdlbmVyYXRlQXJyYXkoNykubWFwKFxuICAvLyAgICAgKHZhbHVlLCBpZHgpID0+ICh7IFt2YWx1ZV06IGZha2VyLmxvcmVtLnNsdWcoaWR4KSB9KVxuICAvLyAgICkpXG4gIC8vIH1cbi8vIH0sIHtcbiAgbmFtZTogXCJzdHJpbmdzVG9TdHJpbmdzXCIsXG4gIHR5cGU6IHtcbiAgICBmcm9tOiBcInN0cmluZ1wiLFxuICAgIHRvOiBcInN0cmluZ1wiXG4gIH0sXG4gIHZhbHVlOiB7XG4gICAgLi4uT2JqZWN0LmFzc2lnbih7fSwgLi4uWzAsMSwyLDMsNF0ubWFwKFxuICAgICAgKGlkeCkgPT4gKHsgW2Zha2VyLmxvcmVtLnNsdWcoaWR4KV06IGZha2VyLmxvcmVtLnNsdWcoaWR4KSB9KVxuICAgICkpXG4gIH1cbn1dO1xuXG5kZWJ1ZyhcIm1hcHBpbmdGaXh0dXJlcyAlT1wiLCBtYXBwaW5nRml4dHVyZXMpO1xuXG5kZXNjcmliZShcIkRlY29kaW5nXCIsIGZ1bmN0aW9uKCkge1xuXG4gIC8qXG4gICAqIFN0b3JhZ2UgVGVzdHNcbiAgICovXG4gIGRlc2NyaWJlRGVjb2RpbmcoXG4gICAgXCJTdG9yYWdlIFZhcmlhYmxlc1wiLCBjb21tb25GaXh0dXJlcywgZXZtLmN1cnJlbnQuc3RhdGUuc3RvcmFnZSxcblxuICAgIChjb250cmFjdE5hbWUsIGZpeHR1cmVzKSA9PiB7XG4gICAgICByZXR1cm4gYHByYWdtYSBzb2xpZGl0eSBeMC40LjIzO1xuXG5jb250cmFjdCAke2NvbnRyYWN0TmFtZX0ge1xuXG4gIGV2ZW50IERvbmUoKTtcblxuICAvLyBkZWNsYXJhdGlvbnNcbiAgJHtmaXh0dXJlc1xuICAgIC5tYXAoICh7dHlwZSwgbmFtZX0pID0+IGAke3R5cGV9ICR7bmFtZX07YCApXG4gICAgLmpvaW4oXCJcXG4gIFwiKX1cblxuICBmdW5jdGlvbiBydW4oKSBwdWJsaWMge1xuICAgICR7Zml4dHVyZXNcbiAgICAgIC5tYXAoICh7bmFtZSwgdmFsdWV9KSA9PiBgJHtuYW1lfSA9ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfTtgIClcbiAgICAgIC5qb2luKFwiXFxuICAgIFwiKX1cblxuICAgIGVtaXQgRG9uZSgpO1xuICB9XG59XG5gICAgfVxuICApO1xuXG4gIGRlc2NyaWJlRGVjb2RpbmcoXG4gICAgXCJNYXBwaW5nIFZhcmlhYmxlc1wiLCBtYXBwaW5nRml4dHVyZXMsIGV2bS5jdXJyZW50LnN0YXRlLnN0b3JhZ2UsXG5cbiAgICAoY29udHJhY3ROYW1lLCBmaXh0dXJlcykgPT4ge1xuICAgICAgcmV0dXJuIGBwcmFnbWEgc29saWRpdHkgXjAuNC4yNDtcblxuY29udHJhY3QgJHtjb250cmFjdE5hbWV9IHtcbiAgZXZlbnQgRG9uZSgpO1xuXG4gIC8vIGRlY2xhcmF0aW9uc1xuICAke2ZpeHR1cmVzXG4gICAgLm1hcCggKHtuYW1lLCB0eXBlOiB7ZnJvbSwgdG99fSkgPT4gYG1hcHBpbmcgKCR7ZnJvbX0gPT4gJHt0b30pICR7bmFtZX07YCApXG4gICAgLmpvaW4oXCJcXG4gIFwiKX1cblxuICBmdW5jdGlvbiBydW4oKSBwdWJsaWMge1xuICAgICR7Zml4dHVyZXNcbiAgICAgIC5tYXAoXG4gICAgICAgICh7bmFtZSwgdHlwZToge2Zyb219LCB2YWx1ZX0pID0+XG4gICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpXG4gICAgICAgICAgICAubWFwKCAoW2ssIHZdKSA9PiAoZnJvbSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgPyBgJHtuYW1lfVtcIiR7a31cIl0gPSAke0pTT04uc3RyaW5naWZ5KHYpfTtgXG4gICAgICAgICAgICAgIDogYCR7bmFtZX1bJHtrfV0gPSAke0pTT04uc3RyaW5naWZ5KHYpfTtgXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuam9pbihcIlxcbiAgICBcIilcbiAgICAgIClcbiAgICAgIC5qb2luKFwiXFxuXFxuICAgIFwiKX1cblxuICAgIGVtaXQgRG9uZSgpO1xuICB9XG59XG5gXG4gICAgfVxuICApO1xuXG4gIC8qXG4gICAqIE1lbW9yeSBUZXN0c1xuICAgKi9cbiAgZGVzY3JpYmVEZWNvZGluZyhcbiAgICBcIk1lbW9yeSBWYXJpYWJsZXNcIiwgY29tbW9uRml4dHVyZXMsIGV2bS5jdXJyZW50LnN0YXRlLm1lbW9yeSxcblxuICAgIChjb250cmFjdE5hbWUsIGZpeHR1cmVzKSA9PiB7XG4gICAgICBjb25zdCBzZXBhcmF0b3IgPSBcIjtcXG4gICAgXCI7XG5cbiAgICAgIGZ1bmN0aW9uIGRlY2xhcmVBc3NpZ24oe25hbWUsIHR5cGUsIHZhbHVlfSkge1xuICAgICAgICBpZiAodHlwZS5pbmRleE9mKFwiW11cIikgIT0gLTEpIHtcbiAgICAgICAgICAvLyBhcnJheSwgbXVzdCBgbmV3YFxuICAgICAgICAgIGxldCBkZWNsYXJlID0gYCR7dHlwZX0gbWVtb3J5ICR7bmFtZX0gPSBuZXcgJHt0eXBlfSgke3ZhbHVlLmxlbmd0aH0pYFxuICAgICAgICAgIGxldCBhc3NpZ25zID0gdmFsdWUubWFwKChrLCBpKSA9PiBgJHtuYW1lfVske2l9XSA9ICR7a31gKTtcbiAgICAgICAgICByZXR1cm4gYCR7ZGVjbGFyZX0ke3NlcGFyYXRvcn0ke2Fzc2lnbnMuam9pbihzZXBhcmF0b3IpfWBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYCR7dHlwZX0gbWVtb3J5ICR7bmFtZX0gPSAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGBwcmFnbWEgc29saWRpdHkgXjAuNC4yMztcblxuY29udHJhY3QgJHtjb250cmFjdE5hbWV9IHtcblxuICBldmVudCBEb25lKCk7XG5cbiAgZnVuY3Rpb24gcnVuKCkgcHVibGljIHtcbiAgICB1aW50IGk7XG4gICAgLy8gZGVjbGFyYXRpb25zXG4gICAgJHtmaXh0dXJlcy5tYXAoZGVjbGFyZUFzc2lnbikuam9pbihzZXBhcmF0b3IpfTtcblxuICAgIGVtaXQgRG9uZSgpO1xuICB9XG59XG5gXG4gICAgfVxuICApO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gdGVzdC9kYXRhL2RlY29kZS9kZWNvZGluZy5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeVwiXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJmYWtlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImZha2VyXCJcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNoYW5nZS1jYXNlXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiY2hhbmdlLWNhc2VcIlxuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcInRlc3Q6ZGF0YTpkZWNvZGU6dXRpbHNcIik7XG5cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCJjaGFpXCI7XG5cbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJiaWdudW1iZXIuanNcIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCJsaWIvZGF0YS9kZWNvZGUvdXRpbHNcIjtcblxuZGVzY3JpYmUoXCJVdGlsc1wiLCBmdW5jdGlvbigpIHtcbiAgZGVzY3JpYmUoXCJ0eXBlQ2xhc3MoKVwiLCBmdW5jdGlvbigpIHtcbiAgICBpdChcImhhbmRsZXMgbWFwcGluZ3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgdHlwZURlc2NyaXB0aW9uczoge1xuICAgICAgICAgIHR5cGVJZGVudGlmaWVyOiBcInRfbWFwcGluZyRfdF91aW50MjU2XyRfdF91aW50MjU2XyRcIlxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBhc3NlcnQuZXF1YWwodXRpbHMudHlwZUNsYXNzKGRlZmluaXRpb24pLCBcIm1hcHBpbmdcIik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwidG9CaWdOdW1iZXIoKVwiLCBmdW5jdGlvbigpIHtcbiAgICBpdChcInJldHVybnMgY29ycmVjdCB2YWx1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGxldCBieXRlcyA9IFsweGY1LCAweGUyLCAweGM1LCAweDE3XTtcbiAgICAgIGxldCBleHBlY3RlZFZhbHVlID0gbmV3IEJpZ051bWJlcihcImY1ZTJjNTE3XCIsIDE2KTtcblxuICAgICAgbGV0IHJlc3VsdCA9IHV0aWxzLnRvQmlnTnVtYmVyKGJ5dGVzKTtcblxuICAgICAgYXNzZXJ0LmVxdWFsKHJlc3VsdC50b1N0cmluZygpLCBleHBlY3RlZFZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH0pXG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwidG9TaWduZWRCaWdOdW1iZXIoKVwiLCBmdW5jdGlvbigpIHtcbiAgICBpdChcInJldHVybnMgY29ycmVjdCBuZWdhdGl2ZSB2YWx1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGxldCBieXRlcyA9IFsweGY1LCAweGUyLCAweGM1LCAweDE3XTsgIC8vIHN0YXJ0cyB3aXRoIDBiMVxuICAgICAgbGV0IHJhdyA9IG5ldyBCaWdOdW1iZXIoXCJmNWUyYzUxN1wiLCAxNik7XG4gICAgICBsZXQgYml0ZmlwcGVkID0gbmV3IEJpZ051bWJlcihcbiAgICAgICAgcmF3LnRvU3RyaW5nKDIpXG4gICAgICAgICAgLnJlcGxhY2UoLzAvZywgXCJ4XCIpXG4gICAgICAgICAgLnJlcGxhY2UoLzEvZywgXCIwXCIpXG4gICAgICAgICAgLnJlcGxhY2UoL3gvZywgXCIxXCIpLFxuICAgICAgICAyXG4gICAgICApO1xuXG4gICAgICBsZXQgZXhwZWN0ZWRWYWx1ZSA9IGJpdGZpcHBlZC5wbHVzKDEpLm5lZ2F0ZWQoKTtcblxuICAgICAgbGV0IHJlc3VsdCA9IHV0aWxzLnRvU2lnbmVkQmlnTnVtYmVyKGJ5dGVzKTtcblxuICAgICAgYXNzZXJ0LmVxdWFsKHJlc3VsdC50b1N0cmluZygpLCBleHBlY3RlZFZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJyZXR1cm5zIGNvcnJlY3QgcG9zaXRpdmUgdmFsdWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgYnl0ZXMgPSBbMHgwNSwgMHhlMiwgMHhjNSwgMHgxN107IC8vIHN0YXJ0cyB3aXRoIDBiMFxuICAgICAgbGV0IHJhdyA9IG5ldyBCaWdOdW1iZXIoXCIwNWUyYzUxN1wiLCAxNik7XG4gICAgICBsZXQgZXhwZWN0ZWRWYWx1ZSA9IHJhdztcblxuICAgICAgbGV0IHJlc3VsdCA9IHV0aWxzLnRvU2lnbmVkQmlnTnVtYmVyKGJ5dGVzKTtcblxuICAgICAgYXNzZXJ0LmVxdWFsKHJlc3VsdC50b1N0cmluZygpLCBleHBlY3RlZFZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH0pXG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwidG9IZXhTdHJpbmcoKVwiLCBmdW5jdGlvbigpIHtcbiAgICBpdChcInJldHVybnMgY29ycmVjdCByZXByZXNlbnRhdGlvbiB3aXRoIGZ1bGwgYnl0ZXNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpZSwgMHgwMCBpbnN0ZWFkIG9mIDB4MFxuICAgICAgYXNzZXJ0LmVxdWFsKHV0aWxzLnRvSGV4U3RyaW5nKFsweDA1LCAweDExXSksIFwiMHgwNTExXCIpO1xuICAgICAgYXNzZXJ0LmVxdWFsKHV0aWxzLnRvSGV4U3RyaW5nKFsweGZmLCAweDAwLCAweGZmXSksIFwiMHhmZjAwZmZcIik7XG4gICAgfSk7XG5cbiAgICBpdChcImFsbG93cyByZW1vdmluZyBsZWFkaW5nIHplcm9lc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgIGFzc2VydC5lcXVhbCh1dGlscy50b0hleFN0cmluZyhbMHgwMCwgMHgwMCwgMHhjY10sIHRydWUpLCBcIjB4Y2NcIik7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gdGVzdC9kYXRhL2RlY29kZS91dGlscy5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJ0ZXN0OnNvbGlkaXR5XCIpO1xuXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiY2hhaVwiO1xuXG5pbXBvcnQgR2FuYWNoZSBmcm9tIFwiZ2FuYWNoZS1jbGlcIjtcbmltcG9ydCBXZWIzIGZyb20gXCJ3ZWIzXCI7XG5cbmltcG9ydCB7IHByZXBhcmVDb250cmFjdHMgfSBmcm9tIFwiLi9oZWxwZXJzXCI7XG5pbXBvcnQgRGVidWdnZXIgZnJvbSBcImxpYi9kZWJ1Z2dlclwiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3NlbGVjdG9yc1wiO1xuXG5cbmNvbnN0IF9fT1VURVIgPSBgXG5wcmFnbWEgc29saWRpdHkgXjAuNC4xODtcblxuaW1wb3J0IFwiLi9Jbm5lci5zb2xcIjtcblxuY29udHJhY3QgT3V0ZXIge1xuICBldmVudCBDYWxsZWQoKTtcblxuICBJbm5lciBpbm5lcjtcblxuICBmdW5jdGlvbiBPdXRlcihhZGRyZXNzIF9pbm5lcikge1xuICAgIGlubmVyID0gSW5uZXIoX2lubmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1blNpbmdsZSgpIHB1YmxpYyB7XG4gIH1cblxuICBmdW5jdGlvbiBydW4oKSBwdWJsaWMge1xuICAgIGlubmVyLnJ1bigpO1xuICB9XG59XG5gO1xuXG5cbmNvbnN0IF9fSU5ORVIgPSBgXG5wcmFnbWEgc29saWRpdHkgXjAuNC4xODtcblxuY29udHJhY3QgSW5uZXIge1xuICBmdW5jdGlvbiBydW4oKSBwdWJsaWMge1xuICB9XG59XG5gO1xuXG5jb25zdCBfX01JR1JBVElPTiA9IGBcbmxldCBPdXRlciA9IGFydGlmYWN0cy5yZXF1aXJlKFwiT3V0ZXJcIik7XG5sZXQgSW5uZXIgPSBhcnRpZmFjdHMucmVxdWlyZShcIklubmVyXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRlcGxveWVyKSB7XG4gIHJldHVybiBkZXBsb3llclxuICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlcGxveWVyLmRlcGxveShJbm5lcik7XG4gICAgfSlcbiAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJbm5lci5kZXBsb3llZCgpO1xuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24oaW5uZXIpIHtcbiAgICAgIHJldHVybiBkZXBsb3llci5kZXBsb3koT3V0ZXIsIGlubmVyLmFkZHJlc3MpO1xuICAgIH0pO1xufTtcbmA7XG5cbmxldCBzb3VyY2VzID0ge1xuICBcIklubmVyLnNvbFwiOiBfX0lOTkVSLFxuICBcIk91dGVyLnNvbFwiOiBfX09VVEVSLFxufVxuXG5sZXQgbWlncmF0aW9ucyA9IHtcbiAgXCIyX2RlcGxveV9jb250cmFjdHMuanNcIjogX19NSUdSQVRJT04sXG59O1xuXG5kZXNjcmliZShcIkVWTSBEZWJ1Z2dpbmdcIiwgZnVuY3Rpb24oKSB7XG4gIHZhciBwcm92aWRlcjtcbiAgdmFyIHdlYjM7XG5cbiAgdmFyIGFic3RyYWN0aW9ucztcbiAgdmFyIGFydGlmYWN0cztcbiAgdmFyIGZpbGVzO1xuXG4gIGJlZm9yZShcIkNyZWF0ZSBQcm92aWRlclwiLCBhc3luYyBmdW5jdGlvbigpIHtcbiAgICBwcm92aWRlciA9IEdhbmFjaGUucHJvdmlkZXIoe3NlZWQ6IFwiZGVidWdnZXJcIiwgZ2FzTGltaXQ6IDcwMDAwMDB9KTtcbiAgICB3ZWIzID0gbmV3IFdlYjMocHJvdmlkZXIpO1xuICB9KTtcblxuICBiZWZvcmUoXCJQcmVwYXJlIGNvbnRyYWN0cyBhbmQgYXJ0aWZhY3RzXCIsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGltZW91dCgzMDAwMCk7XG5cbiAgICBsZXQgcHJlcGFyZWQgPSBhd2FpdCBwcmVwYXJlQ29udHJhY3RzKHByb3ZpZGVyLCBzb3VyY2VzLCBtaWdyYXRpb25zKVxuICAgIGFic3RyYWN0aW9ucyA9IHByZXBhcmVkLmFic3RyYWN0aW9ucztcbiAgICBhcnRpZmFjdHMgPSBwcmVwYXJlZC5hcnRpZmFjdHM7XG4gICAgZmlsZXMgPSBwcmVwYXJlZC5maWxlcztcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJGdW5jdGlvbiBEZXB0aFwiLCBmdW5jdGlvbigpIHtcbiAgICBpdChcInJlbWFpbnMgYXQgMSBpbiBhYnNlbmNlIG9mIGNyb3NzLWNvbnRyYWN0IGNhbGxzXCIsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbWF4RXhwZWN0ZWQgPSAxO1xuXG4gICAgICBsZXQgaW5zdGFuY2UgPSBhd2FpdCBhYnN0cmFjdGlvbnMuSW5uZXIuZGVwbG95ZWQoKTtcbiAgICAgIGxldCByZWNlaXB0ID0gYXdhaXQgaW5zdGFuY2UucnVuKCk7XG4gICAgICBsZXQgdHhIYXNoID0gcmVjZWlwdC50eDtcblxuICAgICAgbGV0IGJ1Z2dlciA9IGF3YWl0IERlYnVnZ2VyLmZvclR4KHR4SGFzaCwge1xuICAgICAgICBwcm92aWRlcixcbiAgICAgICAgZmlsZXMsXG4gICAgICAgIGNvbnRyYWN0czogYXJ0aWZhY3RzXG4gICAgICB9KTtcblxuICAgICAgbGV0IHNlc3Npb24gPSBidWdnZXIuY29ubmVjdCgpO1xuICAgICAgdmFyIHN0ZXBwZWQ7ICAvLyBzZXNzaW9uIHN0ZXBwZXJzIHJldHVybiBmYWxzZSB3aGVuIGRvbmVcblxuICAgICAgZG8ge1xuICAgICAgICBzdGVwcGVkID0gc2Vzc2lvbi5zdGVwTmV4dCgpO1xuXG4gICAgICAgIGxldCBhY3R1YWwgPSBzZXNzaW9uLnZpZXcoZXZtLmN1cnJlbnQuY2FsbHN0YWNrKS5sZW5ndGg7XG5cbiAgICAgICAgYXNzZXJ0LmlzQXRNb3N0KGFjdHVhbCwgbWF4RXhwZWN0ZWQpO1xuXG4gICAgICB9IHdoaWxlKHN0ZXBwZWQpO1xuXG4gICAgfSk7XG5cbiAgICBpdChcInRyYWNrcyBjYWxsc3RhY2sgY29ycmVjdGx5XCIsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gcHJlcGFyZVxuICAgICAgbGV0IGluc3RhbmNlID0gYXdhaXQgYWJzdHJhY3Rpb25zLk91dGVyLmRlcGxveWVkKCk7XG4gICAgICBsZXQgcmVjZWlwdCA9IGF3YWl0IGluc3RhbmNlLnJ1bigpO1xuICAgICAgbGV0IHR4SGFzaCA9IHJlY2VpcHQudHg7XG5cbiAgICAgIGxldCBidWdnZXIgPSBhd2FpdCBEZWJ1Z2dlci5mb3JUeCh0eEhhc2gsIHtcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIGZpbGVzLFxuICAgICAgICBjb250cmFjdHM6IGFydGlmYWN0c1xuICAgICAgfSk7XG5cbiAgICAgIGxldCBzZXNzaW9uID0gYnVnZ2VyLmNvbm5lY3QoKTtcblxuICAgICAgLy8gZm9sbG93IGNhbGxzdGFjayBsZW5ndGggdmFsdWVzIGluIGxpc3RcbiAgICAgIC8vIHNlZSBzb3VyY2UgYWJvdmVcbiAgICAgIGxldCBleHBlY3RlZERlcHRoU2VxdWVuY2UgPSBbMSwyLDEsMF07XG4gICAgICBsZXQgYWN0dWFsU2VxdWVuY2UgPSBbc2Vzc2lvbi52aWV3KGV2bS5jdXJyZW50LmNhbGxzdGFjaykubGVuZ3RoXTtcblxuICAgICAgdmFyIHN0ZXBwZWQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgc3RlcHBlZCA9IHNlc3Npb24uc3RlcE5leHQoKTtcblxuICAgICAgICBsZXQgY3VycmVudERlcHRoID0gc2Vzc2lvbi52aWV3KGV2bS5jdXJyZW50LmNhbGxzdGFjaykubGVuZ3RoO1xuICAgICAgICBsZXQgbGFzdEtub3duID0gYWN0dWFsU2VxdWVuY2VbYWN0dWFsU2VxdWVuY2UubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGN1cnJlbnREZXB0aCAhPT0gbGFzdEtub3duKSB7XG4gICAgICAgICAgYWN0dWFsU2VxdWVuY2UucHVzaChjdXJyZW50RGVwdGgpO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlKHN0ZXBwZWQpO1xuXG4gICAgICBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbFNlcXVlbmNlLCBleHBlY3RlZERlcHRoU2VxdWVuY2UpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHRlc3QvZXZtLmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcInRlc3Q6c29saWRpdHlcIik7XG5cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCJjaGFpXCI7XG5cbmltcG9ydCBHYW5hY2hlIGZyb20gXCJnYW5hY2hlLWNsaVwiO1xuaW1wb3J0IFdlYjMgZnJvbSBcIndlYjNcIjtcblxuaW1wb3J0IHsgcHJlcGFyZUNvbnRyYWN0cyB9IGZyb20gXCIuL2hlbHBlcnNcIjtcbmltcG9ydCBEZWJ1Z2dlciBmcm9tIFwibGliL2RlYnVnZ2VyXCI7XG5cbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuXG5cbmNvbnN0IF9fU0lOR0xFX0NBTEwgPSBgXG5wcmFnbWEgc29saWRpdHkgXjAuNC4xODtcblxuY29udHJhY3QgU2luZ2xlQ2FsbCB7XG4gIGV2ZW50IENhbGxlZCgpO1xuXG4gIGZ1bmN0aW9uIHJ1bigpIHB1YmxpYyB7XG4gICAgQ2FsbGVkKCk7XG4gIH1cbn1cbmA7XG5cblxuY29uc3QgX19ORVNURURfQ0FMTCA9IGBwcmFnbWEgc29saWRpdHkgXjAuNC4xODtcblxuY29udHJhY3QgTmVzdGVkQ2FsbCB7XG4gIGV2ZW50IEZpcnN0KCk7XG4gIGV2ZW50IFNlY29uZCgpO1xuXG4gIC8vIHJ1bigpXG4gIC8vICAgZmlyc3QoKSAgICAxXG4gIC8vICAgICBpbm5lcigpICAyXG4gIC8vICAgICAgIGV2ZW50ICAzXG4gIC8vICAgICAgICAgICAgICAyXG4gIC8vICAgc2Vjb25kICAgICAxXG4gIC8vICAgICBldmVudCAgICAyXG4gIC8vICAgICAgICAgICAgICAxXG4gIGZ1bmN0aW9uIHJ1bigpIHB1YmxpYyB7XG4gICAgZmlyc3QoKTtcbiAgICBzZWNvbmQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcnN0KCkgcHVibGljIHtcbiAgICBpbm5lcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5uZXIoKSBwdWJsaWMge1xuICAgIEZpcnN0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWNvbmQoKSBwdWJsaWMge1xuICAgIFNlY29uZCgpO1xuICB9XG5cbn1cbmA7XG5cblxubGV0IHNvdXJjZXMgPSB7XG4gIFwiU2luZ2xlQ2FsbC5zb2xcIjogX19TSU5HTEVfQ0FMTCxcbiAgXCJOZXN0ZWRDYWxsLnNvbFwiOiBfX05FU1RFRF9DQUxMLFxufVxuXG5cbmRlc2NyaWJlKFwiU29saWRpdHkgRGVidWdnaW5nXCIsIGZ1bmN0aW9uKCkge1xuICB2YXIgcHJvdmlkZXI7XG4gIHZhciB3ZWIzO1xuXG4gIHZhciBhYnN0cmFjdGlvbnM7XG4gIHZhciBhcnRpZmFjdHM7XG4gIHZhciBmaWxlcztcblxuICBiZWZvcmUoXCJDcmVhdGUgUHJvdmlkZXJcIiwgYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgcHJvdmlkZXIgPSBHYW5hY2hlLnByb3ZpZGVyKHtzZWVkOiBcImRlYnVnZ2VyXCIsIGdhc0xpbWl0OiA3MDAwMDAwfSk7XG4gICAgd2ViMyA9IG5ldyBXZWIzKHByb3ZpZGVyKTtcbiAgfSk7XG5cbiAgYmVmb3JlKFwiUHJlcGFyZSBjb250cmFjdHMgYW5kIGFydGlmYWN0c1wiLCBhc3luYyBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRpbWVvdXQoMzAwMDApO1xuXG4gICAgbGV0IHByZXBhcmVkID0gYXdhaXQgcHJlcGFyZUNvbnRyYWN0cyhwcm92aWRlciwgc291cmNlcylcbiAgICBhYnN0cmFjdGlvbnMgPSBwcmVwYXJlZC5hYnN0cmFjdGlvbnM7XG4gICAgYXJ0aWZhY3RzID0gcHJlcGFyZWQuYXJ0aWZhY3RzO1xuICAgIGZpbGVzID0gcHJlcGFyZWQuZmlsZXM7XG4gIH0pO1xuXG4gIGl0KFwiZXhwb3NlcyBmdW5jdGlvbmFsaXR5IHRvIHN0b3AgYXQgYnJlYWtwb2ludHNcIiwgYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgLy8gcHJlcGFyZVxuICAgIGxldCBpbnN0YW5jZSA9IGF3YWl0IGFic3RyYWN0aW9ucy5OZXN0ZWRDYWxsLmRlcGxveWVkKCk7XG4gICAgbGV0IHJlY2VpcHQgPSBhd2FpdCBpbnN0YW5jZS5ydW4oKTtcbiAgICBsZXQgdHhIYXNoID0gcmVjZWlwdC50eDtcblxuICAgIGxldCBidWdnZXIgPSBhd2FpdCBEZWJ1Z2dlci5mb3JUeCh0eEhhc2gsIHtcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgZmlsZXMsXG4gICAgICBjb250cmFjdHM6IGFydGlmYWN0c1xuICAgIH0pO1xuXG4gICAgbGV0IHNlc3Npb24gPSBidWdnZXIuY29ubmVjdCgpO1xuXG4gICAgLy8gYXQgYHNlY29uZCgpO2BcbiAgICBsZXQgYnJlYWtwb2ludCA9IHsgXCJhZGRyZXNzXCI6IGluc3RhbmNlLmFkZHJlc3MsIGxpbmU6IDE2IH1cbiAgICBsZXQgYnJlYWtwb2ludFN0b3BwZWQgPSBmYWxzZTtcblxuICAgIGRvIHtcbiAgICAgIHNlc3Npb24uY29udGludWVVbnRpbChicmVha3BvaW50KTtcblxuICAgICAgaWYgKCFzZXNzaW9uLmZpbmlzaGVkKSB7XG4gICAgICAgIGxldCByYW5nZSA9IGF3YWl0IHNlc3Npb24udmlldyhzb2xpZGl0eS5jdXJyZW50LnNvdXJjZVJhbmdlKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHJhbmdlLmxpbmVzLnN0YXJ0LmxpbmUsIDE2KTtcblxuICAgICAgICBicmVha3BvaW50U3RvcHBlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICB9IHdoaWxlKCFzZXNzaW9uLmZpbmlzaGVkKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJGdW5jdGlvbiBEZXB0aFwiLCBmdW5jdGlvbigpIHtcbiAgICBpdChcInJlbWFpbnMgYXQgMSBpbiBhYnNlbmNlIG9mIGlubmVyIGZ1bmN0aW9uIGNhbGxzXCIsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbWF4RXhwZWN0ZWQgPSAxO1xuXG4gICAgICBsZXQgaW5zdGFuY2UgPSBhd2FpdCBhYnN0cmFjdGlvbnMuU2luZ2xlQ2FsbC5kZXBsb3llZCgpO1xuICAgICAgbGV0IHJlY2VpcHQgPSBhd2FpdCBpbnN0YW5jZS5ydW4oKTtcbiAgICAgIGxldCB0eEhhc2ggPSByZWNlaXB0LnR4O1xuXG4gICAgICBsZXQgYnVnZ2VyID0gYXdhaXQgRGVidWdnZXIuZm9yVHgodHhIYXNoLCB7XG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBmaWxlcyxcbiAgICAgICAgY29udHJhY3RzOiBhcnRpZmFjdHNcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgc2Vzc2lvbiA9IGJ1Z2dlci5jb25uZWN0KCk7XG4gICAgICB2YXIgc3RlcHBlZDsgIC8vIHNlc3Npb24gc3RlcHBlcnMgcmV0dXJuIGZhbHNlIHdoZW4gZG9uZVxuXG4gICAgICBkbyB7XG4gICAgICAgIHN0ZXBwZWQgPSBzZXNzaW9uLnN0ZXBOZXh0KCk7XG5cbiAgICAgICAgbGV0IGFjdHVhbCA9IHNlc3Npb24udmlldyhzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpO1xuXG4gICAgICAgIGFzc2VydC5pc0F0TW9zdChhY3R1YWwsIG1heEV4cGVjdGVkKTtcblxuICAgICAgfSB3aGlsZShzdGVwcGVkKTtcblxuICAgIH0pO1xuXG4gICAgaXQoXCJzcGVsdW5rcyBjb3JyZWN0bHlcIiwgYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAvLyBwcmVwYXJlXG4gICAgICBsZXQgaW5zdGFuY2UgPSBhd2FpdCBhYnN0cmFjdGlvbnMuTmVzdGVkQ2FsbC5kZXBsb3llZCgpO1xuICAgICAgbGV0IHJlY2VpcHQgPSBhd2FpdCBpbnN0YW5jZS5ydW4oKTtcbiAgICAgIGxldCB0eEhhc2ggPSByZWNlaXB0LnR4O1xuXG4gICAgICBsZXQgYnVnZ2VyID0gYXdhaXQgRGVidWdnZXIuZm9yVHgodHhIYXNoLCB7XG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBmaWxlcyxcbiAgICAgICAgY29udHJhY3RzOiBhcnRpZmFjdHNcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgc2Vzc2lvbiA9IGJ1Z2dlci5jb25uZWN0KCk7XG5cbiAgICAgIC8vIGZvbGxvdyBmdW5jdGlvbkRlcHRoIHZhbHVlcyBpbiBsaXN0XG4gICAgICAvLyBzZWUgc291cmNlIGFib3ZlXG4gICAgICBsZXQgZXhwZWN0ZWREZXB0aFNlcXVlbmNlID0gWzEsMiwzLDIsMSwyLDEsMF07XG4gICAgICBsZXQgYWN0dWFsU2VxdWVuY2UgPSBbc2Vzc2lvbi52aWV3KHNvbGlkaXR5LmN1cnJlbnQuZnVuY3Rpb25EZXB0aCldO1xuXG4gICAgICB2YXIgc3RlcHBlZDtcblxuICAgICAgZG8ge1xuICAgICAgICBzdGVwcGVkID0gc2Vzc2lvbi5zdGVwTmV4dCgpO1xuXG4gICAgICAgIGxldCBjdXJyZW50RGVwdGggPSBzZXNzaW9uLnZpZXcoc29saWRpdHkuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgICAgICAgbGV0IGxhc3RLbm93biA9IGFjdHVhbFNlcXVlbmNlW2FjdHVhbFNlcXVlbmNlLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChjdXJyZW50RGVwdGggIT09IGxhc3RLbm93bikge1xuICAgICAgICAgIGFjdHVhbFNlcXVlbmNlLnB1c2goY3VycmVudERlcHRoKTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZShzdGVwcGVkKTtcblxuICAgICAgYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWxTZXF1ZW5jZSwgZXhwZWN0ZWREZXB0aFNlcXVlbmNlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB0ZXN0L3NvbGlkaXR5LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzdEQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQUxBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUdBOzs7QUFHQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFLQTs7Ozs7QUFLQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFHQTs7Ozs7QUFLQTtBQS9DQTtBQUNBO0FBbURBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQUNBO0FBaUJBOzs7OztBQUtBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBdkJBO0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRkE7QUFDQTtBQUlBO0FBZkE7QUFSQTtBQWRBO0FBQ0E7QUE0Q0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBS0E7OztBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRkE7QUFqQ0E7QUFDQTtBQXVDQTs7Ozs7QUFLQTtBQVNBO0FBREE7QUFDQTtBQUlBOzs7QUFHQTtBQTdEQTtBQUNBO0FBK0RBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFTQTtBQURBO0FBQ0E7QUFJQTtBQXBCQTtBQTVIQTtBQUNBO0FBbUpBOzs7Ozs7QUM1UUE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7QUNFQTtBQVlBO0FBQ0E7QUFmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7Ozs7OztBQVBBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSkE7QUFIQTtBQVlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFUQTtBQUNBO0FBV0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQVJBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUhBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBUEE7QUE5QkE7QUFuREE7QUFDQTtBQTZGQTs7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFuSEE7QUFDQTtBQXNIQTs7O0FBR0E7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBS0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEtBO0FBQ0E7QUF1S0E7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQXpMQTtBQXhCQTtBQUNBO0FBc05BOzs7Ozs7QUMvT0E7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNZQTtBQWtCQTtBQVVBO0FBU0E7QUFrRkE7QUFzQkE7QUF3QkE7QUFJQTtBQUlBO0FBSUE7QUFxQkE7QUFlQTtBQWFBO0FBMENBO0FBd0JBO0FBQ0E7QUFqVEE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFKQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFEQTtBQUlBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFPQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNwVUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUF0Q0E7Ozs7OztBQWlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTs7Ozs7O0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7Ozs7OztBQVlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUpBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7Ozs7OztBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBOzs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOzs7OztBQWxHQTtBQUNBO0FBdkRBO0FBQ0E7OztBQUVBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBYkE7QUFDQTtBQW9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5REE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7Ozs7O0FBUkE7QUFDQTtBQVNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUpBO0FBQ0E7QUFNQTs7O0FBR0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFHQTs7Ozs7QUFLQTtBQUNBO0FBR0E7Ozs7O0FBS0E7QUFDQTtBQUtBOzs7OztBQUtBO0FBQ0E7QUFyQ0E7QUFkQTtBQUNBO0FBMkRBOzs7Ozs7QUMxRUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTs7OztBQUlBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBakJBO0FBa0JBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBeEVBO0FBQ0E7QUFEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBR0E7Ozs7O0FBS0E7QUFDQTtBQUdBOzs7OztBQUtBO0FBdENBO0FBQ0E7QUEyQ0E7Ozs7OztBQzlDQTs7Ozs7Ozs7Ozs7O0FDQ0E7QUFRQTtBQVFBO0FBS0E7QUFLQTtBQUtBO0FBaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2xDQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7QUNDQTtBQVFBO0FBT0E7QUFRQTtBQU9BO0FBL0JBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBYkE7QUFDQTtBQWFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQU9BOzs7QUFHQTtBQUNBO0FBUUE7OztBQUdBO0FBTUE7QUFEQTtBQWhDQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQU1BO0FBQ0E7QUFFQTtBQUhBO0FBREE7QUFWQTtBQUNBO0FBdUJBOzs7OztBQUtBO0FBSUE7QUFKQTtBQXpDQTtBQUNBO0FBaURBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBTEE7QUFDQTtBQU9BOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBTEE7QUFDQTtBQU9BOzs7QUFHQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7QUFHQTtBQUxBO0FBQ0E7QUFTQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQVJBO0FBQ0E7QUFVQTtBQTVCQTtBQUNBO0FBK0JBOzs7OztBQUtBO0FBU0E7QUFDQTtBQUNBO0FBaERBO0FBQ0E7QUFvREE7Ozs7O0FBS0E7QUFTQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBdEVBO0FBQ0E7QUE0RUE7QUFVQTtBQURBO0FBQ0E7QUFLQTtBQTVGQTtBQXZCQTtBQUNBO0FBc0hBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBTEE7QUEzTUE7QUFDQTtBQW1OQTs7Ozs7O0FDaFJBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ1NBO0FBY0E7QUF5QkE7QUFDQTtBQWpEQTtBQUNBOzs7QUFFQTtBQUNBOzs7Ozs7O0FBSEE7QUFDQTtBQUlBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7Ozs7Ozs7Ozs7O0FDbkVBO0FBUUE7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBTUE7QUF4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUlBO0FBd0pBO0FBQ0E7QUE3S0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFkQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRkE7QUFJQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBRkE7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFEQTtBQUxBO0FBQ0E7QUFTQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFGQTtBQURBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBNUdBO0FBOEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyTEE7QUFRQTtBQVFBO0FBakJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRUE7QUFpQ0E7QUFJQTtBQVNBO0FBQ0E7QUF2RUE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFSQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVFQTtBQVFBO0FBU0E7QUFsQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7Ozs7Ozs7Ozs7O0FDdEJBO0FBUUE7QUFRQTtBQVFBO0FBUUE7QUFqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7O0FBTkE7QUFDQTtBQU1BO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFkQTtBQUxBO0FBSkE7QUFDQTtBQWtDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeEJBOzs7Ozs7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFUQTs7Ozs7QUE3REE7QUF1RUE7QUFDQTtBQXpGQTtBQUNBOzs7QUFFQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQWZBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFxQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFkQTtBQUNBO0FBY0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUE2QkE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQ2pIQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBOzs7QUFFQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWRBO0FBQ0E7QUFjQTs7O0FBR0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUxBO0FBREE7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakpBO0FBQUE7Ozs7OztBQ25CQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDN0NBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNPQTtBQXlDQTtBQUNBO0FBbERBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7O0FBTkE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQVRBO0FBWUE7QUFEQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQy9FQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7OztBQ2lCQTtBQUNBO0FBbEJBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFmQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOURBO0FBZ0JBO0FBQ0E7QUEvRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVhBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0VBO0FBYUE7QUEyQ0E7QUE4RUE7QUFtSEE7QUFnREE7QUFDQTtBQXBUQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQVBBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTVCQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUdBO0FBREE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUhBO0FBSEE7QUFDQTtBQVdBO0FBQ0E7QUFEQTtBQXZCQTtBQUNBO0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBckVBO0FBd0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFkQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBbEJBO0FBQ0E7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFSQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFEQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBekdBO0FBMkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQURBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM5VEE7QUFTQTtBQStCQTtBQUNBO0FBekRBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFMQTtBQUNBO0FBTUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuREE7QUFjQTtBQWlDQTtBQUNBO0FBOURBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQUpBO0FBQ0E7QUFJQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBT0E7QUFFQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyR0E7QUFRQTtBQVRBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2VBO0FBQ0E7QUE3QkE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVhBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFlQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQW1CQTs7Ozs7Ozs7Ozs7OztBQ3pOQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7OztBQVBBO0FBQ0E7QUFPQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQWRBO0FBbkJBO0FBTEE7QUFDQTtBQTBDQTs7Ozs7Ozs7Ozs7O0FDakRBO0FBSUE7QUFvQkE7QUFDQTtBQXBDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFUQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQVdBO0FBV0E7QUFRQTtBQXdCQTtBQUNBO0FBdkVBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVRBO0FBQ0E7QUFTQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdkJBO0FBdUJBO0FBOEJBO0FBQ0E7QUF6R0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFSQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaEhBO0FBUUE7QUFRQTtBQVFBO0FBUUE7QUFRQTtBQVFBO0FBakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTs7O0FBQ0E7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFEQTtBQURBO0FBY0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFEQTtBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBREE7QUFRQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBREE7QUFGQTtBQVVBO0FBeERBO0FBQUE7Ozs7Ozs7Ozs7Ozs7QUNRQTtBQUNBO0FBZkE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBYUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTEE7QUFDQTtBQUtBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFIQTtBQURBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUhBO0FBSEE7QUFEQTtBQUNBO0FBZUE7QUFDQTtBQXhDQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUVBO0FBRkE7QUFEQTtBQU5BO0FBQ0E7QUFnQkE7QUFDQTtBQXBCQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBRUE7QUFGQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBOUZBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBSEE7QUFQQTtBQUNBO0FBYUE7OztBQUdBO0FBQ0E7QUEvQkE7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFKQTtBQVBBO0FBQ0E7QUFlQTs7O0FBR0E7QUFDQTtBQS9CQTtBQWtDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUVBO0FBRkE7QUFDQTtBQUlBOzs7Ozs7QUN4SEE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQytFQTtBQUNBO0FBaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBSkE7QUFIQTtBQUNBO0FBV0E7OztBQWJBO0FBaUJBO0FBMUJBO0FBNEJBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFGQTtBQUhBO0FBREE7QUFDQTtBQVVBOzs7QUFHQTtBQUNBO0FBdkJBO0FBeUJBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFFQTtBQUZBO0FBQ0E7QUFJQTs7Ozs7Ozs7Ozs7O0FDdkdBO0FBUUE7QUFDQTtBQWJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFFQTtBQUZBO0FBQ0E7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQVpBO0FBQ0E7QUFZQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBcUJBOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQVdBOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQWlCQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcElBO0FBQ0E7OztBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQVBBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQTVCQTtBQUNBO0FBa0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUlBO0FBQ0E7Ozs7QUFiQTtBQW1CQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUlBO0FBQ0E7Ozs7QUFaQTtBQTJCQTtBQUNBO0FBRUE7OztBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7OztBQVZBO0FBZUE7QUFFQTs7Ozs7O0FDeExBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7Ozs7OztBQ0FBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBTkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7Ozs7O0FBWEE7QUFDQTtBQVlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBdUJBOzs7Ozs7O0FBQUE7QUFDQTtBQVFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvSkE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7OztBQVhBO0FBQ0E7QUFZQTs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFZQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBREE7QUFDQTtBQWtDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=